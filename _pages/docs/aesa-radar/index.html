---
title: Design of Sensor Signal Processing with ForSyDe 0.3.1
subtitle: version 0.3.1
layout: default
permalink: docs/aesa-radar/index.html
top-navbar: true
---
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Design of Sensor Signal Processing with ForSyDe</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<header id="title-block-header">
<h1 class="title">Design of Sensor Signal Processing with ForSyDe</h1>
<p class="subtitle">version 0.3.1</p>

<!-- <p class="author">true</p>
<p class="author">true</p>
<p class="author">true</p>
<p class="author">true</p>
<p class="author">true</p>
-->
<div class="copyright-notice"><p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="figs/by-sa.png" alt="CC-BY SA 4.0" width="80px"/></href></a></p></p>
<p class="author">George Ungureanu  <small>(KTH Royal Institute of Technology, Sweden)</small></p>
<p class="author">Timmy Sundström  <small>(Saab AB, Sweden)</small></p>
<p class="author">Anders Åhlander  <small>(Saab AB, Sweden)</small></p>
<p class="author">Ingo Sander  <small>(KTH Royal Institute of Technology, Sweden)</small></p>
<p class="author">Ingemar Söderquist  <small>(Saab AB, Sweden)</small></p>


<p class="abstract"><p>This document serves as a report and as a step-by-step tutorial for modeling, simulating, testing and synthesizing complex heterogeneous systems in ForSyDe, with special focus on parallel and concurrent systems. The application under test is a radar signal processing chain for an active electronically scanned array (AESA) antenna provided by Saab AB. Throughout this report the application will be modeled using several different frameworks, gradually introducing new modeling concepts and pointing out similarities and differences between them.</p></p>



<p>There is also a <a href="aesa-report.pdf">PDF version</a> of this report. The source code used in this report is found at <a href="https://github.com/forsyde/aesa-radar">this GitHub repository</a>.</p><p></p>
</header>
<nav id="TOC">
<ul>
<li><a href="#sec:intro"><span class="toc-section-number">1</span> Introduction</a>
<ul>
<li><a href="#sec:video-chain-spec"><span class="toc-section-number">1.1</span> Application Specification</a></li>
<li><a href="#sec:usage"><span class="toc-section-number">1.2</span> Using This Document</a></li>
</ul></li>
<li><a href="#sec:atom"><span class="toc-section-number">2</span> High-Level Model of the AESA Signal Processing Chain in ForSyDe-Atom</a>
<ul>
<li><a href="#sec:crash-atom"><span class="toc-section-number">2.1</span> Quick Introduction to ForSyDe-Atom</a></li>
<li><a href="#sec:cube-atom-operation"><span class="toc-section-number">2.2</span> A High-Level Model</a>
<ul>
<li><a href="#sec:cube-aliases-atom"><span class="toc-section-number">2.2.1</span> Type Aliases and Constants</a></li>
<li><a href="#sec:cube-atom-pipe-stages"><span class="toc-section-number">2.2.2</span> Video Processing Pipeline Stages</a></li>
<li><a href="#system-process-network"><span class="toc-section-number">2.2.3</span> System Process Network</a></li>
<li><a href="#sec:aesa-parameters"><span class="toc-section-number">2.2.4</span> System Parameters</a></li>
<li><a href="#sec:coefs-atom"><span class="toc-section-number">2.2.5</span> Coefficient Generators</a></li>
</ul></li>
<li><a href="#sec:cube-atom-sim"><span class="toc-section-number">2.3</span> Model Simulation Against Test Data</a></li>
<li><a href="#conclusion"><span class="toc-section-number">2.4</span> Conclusion</a></li>
</ul></li>
<li><a href="#sec:shallow"><span class="toc-section-number">3</span> Alternative Modeling Framework: ForSyDe-Shallow</a>
<ul>
<li><a href="#sec:cube-shallow-operation"><span class="toc-section-number">3.1</span> The High-Level Model</a>
<ul>
<li><a href="#imported-libraries"><span class="toc-section-number">3.1.1</span> Imported Libraries</a></li>
<li><a href="#sec:aliases-shallow"><span class="toc-section-number">3.1.2</span> Type Synonyms</a></li>
<li><a href="#video-processing-pipeline-stages"><span class="toc-section-number">3.1.3</span> Video Processing Pipeline Stages</a></li>
<li><a href="#the-aesa-process-network"><span class="toc-section-number">3.1.4</span> The AESA Process Network</a></li>
</ul></li>
<li><a href="#sec:cube-shallow-sim"><span class="toc-section-number">3.2</span> Model Simulation Against Test Data</a></li>
<li><a href="#conclusion-1"><span class="toc-section-number">3.3</span> Conclusion</a></li>
</ul></li>
<li><a href="#sec:radar"><span class="toc-section-number">4</span> Modeling the Radar Environment</a>
<ul>
<li><a href="#sec:radar-refl"><span class="toc-section-number">4.1</span> Object Reflection Model</a>
<ul>
<li><a href="#sec:atom-radar-app1"><span class="toc-section-number">4.1.1</span> Approach 1: Translating a Numerical Program</a></li>
<li><a href="#sec:atom-radar-app2"><span class="toc-section-number">4.1.2</span> Approach 2: CT Signal Generators</a></li>
</ul></li>
<li><a href="#sec:radar-noisy-data"><span class="toc-section-number">4.2</span> Sampling Noisy Data. Using Distributions.</a></li>
<li><a href="#conclusions"><span class="toc-section-number">4.3</span> Conclusions</a></li>
</ul></li>
<li><a href="#sec:props"><span class="toc-section-number">5</span> Validating a ForSyDe Model Against the Specification</a>
<ul>
<li><a href="#sec:prop-notation"><span class="toc-section-number">5.1</span> Formal Notation</a></li>
<li><a href="#sec:prop-defs"><span class="toc-section-number">5.2</span> Properties</a>
<ul>
<li><a href="#imports"><span class="toc-section-number">5.2.1</span> Imports</a></li>
<li><a href="#formulations"><span class="toc-section-number">5.2.2</span> Formulations</a></li>
<li><a href="#main-function"><span class="toc-section-number">5.2.3</span> Main function</a></li>
<li><a href="#sec:prop-gens"><span class="toc-section-number">5.2.4</span> Data Generators</a></li>
</ul></li>
<li><a href="#running-the-test-suite.-conclusion"><span class="toc-section-number">5.3</span> Running the Test Suite. Conclusion</a></li>
</ul></li>
<li><a href="#sec:refine"><span class="toc-section-number">6</span> Refining the Model Behavior. A Streaming Interpretation of AESA</a>
<ul>
<li><a href="#sec:atom-network"><span class="toc-section-number">6.1</span> The High-Level Model</a>
<ul>
<li><a href="#libraries-and-aliases"><span class="toc-section-number">6.1.1</span> Libraries and Aliases</a></li>
<li><a href="#video-processing-stages"><span class="toc-section-number">6.1.2</span> Video Processing Stages</a></li>
<li><a href="#system-process-network-1"><span class="toc-section-number">6.1.3</span> System Process Network</a></li>
</ul></li>
<li><a href="#sec:stream-atom-sim"><span class="toc-section-number">6.2</span> Model Simulation Against Test Data</a></li>
<li><a href="#sec:stream-prop-defs"><span class="toc-section-number">6.3</span> Checking System Properties</a>
<ul>
<li><a href="#imports-1"><span class="toc-section-number">6.3.1</span> Imports</a></li>
<li><a href="#sec:atom-stream-props"><span class="toc-section-number">6.3.2</span> Properties</a></li>
<li><a href="#main-function.-test-suite-results"><span class="toc-section-number">6.3.3</span> Main function. Test Suite Results</a></li>
</ul></li>
<li><a href="#conclusion-2"><span class="toc-section-number">6.4</span> Conclusion</a></li>
</ul></li>
<li><a href="#sec:synth"><span class="toc-section-number">7</span> Model Synthesis to VHDL</a>
<ul>
<li><a href="#refinement-1-untimed-mav-to-timed-fir"><span class="toc-section-number">7.1</span> Refinement 1: Untimed MAV to Timed FIR</a>
<ul>
<li><a href="#model"><span class="toc-section-number">7.1.1</span> Model</a></li>
<li><a href="#simulation"><span class="toc-section-number">7.1.2</span> Simulation</a></li>
<li><a href="#properties"><span class="toc-section-number">7.1.3</span> Properties</a></li>
</ul></li>
<li><a href="#refinement-2-floating-point-to-q19"><span class="toc-section-number">7.2</span> Refinement 2: Floating Point to Q19</a>
<ul>
<li><a href="#model-1"><span class="toc-section-number">7.2.1</span> Model</a></li>
<li><a href="#simulation-1"><span class="toc-section-number">7.2.2</span> Simulation</a></li>
<li><a href="#properties-1"><span class="toc-section-number">7.2.3</span> Properties</a></li>
</ul></li>
<li><a href="#sec:synth-r3"><span class="toc-section-number">7.3</span> Refinement 3: Deep Language Embedding</a>
<ul>
<li><a href="#sec:crash-deep"><span class="toc-section-number">7.3.1</span> Quick Introduction to ForSyDe-Deep</a></li>
<li><a href="#model-2"><span class="toc-section-number">7.3.2</span> Model</a></li>
<li><a href="#simulation.-synthesis"><span class="toc-section-number">7.3.3</span> Simulation. Synthesis</a></li>
<li><a href="#properties-2"><span class="toc-section-number">7.3.4</span> Properties</a></li>
</ul></li>
<li><a href="#sec:synth-r4"><span class="toc-section-number">7.4</span> R4: Balancing the FIR Reduction</a>
<ul>
<li><a href="#model-3"><span class="toc-section-number">7.4.1</span> Model</a></li>
<li><a href="#simulation.-synthesis-1"><span class="toc-section-number">7.4.2</span> Simulation. Synthesis</a></li>
<li><a href="#properties-3"><span class="toc-section-number">7.4.3</span> Properties</a></li>
</ul></li>
<li><a href="#conclusions-1"><span class="toc-section-number">7.5</span> Conclusions</a></li>
</ul></li>
<li><a href="#acknowledgements"><span class="toc-section-number">8</span> Acknowledgements</a></li>
<li><a href="#references">References</a></li>
</ul>
</nav>
<h1 data-number="1" id="sec:intro"><span class="header-section-number">1</span> Introduction</h1>
<p>In order to develop more cost-efficient implementation methods for complex systems, we need to understand and exploit the inherent properties derived from the specification of the target applications and, based on these properties, be able to explore the design space offered by alternative platforms. Such is the case of the application studied in this report: the active electronically scanned array (AESA) radar is a versatile system that is able to determine both position and direction of incoming objects, however critical parts of its signal processing has significant demands on processing and memory bandwidth, making it well out-of reach from the general public usage. We believe that a proper understanding of the temporal and spatial properties of the signal processing chain can lead to a better exploration of alternative solutions, ideally making it an affordable appliance in the context of current technology limitations. Nevertheless, expressing behaviors and (extra-functional) properties of systems in a useful way is far from a trivial task and it involves respecting some key principles:</p>
<ul>
<li>the language(s) chosen to represent the models need(s) to be <em>formally defined</em> and <em>unambiguous</em> to be able to provide a solid foundation for analysis and subsequent synthesis towards implementation.</li>
<li>the modeling paradigm should offer the <em>right</em> abstraction level for capturing the <em>needed</em> properties <span class="citation" data-cites="lee-2015">(Lee <a href="#ref-lee-2015" role="doc-biblioref">2015</a>)</span>. An improper model might either abstract away essential properties or over-specify them in a way that makes analysis impossible. In other words it is the engineer’s merit to find the right model for the right “thing being modeled”.</li>
<li>the models, at least during initial development stages, need to be <em>deterministic</em> with regard to defining what <em>correct</em> behavior is <span class="citation" data-cites="Lee18">(Lee <a href="#ref-Lee18" role="doc-biblioref">2018</a>)</span>.</li>
<li>at a minimum, the models need to be <em>executable</em> in order to verify their conformance with the system specification. Ideally they should express operational semantics which are traceable across abstraction levels, ultimately being able to be synthesized on the desired platform <span class="citation" data-cites="Sifakis15">(Sifakis <a href="#ref-Sifakis15" role="doc-biblioref">2015</a>)</span>.</li>
</ul>
<p><a href="https://forsyde.github.io/">ForSyDe</a> is a design methodology which envisions “correct-by-construction system design” through formal or rigorous methods. Its associated modeling frameworks offer means to tackle the challenges enumerated above by providing well-defined composable building blocks which capture extra-functional properties in unison with functional ones. <a href="https://forsyde.github.io/forsyde-shallow">ForSyDe-Shallow</a> is a domain specific language (DSL) shallow-embedded in the functional programming language Haskell, meaning that it can be used only for modeling and simulation purposes. It introduced the concept of <em>process constructors</em> <span class="citation" data-cites="sander-2004">(Sander and Jantsch <a href="#ref-sander-2004" role="doc-biblioref">2004</a>)</span> as building blocks that capture the semantics of computation, concurrency and synchronization as dictated by a certain model of computation (MoC). <a href="https://forsyde.github.io/forsyde-atom">ForSyDe-Atom</a> is also a shallow-embedded (set of) DSL which extends the modeling concepts of ForSyDe-Shallow to systematically capture the interacting extra-functional aspects of a system in a disciplined way as interacting <em>layers</em> of minimalistic languages of primitive operations called <em>atoms</em> <span class="citation" data-cites="ungureanu17">(Ungureanu and Sander <a href="#ref-ungureanu17" role="doc-biblioref">2017</a>)</span>. <a href="https://forsyde.github.io/forsyde-deep">ForSyDe-Deep</a> is a deep-embedded DSL implementing a synthesizable subset of ForSyDe, meaning that it can parse the structure of process networks written in this language and operate on their abstract syntax: either simulate them or further feed them to design flows. Currently ForSyDe-Deep is able to generate GraphML structure files and synthesizable VHDL code.</p>
<p>This documents presents alternatives ways to modelling the AESA radar signal processing chain and, using these models, gradually introducing one concept at a time and pointing towards reference documentation. The final purpose is to refine, synthesize, and replace parts of the behavioral model down to VHDL implementation on FPGA hardware platforms, and co-simulate these design artifacts along with the initial high-level model. The report itself is written using <a href="https://en.wikipedia.org/wiki/Literate_programming">literate programming</a>, which means that all code snippets contained are <em>actual compiled code</em> alternating with documentation text. Following the report might be difficult without some initial clarification. The remaining parts of section <a href="#sec:intro">1</a> will present a guide to using this document, as well as an introduction to the AESA application. In section <a href="#sec:atom">2</a> a high-level, functionally complete ForSyDe-Atom model of the application is thoroughly presented with respect to the specification, and tested against a set of known input data. In section <a href="#sec:shallow">3</a> an equivalent model written in ForSyDe-Shallow is briefly presented and tested, to show the main similarities and differences between the two modeling APIs. In section <a href="#sec:radar">4</a> we model the radar environment as describing the object reflections, represented by continuous signals in time subjected to white noize. In section <a href="#sec:props">5</a> is introduced the concept of property checking for the purpose of validation of ForSyDe designs. We formulate a set of properties in the <a href="https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html">QuicCheck</a> DSL for each component of the AESA model which are validated against a number of randomly-generated tests. In section <a href="#sec:atom-network">6.1</a> we focus on refining the behavior of the initial (high-level) specification model to lower level ones, more suitable for (backend) implementation synthesis, followed by section <a href="#sec:stream-prop-defs">6.3</a> where we formulate new properties for validating some of these refinements. All refinements in section <a href="#sec:refine">6</a> happen in the domain(s) of the ForSyDe-Atom DSL. In section <a href="#sec:synth">7</a> we switch the DSL to ForSyDe-Deep, which benefits from automatic synthesis towards VHDL: in each subsection the refinements are stated, the refined components are modeled, properties are formulated to validate them, and in sections <a href="#sec:synth-r3">7.3</a>, <a href="#sec:synth-r4">7.4</a> VHDL code is generated and validated.</p>
<figure>
<img src="figs/reading-order.png" id="fig:reading-order" alt="" /><figcaption>Figure 1: Reading order dependencies</figcaption>
</figure>
<p>Figure <a href="#fig:reading-order">1</a> depicts a reading order suggestion, based on information dependencies. The dashed line between section <a href="#sec:shallow">3</a> and sections <a href="#sec:synth-r3">7.3</a>, <a href="#sec:synth-r4">7.4</a> suggests that understanding the latter is not directly dependent on the former, but since ForSyDe-Deep syntax is derived from ForSyDe-Shallow, it is recommended to get acquainted with the ForSyDe-Shallow syntax and its equivalence with the ForSyDe-Atom syntax.</p>
<h2 data-number="1.1" label="Application Specification" id="sec:video-chain-spec"><span class="header-section-number">1.1</span> Application Specification</h2>
<p>An AESA, see picture below, may consist of thousands of antenna elements. The relative phases of the pulses of the antenna’s different antenna elements can be set to create a constructive interference in the chosen main lobe bearing. In this way the pointing direction can be set without any moving parts. When receiving, the direction can be steered by following the same principle, as seen the Digital Beam Former below. One of the main advantages of the array antennas is the capacity to extract not only temporal but also spatial information, i.e. the direction of incoming signals.</p>
<p><img src="figs/aesa-antenna.png" style="height:3.5cm" alt="Antenna" />  <img src="figs/aesa-beamforming.png" style="height:3.5cm" /></p>
<p>Figure <a href="#fig:video-chain-spec">2</a> shows a simplified radar signal processing chain that is used to illustrate the calculations of interest. The input data from the antenna is processed in a number of steps.</p>
<figure>
<img src="figs/video-chain-spec.png" id="fig:video-chain-spec" alt="" /><figcaption>Figure 2: Overview of the video processing chain</figcaption>
</figure>
<p>In this report we assume one stream per antenna element. The indata is organized into a sequence of “cubes”, each corresponding to a certain integration interval. Each sample in the cube represents a particular antenna element, pulse and range bin. The data of the cube arrives pulse by pulse and each pulse arrives range bin by range bin. This is for all elements in parallel. Between the Pulse Compression (PC) and Doppler Filter Bank (DFB) steps there is a corner turn of data, i.e. data from all pulses must be collected before the DFB can execute.</p>
<p>The different steps of the chain, the antenna and the input data format are briefly described in the following list. For a more detailed description of the processing chain, please refer to section <a href="#sec:atom">2</a>.</p>
<ul>
<li><p><em>Digital Beam Forming (DBF)</em>: The DBF step creates a number of simultaneous receiver beams, or “listening directions”, from the input data. This is done by doing weighted combinations of the data from the different antenna elements, so that constructive interference is created in the desired bearings of the beams. The element samples in the input data set are then transformed into beams.</p></li>
<li><p><em>Pulse Compression (PC)</em>: The goal of the pulse compression is to collect all received energy from one target into a single range bin. The received echo of the modulated pulse is passed through a matched filter. Here, the matched filtering is done digitally.</p></li>
<li><p><em>Doppler Filter Bank incl. envelope detection (DFB)</em>: The DFB gives an estimation of the target’s speed relative to the radar. It also gives an improved signal-to-noise ratio due to a coherent integration of indata. The pulse bins in the data set are transformed into Doppler channels. The envelope detector calculates the absolute values of the digital samples. The data is real after this step.</p></li>
<li><p><em>Constant False Alarm Ratio (CFAR)</em>: The CFAR processing is intended to keep the number of false targets at an acceptable level while maintaining the best possible sensitivity. It normalizes the video in order to maintain a constant false alarm rate when the video is compared to a detection threshold. With this normalization the sensitivity will be adapted to the clutter situation in the area (around a cell under test) of interest.</p></li>
<li><p><em>Integrator (INT)</em> The integrator is an 8-tap unsigned integrator that integrates channel oriented video. Integration shall be done over a number of FFT batches of envelope detected video. Each Doppler channel, range bin and antenna element shall be integrated.</p></li>
</ul>
<p>The following table briefly presents the dimensions of the primitive functions associated with each processing stage, where data sets are measured in number of elements processed organized in channels <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>×</mo><annotation encoding="application/x-tex">\times</annotation></semantics></math> range bins <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>×</mo><annotation encoding="application/x-tex">\times</annotation></semantics></math> pulses; data precision is measured in bit width; and approximative performance is given in MOPS. These dimensions represent the scaled-down version of a realistic AESA radar signal processing system, with 16 input antenna channels forming into 8 beams.</p>
<div id="tbl:sizes">
<table>
<caption>Table 1: Dimensions of the AESA case study covered in the report</caption>
<colgroup>
<col style="width: 7%" />
<col style="width: 27%" />
<col style="width: 27%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th>Block</th>
<th>In Data Set</th>
<th>Out Data Set</th>
<th>Type In</th>
<th>Out</th>
<th>Precision In</th>
<th>Out</th>
<th>Approx. perform.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DBF</td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">16 \times 1 \times 1</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">8 \times 1 \times 1</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></td>
<td>16</td>
<td>20</td>
<td>2688</td>
</tr>
<tr class="even">
<td>PC</td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1024</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1024 \times1</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1024</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1024 \times 1</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></td>
<td>20</td>
<td>20</td>
<td>4608</td>
</tr>
<tr class="odd">
<td>DFB</td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">1\times 1 \times 256</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">1 \times 1 \times 256</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></td>
<td>20</td>
<td>20</td>
<td>7680</td>
</tr>
<tr class="even">
<td>CFAR</td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1024</mn><mo>×</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">1 \times 1024 \times 256</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1024</mn><mo>×</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">1 \times 1024 \times 256</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></td>
<td>20</td>
<td>16</td>
<td>360</td>
</tr>
<tr class="odd">
<td>INT</td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1 \times 1</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1 \times 1</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></td>
<td>16</td>
<td>16</td>
<td>24576</td>
</tr>
<tr class="even">
<td>AESA</td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>×</mo><mn>1024</mn><mo>×</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">16\times 1024 \times 256</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mn>8</mn><mo>×</mo><mn>1024</mn><mo>×</mo><mn>256</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">2 (8 \times 1024 \times 256)</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></td>
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></td>
<td>–</td>
<td>–</td>
<td>39912</td>
</tr>
</tbody>
</table>
</div>
<h2 data-number="1.2" id="sec:usage"><span class="header-section-number">1.2</span> Using This Document</h2>
<p><strong>PREREQUISITES:</strong> the document assumes that the reader is familiar with the functional programming language <a href="https://www.haskell.org/">Haskell</a>, its syntax, and the usage of a Haskell interpreter (e.g. <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html"><code>ghci</code></a>). Otherwise, we recommend consulting at least the introductory chapters of one of the following books by <span class="citation" data-cites="Lipovaca11">Lipovača (<a href="#ref-Lipovaca11" role="doc-biblioref">2011</a>)</span> and <span class="citation" data-cites="hutton-2016">Hutton (<a href="#ref-hutton-2016" role="doc-biblioref">2016</a>)</span> or other recent books in Haskell. The reader also needs to be familiar with some basic ForSyDe modeling concepts, such as <em>process constructor</em>, <em>process</em> or <em>signal</em>. We recommend going through at least the online getting started <a href="https://forsyde.github.io/forsyde-shallow/getting_started">tutorial on ForSyDe-Shallow</a> or the one <a href="https://forsyde.github.io/forsyde-atom/assets/manual.pdf">on ForSyDe-Atom</a>, and if possible, consulting the (slightly outdated) book chapter on ForSyDe <span class="citation" data-cites="sander-2017-forsy">(Sander, Jantsch, and Attarzadeh-Niaki <a href="#ref-sander-2017-forsy" role="doc-biblioref">2017</a>)</span>.</p>
<p>This document has been created using literate programming. This means that all code shown in the listings is compilable and executable. There are two types of code listing found in this document. This style</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">-- | API documentation comment</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">myIdFunc ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1-3"><a href="#cb1-3"></a>myIdFunc <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p>shows <em>source code</em> as it is found in the implementation files, where the line numbers correspond to the position in the source file. This style</p>
<pre><code>Prelude&gt; 1 + 1
2
</code></pre>
<p>suggests <em>interactive commands</em> given by the user in a terminal or an interpreter session. The listing above shows a typical <code>ghci</code> session, where the string after the prompter symbol <code>&gt;</code> suggests the user input (e.g. <code>1 + 1</code>). Whenever relevant, the expected output is printed one row below (e.g. <code>2</code>).</p>
<p>The way this document is meant to be parsed efficiently is to load the source files themselves in an interpreter and test the exported functions gradually, while reading the document at the same time. Due to multiple (sometimes conflicting) dependencies on external packages, for convenience the source files are shipped as <em>multiple</em> <a href="https://docs.haskellstack.org/en/stable/README/">Stack</a> packages each creating an own sandbox on the user’s local machine with all dependencies and requirements taken care of. Please refer to the project’s <code>README</code> file for instructions on how to install and compile or run the Haskell files.</p>
<p>At the beginning of each chapter there is meta-data guiding the reader what tools and packages are used, like:</p>
<table>
<tbody>
<tr class="odd">
<td>Package</td>
<td>aesa-atom-0.1.0</td>
<td>path: <code>./aesa-atom/README.md</code></td>
</tr>
</tbody>
</table>
<p>This table tells that the package where the current chapter’s code resides is <code>aesa-atom</code>, version 0.1.0. This table might contain information on the main dependency packages which contain important functions, and which should be consulted while reading the code in the current chapter. If the main package generates an executable binary or a test suite, these are also pointed out. The third column provides additional information such as a pointer to documentation (relative path to the project root, or web URL), or usage suggestions.</p>
<p>It is recommended to read the main package’s <code>README</code> file which contains instructions on how to install, compile and test the software, before proceeding with following a chapter. Each section of a chapter is written within a library <em>module</em>, pointed out in the beginning of the respective section by the line:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">module</span> <span class="dt">ForSyDe.X.Y</span> <span class="kw">where</span></span></code></pre></div>
<p>The most convenient way to test out all functions used in module <code>ForSyDe.X.Y</code> is by loading its source file in the sandboxed interpreter, i.e. by running the following command from the project root:</p>
<pre><code>stack ghci src/ForSyDe/X/Y.lhs
</code></pre>
<p>An equally convenient way is to create an own <code>.hs</code> file somewhere under the project root, which imports and uses module <code>ForSyDe.X.Y</code>, e.g.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">-- MyTest.hs</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">import</span> <span class="dt">ForSyDe.X.Y</span></span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a>myData <span class="ot">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb5-5"><a href="#cb5-5"></a>myTest <span class="ot">=</span> functionFromForSyDeXY myData</span></code></pre></div>
<p>This file can be loaded and/or compiled from within the sandbox, e.g. with <code>stack ghci MyTest.hs</code>.</p>
<h1 data-number="2" id="sec:atom"><span class="header-section-number">2</span> High-Level Model of the AESA Signal Processing Chain in ForSyDe-Atom</h1>
<blockquote>
<p><em>This section guides the reader throughout translating “word-by-word” the provided specifications of the AESA signal processing chain into a concrete, functionally complete, high-level executable model in ForSyDe-Atom. This first attempt focuses mainly on the top-level functional behavior of the system, exerting the successive transformations upon the input video cubes, as suggested by Figure <a href="#fig:video-chain-spec">2</a>. We postpone the description/derivation of more appropriate time behaviors for later sections. Enough AESA system details are given in order to understand the model. At the end of this section we simulate this model against a realistic input set of complex antenna data, and test if it is sane (i.e. provides the expected results).</em></p>
</blockquote>
<table>
<tbody>
<tr class="odd">
<td>Package</td>
<td>aesa-atom-0.1.0</td>
<td>path: <code>./aesa-atom/README.md</code></td>
</tr>
<tr class="even">
<td>Deps</td>
<td>forsyde-atom-0.3.1</td>
<td>url: <code>https://forsyde.github.io/forsyde-atom/api/</code></td>
</tr>
<tr class="odd">
<td>Bin</td>
<td>aesa-cube</td>
<td>usage: <code>aesa-cube --help</code></td>
</tr>
</tbody>
</table>
<p>Historically, <a href="https://forsyde.github.io/forsyde-atom/">ForSyDe-Atom</a> has been a spin-off of <a href="https://forsyde.github.io/forsyde-shallow/">ForSyDe-Shallow</a> which has explored new modeling concepts, and had a fundamentally different approach to how models are described and instantiated. ForSyDe-Atom introduced the concept of <em>language layer</em>, extending the idea of process constructor, and within this setting it explored the algebra of algorithmic skeletons, employed heavily within this report. As of today, both ForSyDe-Shallow and ForSyDe-Atom have similar APIs and are capable of modeling largely the same behaviors. The main syntax differences between the two are covered in section <a href="#sec:shallow">3</a>, where the same high-level model is written in ForSyDe-Shallow.</p>
<h2 data-number="2.1" id="sec:crash-atom"><span class="header-section-number">2.1</span> Quick Introduction to ForSyDe-Atom</h2>
<p>Before proceeding with the modeling of the AESA processing chain, let us consolidate the main ForSyDe concepts which will be used throughout this report: <em>layer</em>, <em>process constructor</em> and <em>skeleton</em>. If you are not familiar with ForSyDe nomenclature and general modeling principles, we recommend consulting the documentation pointed out in section <a href="#sec:intro">1</a> first.</p>
<p>As seen in section <a href="#sec:video-chain-spec">1.Application Specification</a>, most of the AESA application consists of typical DSP algorithms such as matrix multiplications, FFT, moving averages, etc. which lend themselves to <em>streaming parallel</em> implementations. Hence we need to unambiguously capture the two distinct aspects of the AESA chain components:</p>
<ul>
<li><p><em>streaming behavior</em> is expressed in ForSyDe through processes which operate on signals encoding a temporal partitioning of data. Processes are instantiated exclusively using <em>process constructors</em> which can be regarded as templates inferring the semantics of computation, synchronization and concurrency as dictated by a certain model of computation (MoC) (<span class="citation" data-cites="sander-2004">Sander and Jantsch (<a href="#ref-sander-2004" role="doc-biblioref">2004</a>)</span>,<span class="citation" data-cites="leeseshia-15">Edward A. Lee and Seshia (<a href="#ref-leeseshia-15" role="doc-biblioref">2016</a>)</span>).</p></li>
<li><p><em>parallelism</em> is expressed through parallel patterns which operate on structured types (e.g. vectors) encoding a spatial partitioning of data. These patterns are instantiated as skeletons, which are templates inferring the semantics of distribution, parallel computation and interaction between elements, as defined by the algebra of catamorphisms <span class="citation" data-cites="Fischer-2003">(Fischer, Gorlatch, and Bischof <a href="#ref-Fischer-2003" role="doc-biblioref">2003</a>)</span>.</p></li>
</ul>
<figure>
<img src="figs/layers.png" id="fig:atom-layers" alt="" /><figcaption>Figure 3: Depiction of layer usage: (left) skeleton networks of processes; (right) processes of skeleton functions</figcaption>
</figure>
<p>In order to capture these two<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> interacting aspects in unison as a complete system, we describe them in terms of two distinct, orthogonal <em>layers</em> within the ForSyDe-Atom framework. A language layer is a (very small) domain specific language (DSL) heavily rooted in the functional programming paradigm, which is able to describe one aspect of a cyber-physical system (CPS). Layers interact with one another by virtue of the abstraction principle inherent to a functional programming language <span class="citation" data-cites="backus-1978">(Backus <a href="#ref-backus-1978" role="doc-biblioref">1978</a>)</span>: each layer defines at least one higher order function that is able to take a function (i.e. abstraction) from another layer as an argument and to lift it within its own domain. To picture the interaction between layers, consider Figure <a href="#fig:video-chain-spec">2</a> where, although we use the same <code>farm</code> vector skeleton and <code>comb</code> synchronous (SY) process constructor, the two different compositions describe two different (albeit semantically equivalent) systems: the first one is instantiating a farm network of SY processes operating on a vector of signals in parallel; whereas the second one is instantiating a single SY process operating on o signal where each event is carrying a vector of values.</p>
<!-- Historically, it has been the "playground" for -->
<!-- developing and applying modeling concepts such as algorithmic skeletons (parallel -->
<!-- patterns) and applicative-style modeling in ForSyDe. For more information on the main -->
<!-- concepts behind ForSyDe-Atom see [@ungureanu17]. From the point of view of user -->
<!-- experience however, the API is pretty much identical to ForSyDe-Shallow's, with the -->
<!-- following two main differences: -->
<!--  * the user has more control of which libraries are -->
<!--    imported. Functions are not distinguished by their suffix any -->
<!--    longer, which means that multiple libraries export functions which -->
<!--    deliberately share the same name. As such, the suggested -->
<!--    programming style for mixed-library designs is to alias the -->
<!--    imported library (e.g. `import ForSyDe.Atom.MoC.SY as SY`) and -->
<!--    reference the function using the alias as a prefix (e.g. `SY.mealy` -->
<!--    instead of `mealySY` in ForSyDe-Shallow). -->
<!--  * some of ForSyDe's "canonical" names for process constructors -->
<!--    inspired from functional programming have been replaced with more -->
<!--    suggestive names inspired from component-based modeling, which are -->
<!--    denoting common building blocks, relevant to their domain. For -->
<!--    example `mapSY` is now called `SY.comb11`; `zipWithSY` is now -->
<!--    called `SY.comb21`; `zipWithV` is now called `V.farm21`, etc. -->
<!-- In this section we approach modeling the AESA application from two -->
<!-- different point of views: the first one is a direct translation of the -->
<!-- ForSyDe-Shallow implementation from [@sec:shallow], and it models the -->
<!-- signal processing chain as a pipe of processes working on _parallel -->
<!-- data_ organinzed in matrices or cubes; the second approach is to model -->
<!-- the data path from each individual antenna element by describing -->
<!-- parallelism at a _process network_ level (e.g. process farms), similar -->
<!-- to how [@sec:int-shallow] has been described. We show that the second -->
<!-- approach enables opportunities for exploitation and design space -->
<!-- exploration at a more fine-grained level. -->
<h2 data-number="2.2" id="sec:cube-atom-operation"><span class="header-section-number">2.2</span> A High-Level Model</h2>
<p>This section presents a high-level behavioral model of the AESA signal processing chain presented in section <a href="#sec:video-chain-spec">1.Application Specification</a>. This model follows intuitive and didactic way to tackle the challenge of translating the <em>textual</em> specifications into an <em>executable</em> ForSyDe specification and is not, in any circumstance, the only way to model the application. As of section <a href="#sec:crash-atom">2.1</a> we represent each stage in the AESA chain as a <em>process</em> acting upon (complete) <em>cubes</em> of data, i.e. as processes of skeleton functions. At this phase in the system design we do not care <em>how</em> the cubes are being formed or how the data is being carried around, bur rather on <em>what</em> transformations are applied on the data cubes during each subsequent stage of the AESA pipeline. The purpose of the model is to provide a executable <em>reference</em> for the AESA system functionality, that can later be derived to more efficient descriptions.</p>
<p>The code for this section is written in the following module, see section <a href="#sec:usage">1.2</a> on how to use it:</p>
<div class="sourceCode" id="cb6" data-startFrom="18"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 17;"><span id="cb6-18"><a href="#cb6-18"></a><span class="kw">module</span> <span class="dt">AESA.CubesAtom</span> <span class="kw">where</span></span></code></pre></div>
<p>As the AESA application uses complex numbers, we use Haskell’s <a href="http://hackage.haskell.org/package/base/docs/Data-Complex.html"><code>Complex</code></a> type.</p>
<div class="sourceCode" id="cb7" data-startFrom="23"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 22;"><span id="cb7-23"><a href="#cb7-23"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span></code></pre></div>
<p>The only timed behavior exerted by the model in this section is the causal, i.e. ordered, passing of cubes from one stage to another. In order to enable a simple, abstract, and thus analyzable “pipeline” behavior this passing can be described according to the <em>perfect synchrony hypothesis</em>, which assumes the processing of each event (cube) takes an infinitely small amount of time and it is ready before the next synchronization point. This in turn implies that all events in a system are synchronized, enabling the description of fully deterministic behaviors over infinite streams of events. These precise execution semantics are captured by the <em>synchronous reactive (SY) model of computation (MoC)</em> (<span class="citation" data-cites="leeseshia-15">Edward A. Lee and Seshia (<a href="#ref-leeseshia-15" role="doc-biblioref">2016</a>)</span>,<span class="citation" data-cites="Benveniste03">Benveniste et al. (<a href="#ref-Benveniste03" role="doc-biblioref">2003</a>)</span>), hence we import the <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>SY</code></a> library from the <em><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC.html">MoC</a> layer</em> of ForSyDe-Atom, see <span class="citation" data-cites="ungureanu17">(Ungureanu and Sander <a href="#ref-ungureanu17" role="doc-biblioref">2017</a>)</span>, using an appropriate alias.</p>
<div class="sourceCode" id="cb8" data-startFrom="39"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 38;"><span id="cb8-39"><a href="#cb8-39"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a>  <span class="kw">as</span> <span class="dt">SY</span></span></code></pre></div>
<p>For describing parallel operations on data we use algorithmic skeletons (<span class="citation" data-cites="Fischer-2003">Fischer, Gorlatch, and Bischof (<a href="#ref-Fischer-2003" role="doc-biblioref">2003</a>)</span>,<span class="citation" data-cites="skillicorn05">Skillicorn (<a href="#ref-skillicorn05" role="doc-biblioref">2005</a>)</span>), formulated on ForSyDe-Atom’s in-house <a href="http://hackage.haskell.org/package/forsyde-atom/docs/ForSyDe-atom-Core-Vector.html"><code>Vector</code></a> data type, which is a shallow, lazy-evaluated implementation of unbounded arrays, ideal for early design validation. Although dependent, bounded, and even boxed (i.e. memory-mapped) alternatives exist, such as <a href="http://hackage.haskell.org/package/parameterized-data/docs/Data-Param-FSVec.html"><code>FSVec</code></a> or REPA <a href="http://hackage.haskell.org/package/repa"><code>Array</code></a>s, for the scope of this project the functional validation and (by-hand) requirement analysis on the properties of skeletons will suffice. We also import the <code>Matrix</code> and <code>Cube</code> utility libraries which contain type synonyms for nested <code>Vector</code>s along with their derived skeletons, as well a <code>DSP</code> which contain commonly used DSP blocks defined in terms of vector skeletons.</p>
<div class="sourceCode" id="cb9" data-startFrom="55"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 54;"><span id="cb9-55"><a href="#cb9-55"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a>        <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb9-56"><a href="#cb9-56"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.Matrix</span></a> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb9-57"><a href="#cb9-57"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Cube.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.Cube</span></a>   <span class="kw">as</span> <span class="dt">C</span></span>
<span id="cb9-58"><a href="#cb9-58"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.DSP</span></a></span></code></pre></div>
<p>Finally, we import the local project module defining different coefficients for the AESA algorithms, presented in detail in section <a href="#sec:coefs-atom">2.2.Coefficients</a>.</p>
<div class="sourceCode" id="cb10" data-startFrom="63"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 62;"><span id="cb10-63"><a href="#cb10-63"></a><span class="kw">import</span> <span class="dt">AESA.Coefs</span></span></code></pre></div>
<h3 data-number="2.2.1" id="sec:cube-aliases-atom"><span class="header-section-number">2.2.1</span> Type Aliases and Constants</h3>
<p>The system parameters are integer constants defining the size of the application. For a simple test scenario provided by Saab AB, we have bundled these parameters in the following module, and we shall use their variable names throughout the whole report:</p>
<div class="sourceCode" id="cb11" data-startFrom="71"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 70;"><span id="cb11-71"><a href="#cb11-71"></a><span class="kw">import</span> <span class="dt">AESA.Params</span></span>
<span id="cb11-72"><a href="#cb11-72"></a><span class="kw">import</span> <span class="dt">Data.Ratio</span></span></code></pre></div>
<p>For ease of documentation we will be using type synonyms (aliases) for all types and structures throughout this design:</p>
<ul>
<li><p><code>Antenna</code> denotes a vector container for the antenna elements. Its length is equal to the number of antennas in the radar <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>A</mi></msub><annotation encoding="application/x-tex">N_A</annotation></semantics></math>.</p></li>
<li><p>After Digital Beamforming (DBF), the antenna elements are transformed into <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>B</mi></msub><annotation encoding="application/x-tex">N_B</annotation></semantics></math> beams, thus we associate the <code>Beam</code> alias for the vector container wrapping those beams.</p></li>
<li><p><code>Range</code> is a vector container for range bins. All antennas have the same number of range bins <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>b</mi></msub><annotation encoding="application/x-tex">N_b</annotation></semantics></math>, rendering each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Antenna</mtext><mo>×</mo><mtext mathvariant="normal">Range</mtext></mrow><annotation encoding="application/x-tex">\text{Antenna} \times \text{Range}</annotation></semantics></math> a perfect matrix of samples for every pulse.</p></li>
<li><p><code>Window</code> stands for a Doppler window of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><annotation encoding="application/x-tex">N_{FFT}</annotation></semantics></math> pulses.</p></li>
</ul>
<div class="sourceCode" id="cb12" data-startFrom="90"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 89;"><span id="cb12-90"><a href="#cb12-90"></a><span class="kw">type</span> <span class="dt">Antenna</span>     <span class="ot">=</span> <span class="dt">Vector</span> <span class="co">-- length: nA</span></span>
<span id="cb12-91"><a href="#cb12-91"></a><span class="kw">type</span> <span class="dt">Beam</span>        <span class="ot">=</span> <span class="dt">Vector</span> <span class="co">-- length: nB</span></span>
<span id="cb12-92"><a href="#cb12-92"></a><span class="kw">type</span> <span class="dt">Range</span>       <span class="ot">=</span> <span class="dt">Vector</span> <span class="co">-- length: nb</span></span>
<span id="cb12-93"><a href="#cb12-93"></a><span class="kw">type</span> <span class="dt">Window</span>      <span class="ot">=</span> <span class="dt">Vector</span> <span class="co">-- length: nFFT</span></span></code></pre></div>
<p>Finally we provide two aliases for the basic Haskell data types used in the system, to stay consistent with the application specification.</p>
<div class="sourceCode" id="cb13" data-startFrom="98"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 97;"><span id="cb13-98"><a href="#cb13-98"></a><span class="kw">type</span> <span class="dt">CpxData</span>  <span class="ot">=</span> <span class="dt">Complex</span> <span class="dt">Float</span></span>
<span id="cb13-99"><a href="#cb13-99"></a><span class="kw">type</span> <span class="dt">RealData</span> <span class="ot">=</span> <span class="dt">Float</span></span></code></pre></div>
<h3 data-number="2.2.2" id="sec:cube-atom-pipe-stages"><span class="header-section-number">2.2.2</span> Video Processing Pipeline Stages</h3>
<p>In this section we follow each stage described in section <a href="#sec:video-chain-spec">1.Application Specification</a>, and model them as a processes operating on cubes (three-dimensional vectors) of antenna samples.</p>
<h4 data-number="2.2.2.1" id="sec:cube-dbf-atom"><span class="header-section-number">2.2.2.1</span> Digital Beamforming (DFB)</h4>
<p>The DBF receives complex in data, from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>A</mi></msub><annotation encoding="application/x-tex">N_A</annotation></semantics></math> antenna elements and forms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>B</mi></msub><annotation encoding="application/x-tex">N_B</annotation></semantics></math> simultaneous receiver beams, or “listening directions”, by summing individually phase-shifted in data signals from all elements. Considering the indata video cube, the transformation applied by DBF, could be depicted as in Figure <a href="#fig:cube-dbf-cube">4</a>.</p>
<figure>
<img src="figs/dbf-cube.png" id="fig:cube-dbf-cube" alt="" /><figcaption>Figure 4: DBF on video structure</figcaption>
</figure>
<p>Considering the application specification in section <a href="#sec:video-chain-spec">1.Application Specification</a> on the input data, namely <em>“for each antenna the data arrives <em>pulse by pulse</em>, and each pulse arrives <em>range bin by range bin</em>”</em>, we can assume that the video is received as <code>Antenna (Window (Range a))</code> cubes, meaning that the inner vectors are the range bins. However, Figure <a href="#fig:cube-dbf-cube">4</a> shows that the beamforming function is applied in the antenna direction, so we need to transpose the cube in such a way that <code>Antenna</code> becomes the inner vector, i.e. <code>Window (Range (Antenna a))</code>. We thus describe the DBF stage as a combinational SY process <code>comb</code> acting upon signals of <code>Cube</code>s, namely mapping the beamforming function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><annotation encoding="application/x-tex">f_{DBF}</annotation></semantics></math> on each column of each <em>pulse matrix</em> (see Figure <a href="#fig:cube-dbf-cube">4</a>).</p>
<figure>
<img src="figs/dbf-proc-atom.png" id="fig:cube-dbf-proc-atom" alt="" /><figcaption>Figure 5: DBF stage process</figcaption>
</figure>
<div class="sourceCode" id="cb14" data-startFrom="128"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 127;"><span id="cb14-128"><a href="#cb14-128"></a><span class="ot">dbf ::</span> <span class="dt">Signal</span> (<span class="dt">Antenna</span> (<span class="dt">Window</span> (<span class="dt">Range</span> <span class="dt">CpxData</span>)))</span>
<span id="cb14-129"><a href="#cb14-129"></a>    <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Window</span>  (<span class="dt">Range</span>  (<span class="dt">Beam</span>  <span class="dt">CpxData</span>)))</span>
<span id="cb14-130"><a href="#cb14-130"></a>dbf <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> (M.farm11 fDBF <span class="op">.</span> C.transpose)</span></code></pre></div>
<p>The beamforming function is specified like in eq. <a href="#eq:dbf">1</a>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>k</mi></msub><mo>,</mo><mspace width="0.222em"></mspace><mo>∀</mo><mi>k</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo>,</mo><msub><mi>N</mi><mi>A</mi></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">e_k ,\ \forall k \in [1,N_A]</annotation></semantics></math> denotes the samples from antenna elements, and respectively <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><mspace width="0.222em"></mspace><mo>∀</mo><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo>,</mo><msub><mi>N</mi><mi>B</mi></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">b_i,\ \forall i \in [1,N_B]</annotation></semantics></math> are samples for each beam. This is in fact a of matrix-vector multiplication, thus we implement eq. <a href="#eq:dbf">1</a> at the highest level of abstraction simply as matrix/vector operations like in eq. <a href="#eq:dbf-mat">2</a>.</p>
<p><span id="eq:dbf"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>N</mi><mi>A</mi></msub></munderover><msub><mi>e</mi><mi>k</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><msub><mi>α</mi><mrow><mi>k</mi><mi>i</mi></mrow></msub><mspace width="2.0em"></mspace><mo>∀</mo><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo>,</mo><msub><mi>N</mi><mi>B</mi></msub><mo stretchy="false" form="postfix">]</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> b_i(n) = \sum_{k=1}^{N_A} e_k(n) \cdot \alpha_{ki}\qquad\forall i \in [1,N_B] \qquad(1)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb15" data-startFrom="140"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 139;"><span id="cb15-140"><a href="#cb15-140"></a><span class="ot">fDBF ::</span> <span class="dt">Antenna</span> <span class="dt">CpxData</span> <span class="co">-- ^ input antenna elements</span></span>
<span id="cb15-141"><a href="#cb15-141"></a>     <span class="ot">-&gt;</span> <span class="dt">Beam</span>    <span class="dt">CpxData</span> <span class="co">-- ^ output beams</span></span>
<span id="cb15-142"><a href="#cb15-142"></a>fDBF antennaEl <span class="ot">=</span> beams</span>
<span id="cb15-143"><a href="#cb15-143"></a>  <span class="kw">where</span></span>
<span id="cb15-144"><a href="#cb15-144"></a>    beams      <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.reduce</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.farm21</a> (<span class="op">+</span>)) beamMatrix</span>
<span id="cb15-145"><a href="#cb15-145"></a>    beamMatrix <span class="ot">=</span> M.farm21 (<span class="op">*</span>) elMatrix beamConsts</span>
<span id="cb15-146"><a href="#cb15-146"></a>    elMatrix   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fanout</a> antennaEl</span>
<span id="cb15-147"><a href="#cb15-147"></a>    beamConsts <span class="ot">=</span> mkBeamConsts dElements waveLength nA<span class="ot"> nB ::</span> <span class="dt">Matrix</span> <span class="dt">CpxData</span></span></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>farm11</code>, <code>reduce</code>, <code>length</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>farm11</code>, <code>farm21</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><code>ForSyDe.Atom.Skel.FastVector.Matrix</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>transpose</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Cube.html"><code>ForSyDe.Atom.Skel.FastVector.Cube</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>comb11</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>ForSyDe.Atom.MoC.SY</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>mkBeamConsts</code></td>
<td><code>AESA.Coefs</code></td>
<td>aesa-atom</td>
</tr>
<tr class="even">
<td><code>dElements</code>, <code>waveLenth</code>, <code>nA</code>, <code>nB</code></td>
<td><code>AESA.Params</code></td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<p><span id="eq:dbf-mat"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtable><mtr><mtd columnalign="center"><mover><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>e</mi><mn>1</mn></msub></mtd><mtd columnalign="center"><msub><mi>e</mi><mn>1</mn></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>e</mi><mn>2</mn></msub></mtd><mtd columnalign="center"><msub><mi>e</mi><mn>2</mn></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>e</mi><msub><mi>N</mi><mi>A</mi></msub></msub></mtd><mtd columnalign="center"><msub><mi>e</mi><msub><mi>N</mi><mi>A</mi></msub></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mtext mathvariant="normal">elMatrix</mtext></mover><mo>×</mo><mover><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>α</mi><mn>11</mn></msub></mtd><mtd columnalign="center"><msub><mi>α</mi><mn>12</mn></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msub><mi>α</mi><mrow><mn>1</mn><msub><mi>N</mi><mi>B</mi></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>α</mi><mn>21</mn></msub></mtd><mtd columnalign="center"><msub><mi>α</mi><mn>22</mn></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msub><mi>α</mi><mrow><mn>2</mn><msub><mi>N</mi><mi>B</mi></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>α</mi><mrow><msub><mi>N</mi><mi>A</mi></msub><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><msub><mi>α</mi><mrow><msub><mi>N</mi><mi>A</mi></msub><mn>2</mn></mrow></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msub><mi>α</mi><mrow><msub><mi>N</mi><mi>A</mi></msub><msub><mi>N</mi><mi>B</mi></msub></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mtext mathvariant="normal">beamConsts</mtext></mover><mo>⇒</mo></mtd></mtr><mtr><mtd columnalign="center"><mo>⇒</mo><mover><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>e</mi><mn>1</mn></msub><msub><mi>α</mi><mn>11</mn></msub></mtd><mtd columnalign="center"><msub><mi>e</mi><mn>1</mn></msub><msub><mi>α</mi><mn>12</mn></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msub><mi>e</mi><mn>1</mn></msub><msub><mi>α</mi><mrow><mn>1</mn><msub><mi>N</mi><mi>B</mi></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>e</mi><mn>2</mn></msub><msub><mi>α</mi><mn>21</mn></msub></mtd><mtd columnalign="center"><msub><mi>e</mi><mn>2</mn></msub><msub><mi>α</mi><mn>22</mn></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msub><mi>e</mi><mn>2</mn></msub><msub><mi>α</mi><mrow><mn>2</mn><msub><mi>N</mi><mi>B</mi></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>e</mi><msub><mi>N</mi><mi>A</mi></msub></msub><msub><mi>α</mi><mrow><msub><mi>N</mi><mi>A</mi></msub><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><msub><mi>e</mi><msub><mi>N</mi><mi>A</mi></msub></msub><msub><mi>α</mi><mrow><msub><mi>N</mi><mi>A</mi></msub><mn>2</mn></mrow></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msub><mi>e</mi><msub><mi>N</mi><mi>A</mi></msub></msub><msub><mi>α</mi><mrow><msub><mi>N</mi><mi>A</mi></msub><msub><mi>N</mi><mi>B</mi></msub></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><mtext mathvariant="normal">beamMatrix</mtext></mover><munder><mo>∑</mo><mstyle mathvariant="italic"><mi>𝑟</mi><mi>𝑜</mi><mi>𝑤</mi><mi>𝑠</mi></mstyle></munder><mo>=</mo><mover><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>b</mi><mn>1</mn></msub></mtd><mtd columnalign="center"><msub><mi>b</mi><mn>2</mn></msub></mtd><mtd columnalign="center"><mi>…</mi></mtd><mtd columnalign="center"><msub><mi>b</mi><mi>n</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mtext mathvariant="normal">beam</mtext></mover></mtd></mtr></mtable><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>2</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \begin{gathered}
   \stackrel{\mbox{elMatrix}}{
   \begin{bmatrix}
    e_{1} &amp; e_{1} &amp; \dots  \\
    e_{2} &amp; e_{2} &amp; \dots  \\
    \vdots&amp; \vdots&amp; \ddots \\
    e_{N_A} &amp; e_{N_A} &amp; \dots
   \end{bmatrix}}
   \times
   \stackrel{\mbox{beamConsts}}{
   \begin{bmatrix}
    \alpha_{11} &amp; \alpha_{12} &amp; \dots  &amp; \alpha_{1N_B} \\
    \alpha_{21} &amp; \alpha_{22} &amp; \dots  &amp; \alpha_{2N_B} \\
    \vdots      &amp; \vdots      &amp; \ddots &amp; \vdots\\
    \alpha_{N_A1} &amp; \alpha_{N_A2} &amp; \dots  &amp; \alpha_{N_AN_B} 
   \end{bmatrix}}
   \Rightarrow\\\Rightarrow
   \stackrel{\mbox{beamMatrix}}{
   \left.\begin{bmatrix}
    e_1\alpha_{11} &amp; e_1\alpha_{12} &amp; \dots  &amp; e_1\alpha_{1N_B} \\
    e_2\alpha_{21} &amp; e_2\alpha_{22} &amp; \dots  &amp; e_2\alpha_{2N_B} \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
    e_{N_A}\alpha_{N_A1} &amp; e_{N_A}\alpha_{N_A2} &amp; \dots  &amp; e_{N_A}\alpha_{N_AN_B} 
   \end{bmatrix}\right\}}
   \sum_\mathit{rows}=
   \stackrel{\mbox{beam}}{
   \begin{bmatrix}
    b_1 &amp; b_2 &amp; \dots  &amp; b_n 
   \end{bmatrix}}
   \end{gathered}
\qquad(2)</annotation></semantics></math></span></p>
<p>In fact the operation performed by the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><annotation encoding="application/x-tex">f_{DBF}</annotation></semantics></math> function in eq. <a href="#eq:dbf">1</a>, respectively in eq. <a href="#eq:dbf-mat">2</a> is nothing else but a dot operation between a vector and a matrix. Luckily, <code>ForSyDe.Atom.Skel.FastVector.DSP</code> exports a utility skeleton called <code>dotvm</code> which instantiates exactly this type of operation. Thus we can instantiate an equivalent <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><mi>′</mi></mrow><annotation encoding="application/x-tex">f_{DBF}&#39;</annotation></semantics></math> simply as</p>
<div class="sourceCode" id="cb16" data-startFrom="196"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 195;"><span id="cb16-196"><a href="#cb16-196"></a>fDBF&#39; antennaEl <span class="ot">=</span> antennaEl <span class="ot">`dotvm`</span> beamConsts</span>
<span id="cb16-197"><a href="#cb16-197"></a>  <span class="kw">where</span></span>
<span id="cb16-198"><a href="#cb16-198"></a>    beamConsts <span class="ot">=</span> mkBeamConsts dElements waveLength nA<span class="ot"> nB ::</span> <span class="dt">Matrix</span> <span class="dt">CpxData</span></span></code></pre></div>
<p>The expanded version <code>fDBF</code> was given mainly for didactic purpose, to get a feeling for how to manipulate different skeletons to obtain more complex operations or systems. From now on, in this section we will only use the library-provided operations, and we will study them in-depth only later in section <a href="#sec:refine">6</a>.</p>
<h4 data-number="2.2.2.2" id="sec:cube-pc-atom"><span class="header-section-number">2.2.2.2</span> Pulse Compression (PC)</h4>
<figure>
<img src="figs/pc-cube.png" id="fig:cube-pc-cube" alt="" /><figcaption>Figure 6: PC: direction of application on video structure (left); process (right)</figcaption>
</figure>
<p>In this stage the received echo of the modulated pulse, i.e. the information contained by the range bins, is passed through a matched filter for decoding their modulation. This essentially applies a sliding window, or a moving average on the range bin samples. Considering the video cube, the PC transformation is applied in the direction shown in Figure <a href="#fig:cube-pc-cube">6</a>, i.e. on vectors formed from the range of every pulse.</p>
<p>The PC process is mapping the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>P</mi><mi>C</mi></mrow></msub><annotation encoding="application/x-tex">f_{PC}</annotation></semantics></math> on each row of the pulse matrices in a cube, however the previous stage has arranged the cube to be aligned beam-wise. This is why we need to re-arrange the data so that the innermost vectors are <code>Range</code>s instead, and we do this by simply <code>transpose</code>-ing the inner <code>Range</code> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>×</mo><annotation encoding="application/x-tex">\times</annotation></semantics></math> <code>Beam</code> matrices into <code>Beam</code> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>×</mo><annotation encoding="application/x-tex">\times</annotation></semantics></math> <code>Range</code> ones.</p>
<div class="sourceCode" id="cb17" data-startFrom="221"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 220;"><span id="cb17-221"><a href="#cb17-221"></a><span class="ot">pc ::</span> <span class="dt">Signal</span> (<span class="dt">Window</span> (<span class="dt">Range</span> (<span class="dt">Beam</span>  <span class="dt">CpxData</span>))) </span>
<span id="cb17-222"><a href="#cb17-222"></a>   <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Window</span> (<span class="dt">Beam</span>  (<span class="dt">Range</span> <span class="dt">CpxData</span>)))</span>
<span id="cb17-223"><a href="#cb17-223"></a>pc <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.farm11</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.farm11</a> fPC <span class="op">.</span> M.transpose))</span>
<span id="cb17-224"><a href="#cb17-224"></a><span class="co">--             ^ == (M.farm11 fPC . &quot;&lt;a href=&#39;https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html&#39;&gt;&quot;V.farm11&quot;</a>&quot; M.transpose)</span></span></code></pre></div>
<p>Here the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>P</mi><mi>C</mi></mrow></msub><annotation encoding="application/x-tex">f_{PC}</annotation></semantics></math> applies the <code>fir</code> skeleton on these vectors (which computes a moving average if considering vectors). The <code>fir</code> skeleton is a utility formulated in terms of primitive skeletons (i.e. <code>farm</code> and <code>reduce</code>) on numbers, i.e. lifting arithmetic functions. We will study this skeleton later in this report and for now we take it “for granted”, as conveniently provided by the <code>DSP</code> utility library. For this application we also use a relatively small average window (5 taps).</p>
<div class="sourceCode" id="cb18" data-startFrom="233"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 232;"><span id="cb18-233"><a href="#cb18-233"></a><span class="ot">fPC ::</span> <span class="dt">Range</span> <span class="dt">CpxData</span> <span class="co">-- ^ input range bin     </span></span>
<span id="cb18-234"><a href="#cb18-234"></a>    <span class="ot">-&gt;</span> <span class="dt">Range</span> <span class="dt">CpxData</span> <span class="co">-- ^ output pulse-compressed bin</span></span>
<span id="cb18-235"><a href="#cb18-235"></a>fPC <span class="ot">=</span> fir (mkPcCoefs pcTap)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>comb11</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>ForSyDe.Atom.MoC.SY</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>farm11</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>farm11</code>, <code>transpose</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><code>ForSyDe.Atom.Skel.FastVector.Matrix</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>fir</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><code>ForSyDe.Atom.Skel.FastVector.DSP</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>mkPcCoefs</code></td>
<td><code>AESA.Coefs</code></td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<h4 data-number="2.2.2.3" id="sec:cube-ct-atom"><span class="header-section-number">2.2.2.3</span> Corner Turn (CT) with 50% overlapping data</h4>
<figure>
<img src="figs/ct-cube.png" id="fig:cube-ct-cube" alt="" /><figcaption>Figure 7: Concurrent processing on 50% overlapped data</figcaption>
</figure>
<p>During the CT a rearrangement of data must be performed between functions that process data in “different” directions, e.g. range and pulse, in order to be able to calculate the Doppler channels further in the processing pipeline. The process of corner turning becomes highly relevant when detailed time behavior of the application is being derived or inferred, since it demands well-planned design decisions to make full use of the underlying architecture. At the level of abstraction on which we work right now though, it is merely a matrix <code>transpose</code> operation, and it can very well be postponed until the beginning of the next stage. However, a much more interesting operation is depicted in Figure <a href="#fig:cube-ct-cube">7</a>: in order to maximize the efficiency of the AESA processing the datapath is split into two concurrent processing channels with 50% overlapped data.</p>
<p>Implementing such a behavior requires a bit of “ForSyDe thinking”. At a first glance, the problem seems easily solved considering only the cube structures: just “ignore” half of the first cube of the right channel, while the left channel replicates the input. However, there are some timing issues with this setup: from the left channel’s perspective, the right channel is in fact “peaking into the future”, which is an abnormal behavior. Without going too much into details, you need to understand that <em>any type of signal “cleaning”, like dropping or filtering out events, can cause serious causality issues in a generic process network, and thus it is <strong>illegal</strong> in ForSyDe system modeling</em>. On the other hand we could <em>delay</em> the left channel in a deterministic manner by assuming a well-defined <em>initial state</em> (e.g. all zeroes) while it waits for the right channel to consume and process its first half of data. This defines the history of a system where all components start from <em>time zero</em> and eliminates any source of “clairvoyant”/ambiguous behavior.</p>
<p>To keep things simple, we stay within the same time domain, keeping the perfect synchrony assumption, and instantiating the left channel building mechanism as a simple Mealy finite state machine. This machine splits an input cube into two halves, stores one half and merges the other half with the previously stored state to create the left channel stream of cubes.</p>
<figure>
<img src="figs/ct-proc-atom.png" id="fig:cube-ct-proc-atom" alt="" /><figcaption>Figure 8: Left channel data builder process</figcaption>
</figure>
<div class="sourceCode" id="cb19" data-startFrom="283"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 282;"><span id="cb19-283"><a href="#cb19-283"></a><span class="ot">overlap ::</span> <span class="dt">Signal</span> (<span class="dt">Window</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> <span class="dt">CpxData</span>)))</span>
<span id="cb19-284"><a href="#cb19-284"></a>        <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Window</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> <span class="dt">CpxData</span>)))</span>
<span id="cb19-285"><a href="#cb19-285"></a>overlap <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.mealy11</a> nextState outDecode initState</span>
<span id="cb19-286"><a href="#cb19-286"></a>  <span class="kw">where</span></span>
<span id="cb19-287"><a href="#cb19-287"></a>    nextState _ cube <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.drop</a> (nFFT <span class="ot">`div`</span> <span class="dv">2</span>) cube</span>
<span id="cb19-288"><a href="#cb19-288"></a>    outDecode s cube <span class="ot">=</span> s <span class="op">&lt;++&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.take</a> (nFFT <span class="ot">`div`</span> <span class="dv">2</span>) cube</span>
<span id="cb19-289"><a href="#cb19-289"></a>    initState        <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.fanoutn</a> (nFFT <span class="ot">`div`</span> <span class="dv">2</span>) <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fanoutn</a> nB <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fanoutn</a> nb) <span class="dv">0</span></span></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mealy11</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>ForSyDe.Atom.MoC.SY</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>drop</code>, <code>take</code>, <code>fanoutn</code>, <code>(&lt;++&gt;)</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>nFFT</code>, <code>nA</code>, <code>nB</code></td>
<td><code>AESA.Params</code></td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<p><strong>OBS!</strong> Perhaps considering all zeroes for the initial state might not be the best design decision, since that is in fact “junk data” which is propagated throughout the system and which alters the expected behavior. A much safer (and semantically correct) approach would be to model the initial state using <em>absent events</em> instead of arbitrary data. However this demands the introduction of a new layer and some quite advanced modeling concepts which are out of the scope of this report<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. For the sake of simplicity we now consider that the initial state is half a cube of zeroes and that there are no absent events in the system. As earlier mentioned, it is <em>illegal</em> to assume any type of signal cleaning during system modeling, however this law does not apply to the <em>observer</em> (i.e. the testbench), who is free to take into consideration whichever parts of the signals it deems necessary. We will abuse this knowledge in order to show a realistic output behavior of the AESA signal processing system: as “observers”, we will ignore the effects of the initial state propagation from the output signal and instead plot only the useful data.</p>
<h4 data-number="2.2.2.4" id="sec:cube-dfb-atom"><span class="header-section-number">2.2.2.4</span> Doppler Filter Bank (DFB)</h4>
<p>During the Doppler filter bank, every window of samples, associated with each range bin is transformed into a Doppler channel and the complex samples are converted to real numbers by calculating their envelope.</p>
<p>The <code>dfb</code> process applies the the following chain of functions on each window of complex samples, in three consecutive steps:</p>
<ul>
<li><p>scale the window samples with a set of coefficients to decrease the Doppler side lobes from each FFT output and thereby to increase the clutter rejection.</p></li>
<li><p>apply an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><annotation encoding="application/x-tex">N_{FFT}</annotation></semantics></math>-point 2-radix decimation in frequency Fast Fourier Transform (FFT) algorithm.</p></li>
<li><p>compute the envelope of each complex sample when phase information is no longer of interest. The envelope is obtained by calculating the absolute value of the complex number, converting it into a real number.</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>farm11</code>,<code>farm21</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>fft</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><code>ForSyDe.Atom.Skel.FastVector.DSP</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>mkWeightCoefs</code></td>
<td><code>AESA.Coefs</code></td>
<td>aesa-atom</td>
</tr>
<tr class="even">
<td><code>nS</code>, <code>nFFT</code></td>
<td><code>AESA.Params</code></td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<figure>
<img src="figs/dfb-cube.png" id="fig:cube-dfb-cube" alt="" /><figcaption>Figure 9: Doppler Filter Bank on video structure</figcaption>
</figure>
<figure>
<img src="figs/dfb-proc-atom.png" id="fig:cube-dfb-proc-atom" alt="" /><figcaption>Figure 10: DFB process</figcaption>
</figure>
<div class="sourceCode" id="cb20" data-startFrom="346"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 345;"><span id="cb20-346"><a href="#cb20-346"></a><span class="ot">dfb ::</span> <span class="dt">Signal</span> (<span class="dt">Window</span> (<span class="dt">Beam</span>  (<span class="dt">Range</span>  <span class="dt">CpxData</span> )))</span>
<span id="cb20-347"><a href="#cb20-347"></a>    <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Beam</span>   (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb20-348"><a href="#cb20-348"></a>dfb <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> (M.farm11 fDFB <span class="op">.</span> C.transpose)</span>
<span id="cb20-349"><a href="#cb20-349"></a></span>
<span id="cb20-350"><a href="#cb20-350"></a><span class="ot">fDFB ::</span> <span class="dt">Window</span> <span class="dt">CpxData</span> <span class="ot">-&gt;</span> <span class="dt">Window</span> <span class="dt">RealData</span></span>
<span id="cb20-351"><a href="#cb20-351"></a>fDFB <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> envelope <span class="op">.</span> fft nS <span class="op">.</span> weight</span>
<span id="cb20-352"><a href="#cb20-352"></a>  <span class="kw">where</span></span>
<span id="cb20-353"><a href="#cb20-353"></a>    weight     <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm21</a> (<span class="op">*</span>) (mkWeightCoefs nFFT)</span>
<span id="cb20-354"><a href="#cb20-354"></a>    envelope a <span class="ot">=</span> <span class="kw">let</span> (i, q) <span class="ot">=</span> (realPart a, imagPart a)</span>
<span id="cb20-355"><a href="#cb20-355"></a>                 <span class="kw">in</span> <span class="fu">sqrt</span> (i <span class="op">*</span> i <span class="op">+</span> q <span class="op">*</span> q)</span></code></pre></div>
<h4 data-number="2.2.2.5" id="sec:cube-cfar-atom"><span class="header-section-number">2.2.2.5</span> Constant False Alarm Ratio (CFAR)</h4>
<p>The CFAR normalizes the data within the video cubes in order to maintain a constant false alarm rate with respect to a detection threshold. This is done in order to keep the number of false targets at an acceptable level by adapting the normalization to the clutter situation in the area (around a cell under test) of interest. The described process can be depicted as in Figure <a href="#fig:cube-cfar-cube">11</a> which suggests the <a href="https://en.wikipedia.org/wiki/Stencil_code">stencil</a> data accessing pattern within the video cubes.</p>
<figure>
<img src="figs/cfar-cube.png" id="fig:cube-cfar-cube" alt="" /><figcaption>Figure 11: Constant False Alarm Ratio on cubes of complex samples</figcaption>
</figure>
<div class="sourceCode" id="cb21" data-startFrom="369"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 368;"><span id="cb21-369"><a href="#cb21-369"></a><span class="ot">cfar ::</span> <span class="dt">Signal</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb21-370"><a href="#cb21-370"></a>     <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb21-371"><a href="#cb21-371"></a>cfar <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.farm11</a> fCFAR)</span></code></pre></div>
<figure>
<img src="figs/cfar-proc-atom.png" id="fig:cube-cfar-proc-atom" alt="" /><figcaption>Figure 12: CFAR process</figcaption>
</figure>
<p>The <code>cfar</code> process applies the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>C</mi><mi>F</mi><mi>A</mi><mi>R</mi></mrow></msub><annotation encoding="application/x-tex">f_{CFAR}</annotation></semantics></math> function on every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub><mo>×</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow><annotation encoding="application/x-tex">N_b\times N_{FFT}</annotation></semantics></math> matrix corresponding to each beam. The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>C</mi><mi>F</mi><mi>A</mi><mi>R</mi></mrow></msub><annotation encoding="application/x-tex">f_{CFAR}</annotation></semantics></math> function normalizes each Doppler window, after which the sensitivity will be adapted to the clutter situation in current area, as seen in Figure <a href="#fig:cube-cfar-signal">13</a>. The blue line indicates the mean value of maximum of the left and right reference bins, which means that for each Doppler sample, a swipe of neighbouring bins is necessary, as suggested by Figure <a href="#fig:cube-cfar-cube">11</a>. This is a typical pattern in signal processing called <a href="https://en.wikipedia.org/wiki/Stencil_code">stencil</a>, which will constitute the main parallel skeleton within the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>C</mi><mi>F</mi><mi>A</mi><mi>R</mi></mrow></msub><annotation encoding="application/x-tex">f_{CFAR}</annotation></semantics></math> function.</p>
<figure>
<img src="figs/cfar-signal.png" id="fig:cube-cfar-signal" width="400" alt="" /><figcaption>Figure 13: The signal level within one pulse window: a) before CFAR; b) after CFAR</figcaption>
</figure>
<div class="sourceCode" id="cb22" data-startFrom="387"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 386;"><span id="cb22-387"><a href="#cb22-387"></a><span class="ot">fCFAR ::</span> <span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>) <span class="ot">-&gt;</span> <span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)</span>
<span id="cb22-388"><a href="#cb22-388"></a>fCFAR rbins <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm41</a> (\m <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm31</a> (normCfa m)) md rbins lmv emv</span>
<span id="cb22-389"><a href="#cb22-389"></a>  <span class="kw">where</span></span>
<span id="cb22-390"><a href="#cb22-390"></a>    md  <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> (<span class="fu">logBase</span> <span class="dv">2</span> <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.reduce</a> <span class="fu">min</span>) rbins</span>
<span id="cb22-391"><a href="#cb22-391"></a>    emv <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.fanoutn</a> (nFFT <span class="op">+</span> <span class="dv">1</span>) dummy) <span class="op">&lt;++&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.farm11</a> aritMean neighbors)</span>
<span id="cb22-392"><a href="#cb22-392"></a>    lmv <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.drop</a> <span class="dv">2</span> <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> aritMean neighbors) <span class="op">&lt;++&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.fanout</a> dummy) </span>
<span id="cb22-393"><a href="#cb22-393"></a>    <span class="co">-----------------------------------------------</span></span>
<span id="cb22-394"><a href="#cb22-394"></a>    normCfa m a l e <span class="ot">=</span> <span class="dv">2</span> <span class="op">**</span> (<span class="dv">5</span> <span class="op">+</span> <span class="fu">logBase</span> <span class="dv">2</span> a <span class="op">-</span> <span class="fu">maximum</span> [l,e,m])</span>
<span id="cb22-395"><a href="#cb22-395"></a><span class="ot">    aritMean ::</span> <span class="dt">Vector</span> (<span class="dt">Vector</span> <span class="dt">RealData</span>) <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">RealData</span></span>
<span id="cb22-396"><a href="#cb22-396"></a>    aritMean  <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> (<span class="op">/</span>n) <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.reduce</a> addV <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> geomMean <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.group</a> <span class="dv">4</span></span>
<span id="cb22-397"><a href="#cb22-397"></a>    geomMean  <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> (<span class="fu">logBase</span> <span class="dv">2</span> <span class="op">.</span> (<span class="op">/</span><span class="dv">4</span>)) <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.reduce</a> addV</span>
<span id="cb22-398"><a href="#cb22-398"></a>    <span class="co">-----------------------------------------------</span></span>
<span id="cb22-399"><a href="#cb22-399"></a>    dummy     <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fanoutn</a> nFFT (<span class="op">-</span>maxFloat)</span>
<span id="cb22-400"><a href="#cb22-400"></a>    neighbors <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.stencil</a> nFFT rbins</span>
<span id="cb22-401"><a href="#cb22-401"></a>    <span class="co">-----------------------------------------------</span></span>
<span id="cb22-402"><a href="#cb22-402"></a>    addV      <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm21</a> (<span class="op">+</span>)</span>
<span id="cb22-403"><a href="#cb22-403"></a>    n         <span class="ot">=</span> <span class="fu">fromIntegral</span> nFFT</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>farm</code>[<code>4</code>/<code>3</code>/<code>1</code>]<code>1</code>, <code>reduce</code>, <code>&lt;++&gt;</code>,</td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>drop</code>, <code>fanout</code>, <code>fanoutn</code>, <code>stencil</code></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>comb11</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>ForSyDe.Atom.MoC.SY</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>maxFloat</code></td>
<td>AESA.Coefs</td>
<td>aesa-atom</td>
</tr>
<tr class="odd">
<td><code>nb</code>, <code>nFFT</code></td>
<td><code>AESA.Params</code></td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<p>The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>C</mi><mi>F</mi><mi>A</mi><mi>R</mi></mrow></msub><annotation encoding="application/x-tex">f_{CFAR}</annotation></semantics></math> function itself can be described with the system of eq. <a href="#eq:cfar">3</a>, where</p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">MD</annotation></semantics></math> is the minimum value over all Doppler channels in a batch for a specific data channel and range bin.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>M</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">EMV</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>M</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">LMV</annotation></semantics></math> calculate the early and respectively late mean values from the neighboring range bins as a combination of geometric and arithmetic mean values.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">eb</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">lb</annotation></semantics></math> are the earliest bin, respectively latest bin for which the CFAR can be calculated as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>M</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">EMV</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>M</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">LMV</annotation></semantics></math> require at least <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><annotation encoding="application/x-tex">N_{FFT}</annotation></semantics></math> bins + 1 guard bin before and respectively after the current bin. This phenomenon is also called the “stencil halo”, which means that CFAR, as defined in eq. <a href="#eq:cfar">3</a> is applied only on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub><mi>′</mi><mo>=</mo><msub><mi>N</mi><mi>b</mi></msub><mo>−</mo><mn>2</mn><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">N_b&#39;=N_b-2N_{FFT}-2</annotation></semantics></math> bins.</p></li>
<li><p>bins earlier than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">eb</annotation></semantics></math>, respectively later than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">lb</annotation></semantics></math>, are ignored by the CFAR formula and therefore their respective EMV and LMV are replaced with the lowest representable value.</p></li>
<li><p>5 is added to the exponent of the CFAR equation to set the gain to 32 (i.e. with only noise in the incoming video the output values will be 32).</p></li>
</ul>
<p><span id="eq:cfar"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtable><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>C</mi><mi>F</mi><mi>A</mi><mi>R</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mo stretchy="false" form="prefix">(</mo><mn>5</mn><mo>+</mo><msub><mo>log</mo><mn>2</mn></msub><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mo>max</mo><mo stretchy="false" form="prefix">(</mo><mi>E</mi><mi>M</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>L</mi><mi>M</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>M</mi><mi>D</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow></msup></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>E</mi><mi>M</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>log</mo><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>0</mn></mrow><mn>3</mn></munderover><msub><mi>a</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo>−</mo><mn>4</mn><mi>k</mi><mo>−</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>L</mi><mi>M</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>log</mo><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>0</mn></mrow><mn>3</mn></munderover><msub><mi>a</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mi>k</mi><mo>+</mo><mi>l</mi><mo stretchy="false" form="postfix">)</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>M</mi><mi>D</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mo>log</mo><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>min</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="2.0em"></mspace><mo>∀</mo><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mi>e</mi><mi>b</mi><mo>,</mo><mi>l</mi><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mi>j</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo>,</mo><mi>N</mi><mo stretchy="false" form="postfix">]</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> where </mtext><mspace width="0.333em"></mspace></mrow><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>N</mi><mo>=</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>e</mi><mi>b</mi><mo>=</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>+</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>l</mi><mi>b</mi><mo>=</mo><msub><mi>N</mi><mi>b</mi></msub><mo>−</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>−</mo><mn>1</mn></mtd></mtr></mtable></mrow></mtd></mtr></mtable><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\begin{aligned}&amp;\left\{\begin{aligned}
  &amp;CFAR(a_{ij})= 2^{(5 + \log_2 a_{ij}) - \max (EMV(a_{ij}),LMV(a_{ij}),MD(a_{ij}))}\\
  &amp;EMV(a_{ij}) = \frac{1}{N}\sum_{k=0}^{N-1}\left(\log_2\left(\frac{1}{4}\sum_{l=0}^{3}a_{(i-2-4k-l)j}\right)\right)\\
  &amp;LMV(a_{ij}) = \frac{1}{N}\sum_{k=0}^{N-1}\left(\log_2\left(\frac{1}{4}\sum_{l=0}^{3}a_{(i+2+4k+l)j}\right)\right)\\
  &amp;MD(a_{ij})  = \log_{2}\left(\min_{k=1}^N(a_{ik})\right)
  \end{aligned}\right.\\
  &amp;\qquad \forall i\in[eb,lb], j\in[1,N] \text{ where }\left\{
  \begin{aligned}
  &amp;N = N_{FFT}\\
  &amp;eb = N_{FFT} + 1\\
  &amp;lb = N_b - N_{FFT} - 1\\
  \end{aligned}\right.
  \end{aligned}
\qquad(3)</annotation></semantics></math></span></p>
<p>The first thing we calculate is the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">MD</annotation></semantics></math> for each Doppler window (row). For each row of <code>rbins</code> (i.e. range bins of Doppler windows) we look for the minimum value (<code>reduce min</code>) and apply the binary logarithm on it.</p>
<p>Another action performed over the matrix <code>rbins</code> is to form two stencil “cubes” for EMV and LMV respectively, by gathering batches of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><annotation encoding="application/x-tex">N_{FFT}</annotation></semantics></math> Doppler windows like in eq. <a href="#eq:cfar-stencil">4</a>, computing them like in eq. <a href="#eq:cfar-emv">5</a>.</p>
<p><span id="eq:cfar-stencil"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd columnalign="center"><msub><mi>a</mi><mn>12</mn></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mn>1</mn><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>a</mi><mn>21</mn></msub></mtd><mtd columnalign="center"><msub><mi>a</mi><mn>22</mn></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mn>2</mn><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mi>b</mi></msub><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mi>b</mi></msub><mn>2</mn></mrow></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mi>b</mi></msub><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mtext mathvariant="normal">rbins</mtext></mover><mover><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚜</mi><mi>𝚝</mi><mi>𝚎</mi><mi>𝚗</mi><mi>𝚌</mi><mi>𝚒</mi><mi>𝚕</mi></mstyle></mover><mover><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd columnalign="center"><msub><mi>a</mi><mn>12</mn></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mn>1</mn><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mn>2</mn></mrow></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>a</mi><mn>21</mn></msub></mtd><mtd columnalign="center"><msub><mi>a</mi><mn>22</mn></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mn>2</mn><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>a</mi><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>a</mi><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>N</mi><mi>b</mi></msub><mo>−</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>N</mi><mi>b</mi></msub><mo>−</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>N</mi><mi>b</mi></msub><mo>−</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mi>b</mi></msub><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mi>b</mi></msub><mn>2</mn></mrow></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mi>b</mi></msub><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mtext mathvariant="normal">neighbors</mtext></mover><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
  \stackrel{\mbox{rbins}}{
  \begin{bmatrix}
  a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1N_{FFT}} \\
  a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2N_{FFT}} \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  a_{N_b1} &amp; a_{N_b2} &amp; \cdots &amp; a_{N_bN_{FFT}}
  \end{bmatrix}}
  \stackrel{\mathtt{stencil}}{\rightarrow}
  \stackrel{\mbox{neighbors}}{
  \begin{bmatrix}
  \begin{bmatrix}
  a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1N_{FFT}} \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  a_{N_{FFT}1} &amp; a_{N_{FFT}2} &amp; \cdots &amp; a_{N_{FFT}N_{FFT}} \\
  \end{bmatrix}\\
  \begin{bmatrix}
  a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2N_{FFT}} \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  a_{(N_{FFT}+1)1} &amp; a_{(N_{FFT}+1)2} &amp; \cdots &amp; a_{(N_{FFT}+1)N_{FFT}} \\
  \end{bmatrix}\\
  \vdots \\
  \begin{bmatrix}
  a_{(N_b-N_{FFT})1} &amp; a_{(N_b-N_{FFT})2} &amp; \cdots &amp; a_{(N_b-N_{FFT})N_{FFT}}\\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  a_{N_b1} &amp; a_{N_b2} &amp; \cdots &amp; a_{N_bN_{FFT}}
  \end{bmatrix}
  \end{bmatrix}}
\qquad(4)</annotation></semantics></math></span></p>
<p>Each one of these neighbors matrices will constitute the input data for calculating the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>M</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">EMV</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>M</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">LMV</annotation></semantics></math> for each Doppler window. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>M</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">EMV</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>M</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">LMV</annotation></semantics></math> are calculated by applying the mean function <code>arithMean</code> over them, as shown (only for the window associated with the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">eb</annotation></semantics></math> bin) in eq. <a href="#eq:cfar-emv">5</a>. The resulting <code>emv</code> and <code>lmv</code> matrices are padded with rows of the minimum representable value <code>-maxFloat</code>, so that they align properly with <code>rbins</code> in order to combine into the 2D farm/stencil defined at eq. <a href="#eq:cfar">3</a>. Finally, <code>fCFAR</code> yields a matrix of normalized Doppler windows. The resulting matrices are not transformed back into sample streams by the parent process, but rather they are passed as single tokens downstream to the INT stage, where they will be processed as such.</p>
<p><span id="eq:cfar-emv"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtable><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mn>1</mn><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mover><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚐</mi><mi>𝚛</mi><mi>𝚘</mi><mi>𝚞</mi><mi>𝚙</mi></mstyle></mover><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mn>1</mn><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>a</mi><mn>41</mn></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mn>4</mn><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mi>a</mi><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>−</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>−</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mi>a</mi><mrow><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mover><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚏</mi><mi>𝚊</mi><mi>𝚛</mi><mi>𝚖</mi><mo stretchy="false" form="prefix">(</mo><mi>𝚐</mi><mi>𝚎</mi><mi>𝚘</mi><mi>𝚖</mi><mi>𝙼</mi><mi>𝚎</mi><mi>𝚊</mi><mi>𝚗</mi><mo stretchy="false" form="postfix">)</mo></mstyle></mover><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><msub><mo>log</mo><mn>2</mn></msub><mfrac><mn>1</mn><mn>4</mn></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>4</mn></munderover><msub><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mo>log</mo><mn>2</mn></msub><mfrac><mn>1</mn><mn>4</mn></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>4</mn></munderover><msub><mi>a</mi><mrow><mi>i</mi><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><mi>⋮</mi></mtd><mtd columnalign="center"><mi>⋱</mi></mtd><mtd columnalign="center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center"><msub><mo>log</mo><mn>2</mn></msub><mfrac><mn>1</mn><mn>4</mn></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>−</mo><mn>4</mn></mrow><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></munderover><msub><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><msub><mo>log</mo><mn>2</mn></msub><mfrac><mn>1</mn><mn>4</mn></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>−</mo><mn>4</mn></mrow><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></munderover><msub><mi>a</mi><mrow><mi>i</mi><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mover><mo>→</mo><mstyle mathvariant="monospace"><mo stretchy="false" form="prefix">(</mo><mi>/</mi><msub><mi>𝙽</mi><mrow><mi>𝙵</mi><mi>𝙵</mi><mi>𝚃</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><mi>𝚛</mi><mi>𝚎</mi><mi>𝚍</mi><mi>𝚞</mi><mi>𝚌</mi><mi>𝚎</mi><mo stretchy="false" form="prefix">(</mo><mo>+</mo><mo stretchy="false" form="postfix">)</mo></mstyle></mover><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center"><mi>E</mi><mi>M</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>e</mi><mi>b</mi><mo>,</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="center"><mi>⋯</mi></mtd><mtd columnalign="center"><mi>E</mi><mi>M</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>e</mi><mi>b</mi><mo>,</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>5</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\begin{aligned}
  &amp;\begin{bmatrix}
  a_{11} &amp; \cdots &amp; a_{1N_{FFT}} \\
  \vdots  &amp; \ddots &amp; \vdots \\
  a_{N_{FFT}1}  &amp; \cdots &amp; a_{N_{FFT}N_{FFT}}
  \end{bmatrix}
  \stackrel{\mathtt{group}}{\rightarrow}
  \begin{bmatrix}
  \begin{bmatrix}
  a_{11} &amp; \cdots &amp; a_{1N_{FFT}} \\
  \vdots &amp; \ddots &amp; \vdots \\
  a_{41} &amp; \cdots &amp; a_{4N_{FFT}}
  \end{bmatrix}\\
  \vdots \\
  \begin{bmatrix}
  a_{(N_{FFT}-4)1}  &amp; \cdots &amp; a_{(N_{FFT}-4)N_{FFT}}\\
  \vdots &amp; \ddots &amp; \vdots \\
  a_{N_{FFT}1}  &amp; \cdots &amp; a_{N_{FFT}N_{FFT}}
  \end{bmatrix}
  \end{bmatrix}\\
  &amp;\stackrel{\mathtt{farm(geomMean)}}{\rightarrow}
  \begin{bmatrix}
  \log_2\frac{1}{4}\sum_{i=1}^{4}a_{i1} &amp; \cdots &amp; \log_2\frac{1}{4}\sum_{i=1}^{4}a_{iN_{FFT}} \\
  \vdots &amp; \ddots &amp; \vdots \\
  \log_2\frac{1}{4}\sum_{i=N_{FFT}-4}^{N_{FFT}}a_{i1} &amp; \cdots &amp; \log_2\frac{1}{4}\sum_{i=N_{FFT}-4}^{N_{FFT}}a_{iN_{FFT}}
  \end{bmatrix}\\
  &amp;\stackrel{\mathtt{(/N_{FFT})\circ reduce(+)}}{\rightarrow}
  \begin{bmatrix}
  EMV(a_{eb,1}) &amp; \cdots &amp; EMV(a_{eb,N_{FFT}}) 
  \end{bmatrix}
  \end{aligned}
\qquad(5)</annotation></semantics></math></span></p>
<h4 data-number="2.2.2.6" id="sec:cube-int-atom"><span class="header-section-number">2.2.2.6</span> Integrator (INT)</h4>
<p>During the last stage of the video processing chain each data sample of the video cube is integrated against its 8 previous values using an 8-tap FIR filter, as suggested by the drawing in Figure <a href="#fig:cube-int-cube-atom">14</a>.</p>
<div class="sourceCode" id="cb23" data-startFrom="536"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 535;"><span id="cb23-536"><a href="#cb23-536"></a><span class="ot">int ::</span> <span class="dt">Signal</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb23-537"><a href="#cb23-537"></a>    <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb23-538"><a href="#cb23-538"></a>    <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb23-539"><a href="#cb23-539"></a>int right left <span class="ot">=</span> firNet mkIntCoefs <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.interleave2</a> right left</span></code></pre></div>
<p>Before integrating though, the data from both the left and the right channel need to be merged and interleaved. This is done by the process <code>interleave</code> below, which is a convenient utility exported by the SY library, hiding a domain interface. When considering only the data structures, the <code>interleave</code> process can be regarded as an up-sampler with the rate 2/1. When taking into consideration the size of the entire data set (i.e. token rates <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>×</mo><annotation encoding="application/x-tex">\times</annotation></semantics></math> structure sizes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>×</mo><annotation encoding="application/x-tex">\times</annotation></semantics></math> data size), we can easily see that the overall required system bandwidth (ratio) remains the same between the PC and INT stages, i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>2</mn><mo>×</mo><msub><mi>N</mi><mi>B</mi></msub><mo>×</mo><msub><mi>N</mi><mi>b</mi></msub><mo>×</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>×</mo><mstyle mathvariant="italic"><mi>𝑠</mi><mi>𝑖</mi><mi>𝑧</mi><mi>𝑒</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚎</mi><mi>𝚊</mi><mi>𝚕</mi><mi>𝙳</mi><mi>𝚊</mi><mi>𝚝</mi><mi>𝚊</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><mrow><msub><mi>N</mi><mi>B</mi></msub><mo>×</mo><msub><mi>N</mi><mi>b</mi></msub><mo>×</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>×</mo><mstyle mathvariant="italic"><mi>𝑠</mi><mi>𝑖</mi><mi>𝑧</mi><mi>𝑒</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="monospace"><mi>𝙲</mi><mi>𝚙</mi><mi>𝚡</mi><mi>𝙳</mi><mi>𝚊</mi><mi>𝚝</mi><mi>𝚊</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo>=</mo><mn>1</mn><mi>/</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{2\times N_B \times N_{b} \times N_{FFT}\times \mathit{size}(\mathtt{RealData})}{N_B \times N_{b} \times N_{FFT}\times \mathit{size}(\mathtt{CpxData})}=1/1</annotation></semantics></math>.</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>farm21</code>,<code>farm11</code>,<code>fanout</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Cube.html"><code>ForSyDe.Atom.Skel.FastVector.Cube</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>fir'</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><code>ForSyDe.Atom.Skel.FastVector.DSP</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>comb21</code>,<code>comb11</code>, <code>delay</code>, <code>interleave2</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>ForSyDe.Atom.MoC.SY</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>mkFirCoefs</code></td>
<td>AESA.Coefs</td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<figure>
<img src="figs/int-cube.png" id="fig:cube-int-cube-atom" alt="" /><figcaption>Figure 14: Integration on cubes of complex samples</figcaption>
</figure>
<figure>
<img src="figs/int-proc-atom.png" id="fig:cube-int-atom" alt="" /><figcaption>Figure 15: INT network</figcaption>
</figure>
<p>The 8-tap FIR filter used for integration is also a moving average, but as compared to the <code>fir</code> function used in section <a href="#sec:cube-pc-atom">2.2.2.2</a>, the window slides in time domain, i.e. over streaming samples rather than over vector elements. To instantiate a FIR system we use the <code>fir'</code> skeleton provided by the ForSyDe-Atom DSP utility libraries, which constructs the the well-recognizable FIR pattern in Figure <a href="#fig:cube-int-atom">15</a>, i.e. a recur-farm-reduce composition. In order to do so, <code>fir'</code> needs to know <em>what</em> to fill this template with, thus we need to provide as arguments its “basic” operations, which in our case are processes operating on signals of matrices. In fact, <code>fir</code> itself is a <em>specialization</em> of the <code>fir'</code> skeleton, which defines its basic operations as corresponding functions on vectors. This feature derives from a powerful algebra of skeletons which grants them both modularity, and the possibility to transform them into semantically-equivalent forms, as we shall soon explore in section <a href="#sec:synth">7</a>.</p>
<div class="sourceCode" id="cb24" data-startFrom="577"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 576;"><span id="cb24-577"><a href="#cb24-577"></a><span class="ot">firNet ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Cube</span> a) <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Cube</span> a)</span>
<span id="cb24-578"><a href="#cb24-578"></a>firNet coefs <span class="ot">=</span> fir&#39; addSC mulSC dlySC coefs</span>
<span id="cb24-579"><a href="#cb24-579"></a>  <span class="kw">where</span></span>
<span id="cb24-580"><a href="#cb24-580"></a>    addSC   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb21</a> (C.farm21 (<span class="op">+</span>))</span>
<span id="cb24-581"><a href="#cb24-581"></a>    mulSC c <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> (C.farm11 (<span class="op">*</span>c))</span>
<span id="cb24-582"><a href="#cb24-582"></a>    dlySC   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.delay</a>  (C.fanout <span class="dv">0</span>)</span></code></pre></div>
<h3 data-number="2.2.3" id="system-process-network"><span class="header-section-number">2.2.3</span> System Process Network</h3>
<p>The AESA process network is formed by “plugging in” together all components instantiated in the previous sections, and thus obtaining the system description in Figure <a href="#fig:cube-aesa-atom">16</a>. We do not transpose the output data, because the Doppler windows are the ones we are interested in plotting as the innermost structures.</p>
<figure>
<img src="figs/aesa-proc-atom.png" id="fig:cube-aesa-atom" alt="" /><figcaption>Figure 16: The AESA process network instance</figcaption>
</figure>
<div class="sourceCode" id="cb25" data-startFrom="593"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 592;"><span id="cb25-593"><a href="#cb25-593"></a><span class="ot">aesa ::</span> <span class="dt">Signal</span> (<span class="dt">Antenna</span> (<span class="dt">Window</span> (<span class="dt">Range</span>  <span class="dt">CpxData</span> )))</span>
<span id="cb25-594"><a href="#cb25-594"></a>     <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Beam</span>    (<span class="dt">Range</span>  (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb25-595"><a href="#cb25-595"></a>aesa video <span class="ot">=</span> int rCfar lCfar</span>
<span id="cb25-596"><a href="#cb25-596"></a>  <span class="kw">where</span></span>
<span id="cb25-597"><a href="#cb25-597"></a>    rCfar <span class="ot">=</span> cfar <span class="op">$</span> dfb oPc</span>
<span id="cb25-598"><a href="#cb25-598"></a>    lCfar <span class="ot">=</span> cfar <span class="op">$</span> dfb <span class="op">$</span> overlap oPc</span>
<span id="cb25-599"><a href="#cb25-599"></a>    oPc   <span class="ot">=</span> pc <span class="op">$</span> dbf video</span></code></pre></div>
<h3 data-number="2.2.4" label="AESA parameters" id="sec:aesa-parameters"><span class="header-section-number">2.2.4</span> System Parameters</h3>
<p>Here we define the size constants, for a simple test scenario. The size <code>nA</code> can be inferred from the size of input data and the vector operations.</p>
<div class="sourceCode" id="cb26" data-startFrom="6"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 5;"><span id="cb26-6"><a href="#cb26-6"></a><span class="kw">module</span> <span class="dt">AESA.Params</span> <span class="kw">where</span></span>
<span id="cb26-7"><a href="#cb26-7"></a></span>
<span id="cb26-8"><a href="#cb26-8"></a>nA    <span class="ot">=</span>   <span class="dv">16</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb26-9"><a href="#cb26-9"></a>nB    <span class="ot">=</span>    <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb26-10"><a href="#cb26-10"></a>nb    <span class="ot">=</span> <span class="dv">1024</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb26-11"><a href="#cb26-11"></a>nFFT  <span class="ot">=</span>  <span class="dv">256</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb26-12"><a href="#cb26-12"></a>nS    <span class="ot">=</span>    <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="co">-- 2^nS = nFFT; used for convenience</span></span>
<span id="cb26-13"><a href="#cb26-13"></a>pcTap <span class="ot">=</span>    <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="co">-- number of FIR taps in the PC stage</span></span>
<span id="cb26-14"><a href="#cb26-14"></a></span>
<span id="cb26-15"><a href="#cb26-15"></a>freqRadar  <span class="ot">=</span> <span class="fl">10e9</span><span class="ot"> ::</span> <span class="dt">Float</span> <span class="co">-- 10 Ghz X-band</span></span>
<span id="cb26-16"><a href="#cb26-16"></a>waveLength <span class="ot">=</span> <span class="fl">3e8</span> <span class="op">/</span> freqRadar</span>
<span id="cb26-17"><a href="#cb26-17"></a>dElements  <span class="ot">=</span> waveLength <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb26-18"><a href="#cb26-18"></a>fSampling  <span class="ot">=</span> <span class="fl">3e6</span><span class="ot"> ::</span> <span class="dt">Float</span></span>
<span id="cb26-19"><a href="#cb26-19"></a>pulseWidth <span class="ot">=</span> <span class="fl">1e-6</span><span class="ot"> ::</span> <span class="dt">Float</span></span></code></pre></div>
<h3 data-number="2.2.5" label="Coefficients" id="sec:coefs-atom"><span class="header-section-number">2.2.5</span> Coefficient Generators</h3>
<p>Here we define the vectors of coefficients used throughout the AESA design. We keep this module as independent as possible from the main design and export the coefficients both as ForSyDe-Atom vectors but also as Haskell native lists, so that other packages can make use of them, without importing the whole ForSyDe-Atom chain.</p>
<div class="sourceCode" id="cb27" data-startFrom="8"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 7;"><span id="cb27-8"><a href="#cb27-8"></a><span class="kw">module</span> <span class="dt">AESA.Coefs</span> <span class="kw">where</span></span></code></pre></div>
<div class="sourceCode" id="cb28" data-startFrom="10"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 9;"><span id="cb28-10"><a href="#cb28-10"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb28-11"><a href="#cb28-11"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.Matrix</span></a> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb28-12"><a href="#cb28-12"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.DSP</span></a></span>
<span id="cb28-13"><a href="#cb28-13"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span></code></pre></div>
<p>The <code>mkBeamConst</code> generator creates a matrix of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\alpha_{ij}</annotation></semantics></math> beam constants used in the digital beamforming stage section <a href="#sec:dbf-atom">6.1.2.1</a>. These beam constants perform both phase shift and tapering according to eq. <a href="#eq:beam-coef">6</a>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>k</mi></msub><annotation encoding="application/x-tex">c_k</annotation></semantics></math> performs tapering and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>φ</mi><mrow><mi>k</mi><mi>l</mi></mrow></msub><annotation encoding="application/x-tex">\varphi_{kl}</annotation></semantics></math> perform phase shifting. For tapering we use a set of Taylor coefficients generated with our in-house utility <code>taylor</code>. The phase shift shall be calculated according to eq. <a href="#eq:beam-phase">7</a>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math> is the distance between the antenna elements. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>l</mi></msub><annotation encoding="application/x-tex">\theta_l</annotation></semantics></math> is the angle between the wave front of the current beam and normal of the antenna elements and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> is the wavelength of the pulse.</p>
<p><span id="eq:beam-coef"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mrow><mi>k</mi><mi>l</mi></mrow></msub><mo>=</mo><msub><mi>c</mi><mi>k</mi></msub><msup><mi>e</mi><mrow><mi>j</mi><msub><mi>φ</mi><mrow><mi>k</mi><mi>l</mi></mrow></msub></mrow></msup><mo>,</mo><mspace width="0.222em"></mspace><mo>∀</mo><mi>k</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><msub><mi>N</mi><mi>A</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mi>l</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><msub><mi>N</mi><mi>B</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>6</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \alpha_{kl}=c_k e^{j\varphi_{kl}},\ \forall k\in[0,N_A-1], l \in [0,N_B-1]\qquad(6)</annotation></semantics></math></span></p>
<p><span id="eq:beam-phase"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mrow><mi>k</mi><mi>l</mi></mrow></msub><mo>=</mo><mfrac><mrow><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo>−</mo><mn>9.5</mn><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mn>2</mn><mi>π</mi><mo>⋅</mo><mi>d</mi><mo>sin</mo><mi>θ</mi></mrow><mi>λ</mi></mfrac><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>7</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \varphi_{kl}=\frac{(k-9.5)\cdot 2\pi\cdot d \sin\theta}{\lambda}\qquad(7)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb29" data-startFrom="28"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 27;"><span id="cb29-28"><a href="#cb29-28"></a><span class="ot">mkBeamConsts ::</span> <span class="dt">RealFloat</span> a</span>
<span id="cb29-29"><a href="#cb29-29"></a>             <span class="ot">=&gt;</span> a                  <span class="co">-- ^ distance between radar elements</span></span>
<span id="cb29-30"><a href="#cb29-30"></a>             <span class="ot">-&gt;</span> a                  <span class="co">-- ^ radar signal wavelength</span></span>
<span id="cb29-31"><a href="#cb29-31"></a>             <span class="ot">-&gt;</span> <span class="dt">Int</span>                <span class="co">-- ^ Number of antenna elements</span></span>
<span id="cb29-32"><a href="#cb29-32"></a>             <span class="ot">-&gt;</span> <span class="dt">Int</span>                <span class="co">-- ^ Number of resulting beams</span></span>
<span id="cb29-33"><a href="#cb29-33"></a>             <span class="ot">-&gt;</span> <span class="dt">Matrix</span> (<span class="dt">Complex</span> a)</span>
<span id="cb29-34"><a href="#cb29-34"></a>mkBeamConsts d lambda nA nB <span class="ot">=</span> M.farm21 mulScale taperingCf phaseShiftCf</span>
<span id="cb29-35"><a href="#cb29-35"></a>  <span class="kw">where</span></span>
<span id="cb29-36"><a href="#cb29-36"></a>    <span class="co">-- all coefficients are normalized, i.e. scaled with 1/nA&#39; </span></span>
<span id="cb29-37"><a href="#cb29-37"></a>    mulScale x y   <span class="ot">=</span> x <span class="op">*</span> y <span class="op">/</span> nA&#39;</span>
<span id="cb29-38"><a href="#cb29-38"></a>    <span class="co">-- tapering coefficients, c_k in Eq. (4)</span></span>
<span id="cb29-39"><a href="#cb29-39"></a>    taperingCf     <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.fanoutn</a> nB) taylorCf</span>
<span id="cb29-40"><a href="#cb29-40"></a>    <span class="co">-- phase shift coefficients, e^(j*phi_kl) in Eqs.(4) and (5)</span></span>
<span id="cb29-41"><a href="#cb29-41"></a>    phaseShiftCf   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> (\k <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> (mkCf k) thetas) antennaIxs</span>
<span id="cb29-42"><a href="#cb29-42"></a>    mkCf k theta_l <span class="ot">=</span> cis <span class="op">$</span> (k <span class="op">-</span> <span class="fl">9.5</span>) <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> d <span class="op">*</span> <span class="fu">sin</span> theta_l <span class="op">/</span> lambda</span>
<span id="cb29-43"><a href="#cb29-43"></a>    <span class="co">--------------</span></span>
<span id="cb29-44"><a href="#cb29-44"></a>    <span class="co">-- Taylor series: nA real numbers; 4 nearly constant adjacent side lobes;</span></span>
<span id="cb29-45"><a href="#cb29-45"></a>    <span class="co">-- peak sidelobe level of -30dB</span></span>
<span id="cb29-46"><a href="#cb29-46"></a>    taylorCf <span class="ot">=</span> taylor nA <span class="dv">4</span> (<span class="op">-</span><span class="dv">30</span>)</span>
<span id="cb29-47"><a href="#cb29-47"></a>    <span class="co">-- theta_l spanning nB angles from 0 to pi</span></span>
<span id="cb29-48"><a href="#cb29-48"></a>    thetas   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> (\t <span class="ot">-&gt;</span> <span class="fu">pi</span><span class="op">/</span><span class="dv">3</span> <span class="op">+</span> t <span class="op">*</span> (<span class="fu">pi</span> <span class="op">-</span> <span class="dv">2</span><span class="op">*</span><span class="fu">pi</span><span class="op">/</span><span class="dv">3</span>)<span class="op">/</span>(nB&#39;<span class="op">-</span><span class="dv">1</span>)) beamIxs</span>
<span id="cb29-49"><a href="#cb29-49"></a>    <span class="co">--------------</span></span>
<span id="cb29-50"><a href="#cb29-50"></a>    nA&#39;       <span class="ot">=</span> <span class="fu">fromIntegral</span> nA</span>
<span id="cb29-51"><a href="#cb29-51"></a>    nB&#39;       <span class="ot">=</span> <span class="fu">fromIntegral</span> nB</span>
<span id="cb29-52"><a href="#cb29-52"></a>    antennaIxs <span class="ot">=</span> vector <span class="op">$</span> <span class="fu">map</span> <span class="fu">realToFrac</span> [<span class="dv">0</span><span class="op">..</span>nA<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb29-53"><a href="#cb29-53"></a>    beamIxs    <span class="ot">=</span> vector <span class="op">$</span> <span class="fu">map</span> <span class="fu">realToFrac</span> [<span class="dv">0</span><span class="op">..</span>nB<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<div class="sourceCode" id="cb30" data-startFrom="55"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 54;"><span id="cb30-55"><a href="#cb30-55"></a><span class="co">-- Can be used without importing the <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom.html">ForSyDe.Atom</a> libraries.</span></span>
<span id="cb30-56"><a href="#cb30-56"></a><span class="ot">mkBeamConsts&#39; ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a<span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Complex</span> a]]</span>
<span id="cb30-57"><a href="#cb30-57"></a>mkBeamConsts&#39; d l nA nB <span class="ot">=</span> <span class="fu">map</span> fromVector <span class="op">$</span> fromVector <span class="op">$</span> mkBeamConsts d l nA nB</span></code></pre></div>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 51%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>farm11</code>,<code>farm21</code>, <code>fanout</code>, (<code>from</code>-)<code>vector</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>taylor</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><code>ForSyDe.Atom.Skel.FastVector.DSP</code></a></td>
<td>forsyde-atom</td>
</tr>
</tbody>
</table>
<p>The <code>mkPcCoefs</code> generator for the FIR filter in section <a href="#sec:pc-atom">6.1.2.2</a> is simply a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-tap Hanning window. It can be changed according to the user requirements. All coefficients are scaled with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">1/n</annotation></semantics></math> so that the output does not overflow a possible fixed point representation.</p>
<div class="sourceCode" id="cb31" data-startFrom="71"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 70;"><span id="cb31-71"><a href="#cb31-71"></a><span class="ot">mkPcCoefs ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</span>
<span id="cb31-72"><a href="#cb31-72"></a>mkPcCoefs n <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> (\a <span class="ot">-&gt;</span> <span class="fu">realToFrac</span> a <span class="op">/</span> <span class="fu">realToFrac</span> n) <span class="op">$</span> hanning n</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>hanning</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><code>ForSyDe.Atom.Skel.FastVector.DSP</code></a></td>
<td>forsyde-atom</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb32" data-startFrom="78"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 77;"><span id="cb32-78"><a href="#cb32-78"></a></span>
<span id="cb32-79"><a href="#cb32-79"></a><span class="co">-- Can be used without importing the <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom.html">ForSyDe.Atom</a> libraries.</span></span>
<span id="cb32-80"><a href="#cb32-80"></a><span class="ot">mkPcCoefs&#39; ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a]</span>
<span id="cb32-81"><a href="#cb32-81"></a>mkPcCoefs&#39; n <span class="ot">=</span> fromVector <span class="op">$</span> mkPcCoefs n</span></code></pre></div>
<p>We use also a Hanning window to generate the complex weight coefficients for decreasing the Doppler side lobes during DFB in section <a href="#sec:cube-dfb-atom">2.2.2.4</a>. This can be changed according to the user requirements.</p>
<div class="sourceCode" id="cb33" data-startFrom="87"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 86;"><span id="cb33-87"><a href="#cb33-87"></a><span class="ot">mkWeightCoefs ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</span>
<span id="cb33-88"><a href="#cb33-88"></a>mkWeightCoefs nFFT <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> <span class="fu">realToFrac</span> <span class="op">$</span> hanning nFFT</span></code></pre></div>
<div class="sourceCode" id="cb34" data-startFrom="90"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 89;"><span id="cb34-90"><a href="#cb34-90"></a><span class="co">-- Can be used without importing the <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom.html">ForSyDe.Atom</a> libraries.</span></span>
<span id="cb34-91"><a href="#cb34-91"></a><span class="ot">mkWeightCoefs&#39; ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a]</span>
<span id="cb34-92"><a href="#cb34-92"></a>mkWeightCoefs&#39; nFFT <span class="ot">=</span> fromVector <span class="op">$</span> mkWeightCoefs nFFT</span></code></pre></div>
<p>For the integrator FIR in section <a href="#sec:int-atom">6.1.2.5</a> we use a normalized square window.</p>
<div class="sourceCode" id="cb35" data-startFrom="96"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 95;"><span id="cb35-96"><a href="#cb35-96"></a><span class="ot">mkIntCoefs ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Vector</span> a</span>
<span id="cb35-97"><a href="#cb35-97"></a>mkIntCoefs <span class="ot">=</span> vector mkIntCoefs&#39;</span></code></pre></div>
<div class="sourceCode" id="cb36" data-startFrom="99"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 98;"><span id="cb36-99"><a href="#cb36-99"></a><span class="co">-- Can be used without importing the <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom.html">ForSyDe.Atom</a> libraries.</span></span>
<span id="cb36-100"><a href="#cb36-100"></a><span class="ot">mkIntCoefs&#39; ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> [a]</span>
<span id="cb36-101"><a href="#cb36-101"></a>mkIntCoefs&#39; <span class="ot">=</span> [<span class="dv">1</span><span class="op">/</span><span class="dv">8</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">8</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">8</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">8</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">8</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">8</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">8</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">8</span>] </span></code></pre></div>
<div class="sourceCode" id="cb37" data-startFrom="103"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 102;"><span id="cb37-103"><a href="#cb37-103"></a><span class="co">-- The maximum floating point number representable in Haskell. </span></span>
<span id="cb37-104"><a href="#cb37-104"></a><span class="ot">maxFloat ::</span> <span class="dt">Float</span></span>
<span id="cb37-105"><a href="#cb37-105"></a>maxFloat <span class="ot">=</span> x <span class="op">/</span> <span class="dv">256</span></span>
<span id="cb37-106"><a href="#cb37-106"></a> <span class="kw">where</span> n <span class="ot">=</span> <span class="fu">floatDigits</span> x</span>
<span id="cb37-107"><a href="#cb37-107"></a>       b <span class="ot">=</span> <span class="fu">floatRadix</span> x</span>
<span id="cb37-108"><a href="#cb37-108"></a>       (_, u) <span class="ot">=</span> <span class="fu">floatRange</span> x</span>
<span id="cb37-109"><a href="#cb37-109"></a>       x <span class="ot">=</span> <span class="fu">encodeFloat</span> (b<span class="op">^</span>n <span class="op">-</span> <span class="dv">1</span>) (u <span class="op">-</span> n)</span></code></pre></div>
<h2 data-number="2.3" id="sec:cube-atom-sim"><span class="header-section-number">2.3</span> Model Simulation Against Test Data</h2>
<p>As a first trial to validate that our AESA high-level model is “sane”, i.e. is modeling the expected behavior, we test it against realistic input data from an array of antennas detecting some <em>known</em> objects. For this we have provided a set of data generator and plotter scripts, along with an executable binary created with the <code>CubesAtom</code> module presented in section <a href="#sec:cube-atom-operation">2.2</a>. Please read the project’s <code>README</code> file on how to compile and run the necessary software tools.</p>
<p>The input data generator script replicates a situation in which 13 distinct objects, either near each other or far apart, as seen in tbl. <a href="#tbl:in-objects">2</a>, are detected drowned into -18dB worth of noise by the 16 AESA antenna elements (see section <a href="#sec:aesa-parameters">2.2.AESA parameters</a>). In in Figure <a href="#fig:aesa-indata">17 (a)</a> can be seen a plot with the absolute values of the complex samples in the first video indata cube, comprising of 16 antenna (pulse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>×</mo><annotation encoding="application/x-tex">\times</annotation></semantics></math> range) matrices.</p>
<p>In Figure <a href="#fig:aesa-odata-atom">17 (b)</a> a cube consisting of 8 beam (Doppler <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>×</mo><annotation encoding="application/x-tex">\times</annotation></semantics></math> range) matrices from the AESA signal processing output is shown. We can see the 13 objects detected with different intensities across the 8 beams. As they are all positioned at approximately the same angle relative to the antenna (i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math>) we can see the maximum correlation values are reflected in beam 2.</p>
<div id="tbl:in-objects">
<table>
<caption>Table 2: Objects reflected in the generated AESA indata</caption>
<thead>
<tr class="header">
<th style="text-align: right;">#</th>
<th style="text-align: right;">Distance (m)</th>
<th style="text-align: center;">Angle (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>)</th>
<th style="text-align: right;">Rel. Speed (m/s)</th>
<th style="text-align: right;">Rel. Power</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">12e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">0.94</td>
<td style="text-align: right;">-6</td>
</tr>
<tr class="even">
<td style="text-align: right;">2</td>
<td style="text-align: right;">13e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">5 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-6</td>
</tr>
<tr class="odd">
<td style="text-align: right;">3</td>
<td style="text-align: right;">14e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">10 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-6</td>
</tr>
<tr class="even">
<td style="text-align: right;">4</td>
<td style="text-align: right;">15e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">-0.94</td>
<td style="text-align: right;">-2</td>
</tr>
<tr class="odd">
<td style="text-align: right;">5</td>
<td style="text-align: right;">16e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">-2 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-2</td>
</tr>
<tr class="even">
<td style="text-align: right;">6</td>
<td style="text-align: right;">17e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">-3 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-2</td>
</tr>
<tr class="odd">
<td style="text-align: right;">7</td>
<td style="text-align: right;">18e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">-20 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-4</td>
</tr>
<tr class="even">
<td style="text-align: right;">8</td>
<td style="text-align: right;">19e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">-23 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-4</td>
</tr>
<tr class="odd">
<td style="text-align: right;">9</td>
<td style="text-align: right;">20e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">-26 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-4</td>
</tr>
<tr class="even">
<td style="text-align: right;">10</td>
<td style="text-align: right;">21e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">-29 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-4</td>
</tr>
<tr class="odd">
<td style="text-align: right;">11</td>
<td style="text-align: right;">25e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">-15 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-2</td>
</tr>
<tr class="even">
<td style="text-align: right;">12</td>
<td style="text-align: right;">25.4e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2.1</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2.1(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">-15 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-4</td>
</tr>
<tr class="odd">
<td style="text-align: right;">13</td>
<td style="text-align: right;">25.2e3</td>
<td style="text-align: center;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac><mo>+</mo><mn>2.2</mn><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo>−</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mn>3</mn></mfrac><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">\frac{\pi}{3} + 2.2(\pi-\frac{2\pi}{3})/7</annotation></semantics></math></td>
<td style="text-align: right;">-15 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⋅</mo><annotation encoding="application/x-tex">\cdot</annotation></semantics></math> 0.94</td>
<td style="text-align: right;">-3</td>
</tr>
</tbody>
</table>
</div>
<div id="fig:figureRef" class="subfigures subfigures">
<figure>
<img src="figs/AESA_INPUT_C.png" id="fig:aesa-indata" alt="" /><figcaption>a</figcaption>
</figure>
<figure>
<img src="figs/AESA_OUT_C.png" id="fig:aesa-odata-atom" alt="" /><figcaption>b</figcaption>
</figure>
<p>Figure 17: AESA data plots. a — Absolute values for one input video cube with antenna data, b — One output cube with radar data</p>
</div>
<h2 data-number="2.4" id="conclusion"><span class="header-section-number">2.4</span> Conclusion</h2>
<p>In this section we have shown how to write a fully-functional high-level model of an AESA radar signal processing chain in ForSyDe-Atom. In the process we have exemplified basic modeling concepts such as <em>layers</em>, <em>process constructors</em> and <em>skeletons</em>. For simplicity we have employed only two widely-used layers, representing time (through the MoC layer) and parallelism (through the Skeleton layer) aspects in a system. Within the MoC layer we used only the SY MoC capturing the passage of data (structures) in a synchronous pipeline fashion. Within the Skeleton layer we used algorithmic skeletons on vector data types to capture the inherent parallel interaction between elements, mainly to build algorithms on cubes. As of Figure <a href="#fig:atom-layers">3</a> from section <a href="#sec:crash-atom">2.1</a>, this layer setup is represented by right picture (processes of skeleton functions). However in section <a href="#sec:cube-int-atom">2.2.2.6</a> we have given “an appetizer” on how to instantiate regular, parameterizable process network structures using the <em>same</em> skeletons, thanks to the concept of layers.</p>
<p>In section <a href="#sec:refine">6</a> we transform this model to capture some more refined notions of time and data passage, as well as more complex use of skeletons and patterns, gradually reaching enough system details to start considering the synthesis of the model in section <a href="#sec:synth">7</a> to a hardware platform. Until then we will introduce an alternative modeling framework, as well as practical tools to verify the conformance of the ForSyDe model and all its subsequent refinements to the given specification.</p>
<h1 data-number="3" id="sec:shallow"><span class="header-section-number">3</span> Alternative Modeling Framework: ForSyDe-Shallow</h1>
<blockquote>
<p><em>This section follows step-by-step the same approach as section <a href="#sec:atom">2</a>, but this time using the ForSyDe-Shallow modeling framework. The purpose is to familiarize the reader to the syntax of ForSyDe-Shallow should the designer prefer it instead of ForSyDe-Atom. This section is also meant to show that, except for minor syntactic differences, the same modeling concepts are holding and the user experience and API design are very similar.</em></p>
</blockquote>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 31%" />
<col style="width: 62%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Package</td>
<td>aesa-shallow-0.1.0</td>
<td>path: <code>./aesa-shallow/README.md</code></td>
</tr>
<tr class="even">
<td>Deps</td>
<td>forsyde-shallow-0.2.2</td>
<td>url:<code>http://hackage.haskell.org/package/forsyde-shallow</code></td>
</tr>
<tr class="odd">
<td></td>
<td>forsyde-shallow-extensions-0.1.1</td>
<td>path: <code>./forsyde-shallow-extensions/README.md</code></td>
</tr>
<tr class="even">
<td></td>
<td>aesa-atom-0.1.1</td>
<td>path: <code>./aesa-atom/README.md</code></td>
</tr>
<tr class="odd">
<td>Bin</td>
<td>aesa-shallow</td>
<td>usage: <code>aesa-shallow --help</code></td>
</tr>
</tbody>
</table>
<p><a href="https://forsyde.github.io/forsyde-shallow/">ForSyDe-Shallow</a> is the flagship and the oldest modeling language of the ForSyDe methodology <span class="citation" data-cites="sander-2004">(Sander and Jantsch <a href="#ref-sander-2004" role="doc-biblioref">2004</a>)</span>. It is a domain specific language (DSL) shallow-embedded into the functional programming language Haskell and uses the host’s type system, lazy evaluation mechanisms and the concept of higher-order functions to describe the formal modeling framework defined by ForSyDe. At the moment of writing this report, ForSyDe-Shallow is the more “mature” counterpart of ForSyDe-Atom. Although some practical modeling concepts such as <em>layers</em>, <em>patterns</em> and <em>skeletons</em> have been originally developed within ForSyDe-Atom, they are now well-supported by ForSyDe-Shallow as well. In the future the modeling frameworks such as ForSyDe-Atom and ForSyDe-Shallow are planned to be merged into a single one incorporating the main language features of each one and having a similar user experience as ForSyDe-Shallow.</p>
<h2 data-number="3.1" id="sec:cube-shallow-operation"><span class="header-section-number">3.1</span> The High-Level Model</h2>
<p>The behavioral model of this section is exactly the same as the one presented in in section <a href="#sec:cube-atom-operation">2.2</a>, and thus we will not go through all the details of each functional block, but rather list the code and point out the syntax differences.</p>
<p>The code for this section is written in the following module, see section <a href="#sec:usage">1.2</a> on how to use it:</p>
<div class="sourceCode" id="cb38" data-startFrom="10"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 9;"><span id="cb38-10"><a href="#cb38-10"></a><span class="ot">{-# LANGUAGE PackageImports #-}</span>   <span class="co">-- you can ignore this line for now</span></span></code></pre></div>
<p>The code for this section is written in the following module, see section <a href="#sec:usage">1.2</a> on how to use it:</p>
<div class="sourceCode" id="cb39" data-startFrom="15"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 14;"><span id="cb39-15"><a href="#cb39-15"></a><span class="kw">module</span> <span class="dt">AESA.CubesShallow</span> <span class="kw">where</span></span></code></pre></div>
<h3 data-number="3.1.1" id="imported-libraries"><span class="header-section-number">3.1.1</span> Imported Libraries</h3>
<p>The first main difference between ForSyDe-Shallow and ForSyDe-Atom becomes apparent when importing the libraries: ForSyDe-Shallow does not require to import as many sub-modules as its younger counterpart. This is because the main library <a href="http://hackage.haskell.org/package/forsyde-shallow"><code>ForSyDe.Shallow</code></a> exports all the main language constructs, except for specialized utility blocks, so the user does not need to know where each function is placed.</p>
<div class="sourceCode" id="cb40" data-startFrom="26"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 25;"><span id="cb40-26"><a href="#cb40-26"></a><span class="kw">import</span> <span class="dt">ForSyDe.Shallow</span></span></code></pre></div>
<p>For the AESA model we make use of such utilities, such as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-dimensional vectors (i.e. matrices, cubes) and DSP blocks, thus we import our local extended <a href="http://hackage.haskell.org/package/forsyde-shallow-3.4.0.0/docs/ForSyDe-Shallow-Utility.html"><code>ForSyDe.Shallow.Utilities</code></a> library.</p>
<div class="sourceCode" id="cb41" data-startFrom="33"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 32;"><span id="cb41-33"><a href="#cb41-33"></a><span class="co">-- | explicit import from extensions package. Will be imported</span></span>
<span id="cb41-34"><a href="#cb41-34"></a><span class="co">-- normally once the extensions are merged into forsyde-shallow</span></span>
<span id="cb41-35"><a href="#cb41-35"></a><span class="kw">import</span> &quot;forsyde-shallow-extensions&quot; <span class="dt">ForSyDe.Shallow.Core.Vector</span></span>
<span id="cb41-36"><a href="#cb41-36"></a><span class="kw">import</span> &quot;forsyde-shallow-extensions&quot; <span class="dt">ForSyDe.Shallow.Utility</span></span></code></pre></div>
<p>Finally, we import Haskell’s <a href="http://hackage.haskell.org/package/base/docs/Data-Complex.html"><code>Complex</code></a> type, to represent complex numbers.</p>
<div class="sourceCode" id="cb42" data-startFrom="42"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 41;"><span id="cb42-42"><a href="#cb42-42"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span></code></pre></div>
<p>To keep the model consistent with the design in section <a href="#sec:cube-atom-operation">2.2</a> we import the <em>same</em> parameters and coefficient generator functions from the <code>aesa-atom</code> package, as presented in sections <a href="#sec:aesa-parameters">2.2.AESA parameters</a>, <a href="#sec:coefs-atom">2.2.Coefficients</a>.</p>
<div class="sourceCode" id="cb43" data-startFrom="48"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 47;"><span id="cb43-48"><a href="#cb43-48"></a><span class="kw">import</span> <span class="dt">AESA.Params</span></span>
<span id="cb43-49"><a href="#cb43-49"></a><span class="kw">import</span> <span class="dt">AESA.CoefsShallow</span>  <span class="co">-- wraps the list functions exported by &#39;AESA.Coefs&#39; into</span></span>
<span id="cb43-50"><a href="#cb43-50"></a>                          <span class="co">-- &#39;ForSyDe.Shallow&#39; data types.</span></span></code></pre></div>
<h3 data-number="3.1.2" id="sec:aliases-shallow"><span class="header-section-number">3.1.2</span> Type Synonyms</h3>
<p>We use the same (local) aliases for types representing the different data structure and dimensions.</p>
<div class="sourceCode" id="cb44" data-startFrom="57"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 56;"><span id="cb44-57"><a href="#cb44-57"></a><span class="kw">type</span> <span class="dt">Antenna</span>     <span class="ot">=</span> <span class="dt">Vector</span>       <span class="co">-- length: nA</span></span>
<span id="cb44-58"><a href="#cb44-58"></a><span class="kw">type</span> <span class="dt">Beam</span>        <span class="ot">=</span> <span class="dt">Vector</span>       <span class="co">-- length: nB</span></span>
<span id="cb44-59"><a href="#cb44-59"></a><span class="kw">type</span> <span class="dt">Range</span>       <span class="ot">=</span> <span class="dt">Vector</span>       <span class="co">-- length: nb</span></span>
<span id="cb44-60"><a href="#cb44-60"></a><span class="kw">type</span> <span class="dt">Window</span>      <span class="ot">=</span> <span class="dt">Vector</span>       <span class="co">-- length: nFFT</span></span>
<span id="cb44-61"><a href="#cb44-61"></a><span class="kw">type</span> <span class="dt">CpxData</span>     <span class="ot">=</span> <span class="dt">Complex</span> <span class="dt">Float</span></span>
<span id="cb44-62"><a href="#cb44-62"></a><span class="kw">type</span> <span class="dt">RealData</span>    <span class="ot">=</span> <span class="dt">Float</span></span></code></pre></div>
<h3 data-number="3.1.3" id="video-processing-pipeline-stages"><span class="header-section-number">3.1.3</span> Video Processing Pipeline Stages</h3>
<p>This section follows the same model as section <a href="#sec:cube-atom-pipe-stages">2.2.2</a> using the ForSyDe-Shallow modeling libraries. The digital beamforming (DBF) block presented in section <a href="#sec:cube-dbf-atom">2.2.2.1</a> becomes:</p>
<div class="sourceCode" id="cb45" data-startFrom="70"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 69;"><span id="cb45-70"><a href="#cb45-70"></a><span class="ot">dbf ::</span> <span class="dt">Signal</span> (<span class="dt">Antenna</span> (<span class="dt">Window</span> (<span class="dt">Range</span> <span class="dt">CpxData</span>)))</span>
<span id="cb45-71"><a href="#cb45-71"></a>    <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Window</span>  (<span class="dt">Range</span>  (<span class="dt">Beam</span>  <span class="dt">CpxData</span>)))</span>
<span id="cb45-72"><a href="#cb45-72"></a>dbf <span class="ot">=</span> combSY (mapMat fDBF <span class="op">.</span> transposeCube)</span>
<span id="cb45-73"><a href="#cb45-73"></a></span>
<span id="cb45-74"><a href="#cb45-74"></a><span class="ot">fDBF ::</span> <span class="dt">Antenna</span> <span class="dt">CpxData</span> <span class="co">-- ^ input antenna elements</span></span>
<span id="cb45-75"><a href="#cb45-75"></a>     <span class="ot">-&gt;</span> <span class="dt">Beam</span>    <span class="dt">CpxData</span> <span class="co">-- ^ output beams</span></span>
<span id="cb45-76"><a href="#cb45-76"></a>fDBF antennas  <span class="ot">=</span> beams</span>
<span id="cb45-77"><a href="#cb45-77"></a>  <span class="kw">where</span></span>
<span id="cb45-78"><a href="#cb45-78"></a>    beams      <span class="ot">=</span> reduceV (zipWithV (<span class="op">+</span>)) beamMatrix</span>
<span id="cb45-79"><a href="#cb45-79"></a>    beamMatrix <span class="ot">=</span> zipWithMat (<span class="op">*</span>) elMatrix beamConsts</span>
<span id="cb45-80"><a href="#cb45-80"></a>    elMatrix   <span class="ot">=</span> mapV (copyV nB) antennas</span>
<span id="cb45-81"><a href="#cb45-81"></a>    beamConsts <span class="ot">=</span> mkBeamConsts dElements waveLength nA nB</span></code></pre></div>
<p>The second main difference between the syntax of ForSyDe-Shallow and ForSyDe-Atom can be noticed when using the library functions, such as process constructors: function names are not invoked with their module name (alias), but rather with a suffix denoting the type they operate on, e.g. <code>transposeCube</code> is the equivalent of <code>C.transpose</code>. Another difference is that constructors with different numbers of inputs and outputs are not differentiated by a two-number suffix, but rather by canonical name, e.g. <code>combSY</code> is the equivalent of <code>SY.comb11</code>. Lastly, you might notice that some function names are completely different. That is because ForSyDe-Shallow uses names inspired from functional programming, mainly associated with operations on lists, whereas ForSyDe-Atom tries to adopt more suggestive names with respect to the layer of each design component and its associated jargon, e.g. <code>mapMat</code> is the equivalent of <code>M.farm11</code>, or <code>zipWithV</code> is equivalent with <code>V.farm21</code>.</p>
<p>We go further with the description of the pulse compression (PC) block, as described previously in section <a href="#sec:cube-dbf-atom">2.2.2.1</a> becomes. The same variation in naming convention can be noticed, but the syntax is still the same.</p>
<div class="sourceCode" id="cb46" data-startFrom="101"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 100;"><span id="cb46-101"><a href="#cb46-101"></a><span class="ot">pc ::</span> <span class="dt">Signal</span> (<span class="dt">Window</span> (<span class="dt">Range</span> (<span class="dt">Beam</span>  <span class="dt">CpxData</span>))) </span>
<span id="cb46-102"><a href="#cb46-102"></a>   <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Window</span> (<span class="dt">Beam</span>  (<span class="dt">Range</span> <span class="dt">CpxData</span>)))</span>
<span id="cb46-103"><a href="#cb46-103"></a>pc <span class="ot">=</span> combSY (mapV (mapV fPC <span class="op">.</span> transposeMat))</span>
<span id="cb46-104"><a href="#cb46-104"></a></span>
<span id="cb46-105"><a href="#cb46-105"></a><span class="ot">fPC ::</span> <span class="dt">Range</span> <span class="dt">CpxData</span> <span class="co">-- ^ input range bin     </span></span>
<span id="cb46-106"><a href="#cb46-106"></a>    <span class="ot">-&gt;</span> <span class="dt">Range</span> <span class="dt">CpxData</span> <span class="co">-- ^ output pulse-compressed bin</span></span>
<span id="cb46-107"><a href="#cb46-107"></a>fPC <span class="ot">=</span> mav (mkPcCoefs <span class="dv">5</span>)</span></code></pre></div>
<p>The same goes for <code>overlap</code> state machine use in the corner turn (CT) stage, as well as the Doppler filter bank (DFB) and the constant false alarm ratio (CFAR) stages from sections <a href="#sec:cube-ct-atom">2.2.2.3</a>-<a href="#sec:cube-cfar-atom">2.2.2.5</a> respectively.</p>
<div class="sourceCode" id="cb47" data-startFrom="113"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 112;"><span id="cb47-113"><a href="#cb47-113"></a><span class="ot">overlap ::</span> <span class="dt">Signal</span> (<span class="dt">Window</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> <span class="dt">CpxData</span>)))</span>
<span id="cb47-114"><a href="#cb47-114"></a>        <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Window</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> <span class="dt">CpxData</span>)))</span>
<span id="cb47-115"><a href="#cb47-115"></a>overlap <span class="ot">=</span> mealySY nextState outDecode initState</span>
<span id="cb47-116"><a href="#cb47-116"></a>  <span class="kw">where</span></span>
<span id="cb47-117"><a href="#cb47-117"></a>    nextState _ cube <span class="ot">=</span> dropV (nFFT <span class="ot">`div`</span> <span class="dv">2</span>) cube</span>
<span id="cb47-118"><a href="#cb47-118"></a>    outDecode s cube <span class="ot">=</span> s <span class="op">&lt;+&gt;</span> takeV (nFFT <span class="ot">`div`</span> <span class="dv">2</span>) cube</span>
<span id="cb47-119"><a href="#cb47-119"></a>    initState        <span class="ot">=</span>  copyCube nb nB (nFFT <span class="ot">`div`</span> <span class="dv">2</span>) <span class="dv">0</span> </span></code></pre></div>
<!-- -- (copyV (nFFT `div` 2) . copyV nB . copyV ) 0 -->
<div class="sourceCode" id="cb48" data-startFrom="123"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 122;"><span id="cb48-123"><a href="#cb48-123"></a><span class="ot">dfb ::</span> <span class="dt">Signal</span> (<span class="dt">Window</span> (<span class="dt">Beam</span>  (<span class="dt">Range</span>  <span class="dt">CpxData</span> )))</span>
<span id="cb48-124"><a href="#cb48-124"></a>    <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Beam</span>   (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb48-125"><a href="#cb48-125"></a>dfb <span class="ot">=</span> combSY (mapMat fDFB <span class="op">.</span> transposeCube)</span>
<span id="cb48-126"><a href="#cb48-126"></a></span>
<span id="cb48-127"><a href="#cb48-127"></a><span class="ot">fDFB ::</span> <span class="dt">Window</span> <span class="dt">CpxData</span> <span class="ot">-&gt;</span> <span class="dt">Window</span> <span class="dt">RealData</span></span>
<span id="cb48-128"><a href="#cb48-128"></a>fDFB <span class="ot">=</span> mapV envelope <span class="op">.</span> onComplexFloat (fft nFFT) <span class="op">.</span> weight</span>
<span id="cb48-129"><a href="#cb48-129"></a>  <span class="kw">where</span></span>
<span id="cb48-130"><a href="#cb48-130"></a>    weight     <span class="ot">=</span> zipWithV (<span class="op">*</span>) (mkWeightCoefs nFFT)</span>
<span id="cb48-131"><a href="#cb48-131"></a>    envelope a <span class="ot">=</span> <span class="kw">let</span> (i, q) <span class="ot">=</span> (realPart a, imagPart a)</span>
<span id="cb48-132"><a href="#cb48-132"></a>                 <span class="kw">in</span> <span class="fu">realToFrac</span> <span class="op">$</span> <span class="fu">sqrt</span> (i <span class="op">*</span> i <span class="op">+</span> q <span class="op">*</span> q)</span>
<span id="cb48-133"><a href="#cb48-133"></a>    onComplexFloat f <span class="ot">=</span> mapV (<span class="fu">fmap</span> <span class="fu">realToFrac</span>) <span class="op">.</span> f <span class="op">.</span> mapV (<span class="fu">fmap</span> <span class="fu">realToFrac</span>)</span></code></pre></div>
<p>The <code>fft</code> function from ForSyDe-Shallow is provided as a <em>monomorphic</em> utility function, and not necessarily as a skeleton. This is why, although slightly more efficient, it is not as flexible as the skeleton counterpart, and thus we need to wrap it inside our custom data type converter <code>onComplexFloat</code> to be able to “plug it” into our system, i.e. there are no data type mismatches.</p>
<div class="sourceCode" id="cb49" data-startFrom="141"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 140;"><span id="cb49-141"><a href="#cb49-141"></a><span class="ot">cfar ::</span> <span class="dt">Signal</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb49-142"><a href="#cb49-142"></a>     <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb49-143"><a href="#cb49-143"></a>cfar <span class="ot">=</span> combSY (mapV fCFAR)</span>
<span id="cb49-144"><a href="#cb49-144"></a></span>
<span id="cb49-145"><a href="#cb49-145"></a><span class="ot">fCFAR ::</span> <span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>) <span class="ot">-&gt;</span> <span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)</span>
<span id="cb49-146"><a href="#cb49-146"></a>fCFAR rbins <span class="ot">=</span> zipWith4V (\m <span class="ot">-&gt;</span> zipWith3V (normCfa m)) md rbins lmv emv</span>
<span id="cb49-147"><a href="#cb49-147"></a>  <span class="kw">where</span></span>
<span id="cb49-148"><a href="#cb49-148"></a>    md  <span class="ot">=</span> mapV (<span class="fu">logBase</span> <span class="dv">2</span> <span class="op">.</span> reduceV <span class="fu">min</span>) rbins</span>
<span id="cb49-149"><a href="#cb49-149"></a>    emv <span class="ot">=</span> (copyV (nFFT <span class="op">+</span> <span class="dv">1</span>) dummy) <span class="op">&lt;+&gt;</span> (mapV aritMean neighbors)</span>
<span id="cb49-150"><a href="#cb49-150"></a>    lmv <span class="ot">=</span> (dropV <span class="dv">2</span> <span class="op">$</span> mapV aritMean neighbors) <span class="op">&lt;+&gt;</span> (copyV (nFFT<span class="op">*</span><span class="dv">2</span>) dummy) </span>
<span id="cb49-151"><a href="#cb49-151"></a>    <span class="co">-----------------------------------------------</span></span>
<span id="cb49-152"><a href="#cb49-152"></a>    normCfa m a l e <span class="ot">=</span> <span class="dv">2</span> <span class="op">**</span> (<span class="dv">5</span> <span class="op">+</span> <span class="fu">logBase</span> <span class="dv">2</span> a <span class="op">-</span> <span class="fu">maximum</span> [l,e,m])</span>
<span id="cb49-153"><a href="#cb49-153"></a>    aritMean  <span class="ot">=</span> mapV (<span class="op">/</span>n) <span class="op">.</span> reduceV addV <span class="op">.</span> mapV geomMean <span class="op">.</span> groupV <span class="dv">4</span></span>
<span id="cb49-154"><a href="#cb49-154"></a>    geomMean  <span class="ot">=</span> mapV (<span class="fu">logBase</span> <span class="dv">2</span> <span class="op">.</span> (<span class="op">/</span><span class="dv">4</span>)) <span class="op">.</span> reduceV addV</span>
<span id="cb49-155"><a href="#cb49-155"></a>    <span class="co">-----------------------------------------------</span></span>
<span id="cb49-156"><a href="#cb49-156"></a>    dummy     <span class="ot">=</span> copyV nFFT (<span class="op">-</span>maxFloat)</span>
<span id="cb49-157"><a href="#cb49-157"></a>    neighbors <span class="ot">=</span> stencilV nFFT rbins</span>
<span id="cb49-158"><a href="#cb49-158"></a>    <span class="co">-----------------------------------------------</span></span>
<span id="cb49-159"><a href="#cb49-159"></a>    addV      <span class="ot">=</span> zipWithV (<span class="op">+</span>)</span>
<span id="cb49-160"><a href="#cb49-160"></a>    n         <span class="ot">=</span> <span class="fu">fromIntegral</span> nFFT</span></code></pre></div>
<p>For the integration stage (INT) presented in section <a href="#sec:cube-ct-atom">2.2.2.3</a> we extended the <code>ForSyDe.Shallow.Utility</code> library with a <code>fir'</code> skeleton and an <code>interleaveSY</code> process, similar to the ones developed for ForSyDe-Atom<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. Thus we can implement this stage exactly as before:</p>
<div class="sourceCode" id="cb50" data-startFrom="167"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 166;"><span id="cb50-167"><a href="#cb50-167"></a><span class="ot">int ::</span> <span class="dt">Signal</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb50-168"><a href="#cb50-168"></a>    <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb50-169"><a href="#cb50-169"></a>    <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Beam</span> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb50-170"><a href="#cb50-170"></a><span class="co">-- int r l = firNet $ interleaveSY r l</span></span>
<span id="cb50-171"><a href="#cb50-171"></a><span class="co">--   where</span></span>
<span id="cb50-172"><a href="#cb50-172"></a><span class="co">--     firNet = zipCubeSY . mapCube (firSY mkIntCoefs) . unzipCubeSY</span></span>
<span id="cb50-173"><a href="#cb50-173"></a>int r l <span class="ot">=</span> fir&#39; addSC mulSC dlySC mkIntCoefs <span class="op">$</span> interleaveSY r l</span>
<span id="cb50-174"><a href="#cb50-174"></a>  <span class="kw">where</span></span>
<span id="cb50-175"><a href="#cb50-175"></a>    addSC   <span class="ot">=</span> comb2SY (zipWithCube (<span class="op">+</span>))</span>
<span id="cb50-176"><a href="#cb50-176"></a>    mulSC c <span class="ot">=</span> combSY  (mapCube (<span class="op">*</span>c))</span>
<span id="cb50-177"><a href="#cb50-177"></a>    dlySC   <span class="ot">=</span> delaySY (repeatCube <span class="dv">0</span>)</span></code></pre></div>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 39%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mapV</code>, <code>zipWith</code>, <code>zipWith</code>[<code>4</code>/<code>3</code>],</td>
<td><a href="http://hackage.haskell.org/package/forsyde-shallow-3.4.0.0/docs/ForSyDe-Shallow-Core-Vector.html"><code>ForSyDe.Shallow.Core.Vector</code></a></td>
<td>forsyde-shallow</td>
</tr>
<tr class="even">
<td><code>reduceV</code>, <code>lengthV</code>, <code>dropV</code>, <code>takeV</code>,</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>copyV</code>, <code>(&lt;+&gt;)</code>, <code>stencilV</code></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>mapMat</code>, <code>zipWithMat</code>, <code>transposeMat</code></td>
<td><a href="http://hackage.haskell.org/package/forsyde-shallow-3.4.0.0/docs/ForSyDe-Shallow-Utility-Matrix.html"><code>ForSyDe.Shallow.Utility.Matrix</code></a></td>
<td>forsyde-shallow</td>
</tr>
<tr class="odd">
<td><code>transposeCube</code></td>
<td><code>ForSyDe.Shallow.Utility.Cube</code></td>
<td>forsyde-shallow-extensions</td>
</tr>
<tr class="even">
<td><code>fir</code></td>
<td><a href="http://hackage.haskell.org/package/forsyde-shallow-3.4.0.0/docs/ForSyDe-Shallow-Utility-FIR.html"><code>ForSyDe.Shallow.Utility.FIR</code></a></td>
<td>forsyde-shallow</td>
</tr>
<tr class="odd">
<td><code>fft</code></td>
<td><a href="http://hackage.haskell.org/package/forsyde-shallow-3.4.0.0/docs/ForSyDe-Shallow-Utility-DFT.html"><code>ForSyDe.Shallow.Utility.DFT</code></a></td>
<td>forsyde-shallow</td>
</tr>
<tr class="even">
<td><code>mav</code></td>
<td><code>ForSyDe.Shallow.Utility.DSP</code></td>
<td>forsyde-shallow-extensions</td>
</tr>
<tr class="odd">
<td><code>combSY</code>, <code>comb2SY</code>, <code>mealySY</code>, <code>delaySY</code></td>
<td><a href="http://hackage.haskell.org/package/forsyde-shallow-3.4.0.0/docs/ForSyDe-Shallow-MoC-Synchronous.html"><code>ForSyDe.Shallow.MoC.Synchronous</code></a></td>
<td>forsyde-shallow</td>
</tr>
<tr class="even">
<td><code>interleaveSY</code></td>
<td><code>ForSyDe.Shallow.Utility</code></td>
<td>forsyde-shallow-extensions</td>
</tr>
<tr class="odd">
<td><code>mkBeamConsts</code>,<code>mkPcCoefs</code>,</td>
<td><code>AESA.Coefs</code></td>
<td>aesa-atom</td>
</tr>
<tr class="even">
<td><code>mkWeightCoefs</code>, <code>mkFirCoefs</code>, <code>maxFloat</code></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>dElements</code>, <code>waveLength</code>, <code>nA</code>, <code>nB</code></td>
<td><code>AESA.Params</code></td>
<td>aesa-atom</td>
</tr>
<tr class="even">
<td><code>nFFT</code>, <code>nb</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 data-number="3.1.4" id="the-aesa-process-network"><span class="header-section-number">3.1.4</span> The AESA Process Network</h3>
<p>The process network is exactly the same as the one in section <a href="#sec:cube-atom-operation">2.2</a>, but instantiating the locally defined components.</p>
<div class="sourceCode" id="cb51" data-startFrom="203"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 202;"><span id="cb51-203"><a href="#cb51-203"></a><span class="ot">aesa ::</span> <span class="dt">Signal</span> (<span class="dt">Antenna</span> (<span class="dt">Window</span> (<span class="dt">Range</span>  <span class="dt">CpxData</span> )))</span>
<span id="cb51-204"><a href="#cb51-204"></a>     <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Beam</span>    (<span class="dt">Range</span>  (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb51-205"><a href="#cb51-205"></a>aesa video <span class="ot">=</span> int rCfar lCfar</span>
<span id="cb51-206"><a href="#cb51-206"></a>  <span class="kw">where</span></span>
<span id="cb51-207"><a href="#cb51-207"></a>    rCfar <span class="ot">=</span> cfar <span class="op">$</span> dfb oPc</span>
<span id="cb51-208"><a href="#cb51-208"></a>    lCfar <span class="ot">=</span> cfar <span class="op">$</span> dfb <span class="op">$</span> overlap oPc</span>
<span id="cb51-209"><a href="#cb51-209"></a>    oPc   <span class="ot">=</span> pc <span class="op">$</span> dbf video</span></code></pre></div>
<h2 data-number="3.2" id="sec:cube-shallow-sim"><span class="header-section-number">3.2</span> Model Simulation Against Test Data</h2>
<p>Similarly to the ForSyDe-Atom implementation, we have provided a runner to compile the model defined in section <a href="#sec:cube-atom-operation">2.2</a> within the <code>AESA.CubesShallow</code> module into an executable binary, in order to tests that it is sane. The same generator an plotter scripts can be used with this binary, so please read the project’s <code>README</code> file on how to compile and run the necessary software tools.</p>
<p>We use the same generated input data reflecting the 13 objects from tbl. <a href="#tbl:in-objects">2</a>, plotted in Figure <a href="#fig:aesa-indata">17 (a)</a>. This time the AESA radar processing output shows the picture in Figure <a href="#fig:aesa-odata-shallow">18</a>.</p>
<figure>
<img src="figs/AESA_OUT_CS.png" id="fig:aesa-odata-shallow" alt="" /><figcaption>Figure 18: One output cube with radar data</figcaption>
</figure>
<p>Comparing Figure <a href="#fig:aesa-odata-shallow">18</a> with Figure <a href="#fig:aesa-odata-atom">17 (b)</a> one can see that the same objects have been identified, albeit with slightly different correlation values. This is because we use single-precision floating point <code>Float</code> as the base number representation in our model, which are <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">well-known</a> to be very sensitive to slight variations in arithmetic operations, as far as the order of evaluation is concerned. The output data graphs reflect the fact that ForSyDe-Shallow and ForSyDe-Atom have different implementation, but that is the only conclusion that can be drawn from this.</p>
<h2 data-number="3.3" id="conclusion-1"><span class="header-section-number">3.3</span> Conclusion</h2>
<p>In this section we have presented an alternative implementation of the AESA signal processing high-level model in the ForSyDe-Shallow modeling framework. We have deliberately implemented the <em>same</em> model in order to highlight the API differences between ForSyDe-Atom and ForSyDe-Shallow.</p>
<p>The next sections will only use ForSyDe-Atom as the main modeling framework, however users should hopefully have no trouble switching between their modeling library of choice. The insights in the API of ForSyDe-Shallow will also be useful in section <a href="#sec:synth">7</a> when we introduce ForSyDe-Deep, since the latter has similar constructs.</p>
<h1 data-number="4" id="sec:radar"><span class="header-section-number">4</span> Modeling the Radar Environment</h1>
<blockquote>
<p><em>In this section we model the input signals describing the radar environment, containing analog information about reflected objects, respectivey the digital acquisition of those signals. The purpose of this section is to introduce new modeling “tools” in ForSyDe-Atom: the continuous time (CT) MoC for describing signals that evolve continuously in time, and a new layer, the Probability layer, for describing random values which are distributed with a certain probability. This section can be read independently from the rest.</em></p>
</blockquote>
<table>
<tbody>
<tr class="odd">
<td>Package</td>
<td>aesa-atom-0.3.1</td>
<td>path: <code>./aesa-atom/README.md</code></td>
</tr>
<tr class="even">
<td>Deps</td>
<td>forsyde-atom-0.2.2</td>
<td>url: <code>https://forsyde.github.io/forsyde-atom/api/</code></td>
</tr>
<tr class="odd">
<td>Bin</td>
<td>aesa-atom</td>
<td>usage: <code>aesa-atom -g[NUM] -d</code> (see <code>--help</code>)</td>
</tr>
</tbody>
</table>
<p>The Probability layer and the CT MoC are highlights of the functional implementation of ForSyDe-Atom. Both are represented by paradigms which describe dynamics over continuous domains. However computers, being inherently discrete machines, cannot represent continuums, hence any computer-aided modeling attempt is heavily dependent on numerical methods and discrete “interpretations” of continuous domains (e.g. sampled data). In doing so, we are not only forcing to alter the problem, which might by analytical in nature to a numerical one, but might also unknowingly propagate undesired and chaotic behavior given rise by the fundamental incompatibilities of these two representations. The interested reader is strongly advised to read recent work on cyber-physical systems such as <span class="citation" data-cites="lee2016fundamental bourke2013zelus">(Edward A Lee <a href="#ref-lee2016fundamental" role="doc-biblioref">2016</a>; Bourke and Pouzet <a href="#ref-bourke2013zelus" role="doc-biblioref">2013</a>)</span> to understand these phenomenons.</p>
<p>Being computer programs ForSyDe-Atom models are still dependent on numerical representations, however ForSyDe-Atom deals with this by simply abstracting away the continuous domain (e.g. time) as a <em>function argument</em>. Therefore during modeling, any trasformation can be described as a composition of pure functions. The numerical representation of the domain becomes apparent only at the end, when a model is being evaluated, e.g. when a signal is being plotted, in which case the pure function resulted from a chain of transformations is being evaluated for a certain experiment. This principle is depicted in Figure <a href="#fig:lazy-plot">19</a>, and is enforced by the host language’s (i.e.e Haskell’s) lazy evaluation mechanism.</p>
<figure>
<img src="figs/lazy-plot.png" id="fig:lazy-plot" alt="" /><figcaption>Figure 19: The difference between transforming initially sampled data (above) and sampling transformed pure functions during plotting/trancing (below)</figcaption>
</figure>
<p>In ForSyDe-Atom, CT is defined in the MoC layer, and is describing (discrete) timed interactions between continuous sub-signals. Implementation details and example usage are found at <span class="citation" data-cites="ungureanu-2018-bridg">(Ungureanu, Medeiros, and Sander <a href="#ref-ungureanu-2018-bridg" role="doc-biblioref">2018</a>)</span>. In CT signals each event is described by a discrete tag and a function of time: the tags describe a simple algebra of discrete interactions, whereas event interactions themselves are simply function compositions.</p>
<p>In probability theory on the other hand, an observed value is described by a certain distribution (e.g. normal, uniform), which is a <em>function</em> of a random experiment. Similarly to the CT MoC, the Probability layer represents values by their “recipe” to achieve a desired distribution, whereas the algebra defined by this layer is describing the composition of such recipes. When we need to evaluate a system though, e.g. to plot/trace the behavior, we need to feed the transformed recipe with a (pseudo)-random seed in order to obtain an experimental value.</p>
<p>The radar environment model is found in the <code>AESA.Radar</code> module in <code>aesa-atom</code> package. This module is by default bypassed by the AESA signal processing executable, but if invoked manually, it recreates the AESA radar input for the same 13 object reflections seen in Figure <a href="#fig:aesa-indata">17 (a)</a>, and feeds this input to the AESA signal processing chain. The functions generating this data are presented as follows.</p>
<div class="sourceCode" id="cb52" data-startFrom="8"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 7;"><span id="cb52-8"><a href="#cb52-8"></a><span class="ot">{-# LANGUAGE FlexibleInstances, TypeSynonymInstances #-}</span></span>
<span id="cb52-9"><a href="#cb52-9"></a><span class="kw">module</span> <span class="dt">AESA.Radar</span> <span class="kw">where</span></span></code></pre></div>
<p>For this model we import the following <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC.html"><code>MoC</code></a> libraries: <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-CT.html"><code>CT</code></a> defines discrete interactions between continuous sub-domains, <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-DE.html"><code>DE</code></a> defines the <em>discrete event</em> MoC, which in this case is only used as a conduit MoC, and <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>SY</code></a> which defines the <em>synchronous reactive</em> MoC, on which the AESA signal processing chain operates. From the <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skeleton.html"><code>Skeleton</code></a> layer we import <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skeleton-Vector.html"><code>Vector</code></a>. From the <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Probability.html"><code>Probability</code></a> layer we import the <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Probability-Normal.html"><code>Normal</code></a> distribution to represent white noise.</p>
<div class="sourceCode" id="cb53" data-startFrom="29"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 28;"><span id="cb53-29"><a href="#cb53-29"></a><span class="kw">import</span> <span class="kw">qualified</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-Time.html"><span class="dt">ForSyDe.Atom.MoC.Time</span></a> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb53-30"><a href="#cb53-30"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-CT.html"><span class="dt">ForSyDe.Atom.MoC.CT</span></a> <span class="kw">as</span> <span class="dt">CT</span></span>
<span id="cb53-31"><a href="#cb53-31"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-DE.html"><span class="dt">ForSyDe.Atom.MoC.DE</span></a> <span class="kw">as</span> <span class="dt">DE</span></span>
<span id="cb53-32"><a href="#cb53-32"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a> <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb53-33"><a href="#cb53-33"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb53-34"><a href="#cb53-34"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Prob-Normal.html"><span class="dt">ForSyDe.Atom.Prob.Normal</span></a> <span class="kw">as</span> <span class="dt">N</span></span></code></pre></div>
<p>Other necessary utilities are also imported.</p>
<div class="sourceCode" id="cb54" data-startFrom="38"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 37;"><span id="cb54-38"><a href="#cb54-38"></a><span class="kw">import</span> <span class="dt">AESA.Params</span></span>
<span id="cb54-39"><a href="#cb54-39"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span>
<span id="cb54-40"><a href="#cb54-40"></a><span class="kw">import</span> <span class="dt">System.Random</span></span></code></pre></div>
<p>Since we model high frequency signals, we want to avoid unnecessary quantization errors when representing time instants, therefore we choose a more appropriate representation for timestamps, as <a href="http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Ratio.html#t:Rational"><code>Rational</code></a> numbers. We thus define two aliases <code>CTSignal</code> and <code>DESignal</code> to represent CT respectively DE signals with <code>Rational</code> timestamps.</p>
<div class="sourceCode" id="cb55" data-startFrom="49"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 48;"><span id="cb55-49"><a href="#cb55-49"></a><span class="kw">type</span> <span class="dt">CTSignal</span> a <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-CT.html"><span class="dt">CT.SignalBase</span></a> <span class="dt">Time</span> <span class="dt">Time</span> a</span>
<span id="cb55-50"><a href="#cb55-50"></a><span class="kw">type</span> <span class="dt">DESignal</span> a <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-DE.html"><span class="dt">DE.SignalBase</span></a> <span class="dt">Time</span> a</span></code></pre></div>
<h2 data-number="4.1" id="sec:radar-refl"><span class="header-section-number">4.1</span> Object Reflection Model</h2>
<p>The beamforming principle, illustrated in Figure <a href="#fig:aesa-beamforming">20</a> and briefly presented in section <a href="#sec:cube-dbf-atom">2.2.2.1</a> allows to extract both distance and speed information by cross-checking the information carried by a reflection signal as seen by multiple antenna elements.</p>
<figure>
<img src="figs/beam-acq.png" id="fig:aesa-beamforming" style="height:3.5cm" alt="" /><figcaption>Figure 20: Antenna Beamforming</figcaption>
</figure>
<figure>
<img src="figs/beamform-calculations.png" id="fig:aesa-calculations" style="height:3.5cm" alt="" /><figcaption>Figure 21: The geometry for beamforming calculations</figcaption>
</figure>
<p>According to basic radar principles, an object is detected by sending carrier pulse wave (usually in GHz band, pulse width <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>, period <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>), and decoding the cumulative information from the returning signal, such as reflection time <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math> or phase modulation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϕ</mi><annotation encoding="application/x-tex">\phi</annotation></semantics></math>. In an AESA radar, the constructive interference created by multiple simultaneous detections (see Figure <a href="#fig:aesa-beamforming">20</a>) infers information about direction or speed. Each antenna element is extracting phase information as complex numbers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>+</mo><mi>i</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">I+iQ</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>=</mo><mi>A</mi><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><mi>ϕ</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">I=A\cos(\phi t)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>A</mi><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ϕ</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Q=A\sin(\phi t)</annotation></semantics></math>, which are then samples them and stores them into range bins, like in Figure <a href="#fig:aesa-iq">22</a>.</p>
<figure>
<img src="figs/iq.png" id="fig:aesa-iq" alt="" /><figcaption>Figure 22: Extracting the phase information</figcaption>
</figure>
<p>We model the radar environment by recreating, in CT domain, the image of signals reflected by arbitrary objects, as perceived by every antenna element. Since many of the calculations are time-dependent, we need a high precision for the number representation. Therefore, as with the time representation, the coefficients representing the radar physics need to be <em>defined</em> as rationals (and not just converted), hence we define <code>'</code> alternatives to the coefficients in <code>AESA.Params</code>.</p>
<div class="sourceCode" id="cb56" data-startFrom="78"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 77;"><span id="cb56-78"><a href="#cb56-78"></a>freqRadar&#39;  <span class="ot">=</span> <span class="fl">10e9</span><span class="ot">              ::</span> <span class="dt">Rational</span></span>
<span id="cb56-79"><a href="#cb56-79"></a>waveLength&#39; <span class="ot">=</span> <span class="fl">3e8</span> <span class="op">/</span> freqRadar&#39;</span>
<span id="cb56-80"><a href="#cb56-80"></a>dElements&#39;  <span class="ot">=</span> waveLength&#39; <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb56-81"><a href="#cb56-81"></a>fSampling&#39;  <span class="ot">=</span> <span class="fl">3e6</span><span class="ot">               ::</span> <span class="dt">Rational</span></span>
<span id="cb56-82"><a href="#cb56-82"></a>pulseWidth&#39; <span class="ot">=</span> <span class="fl">1e-6</span><span class="ot">              ::</span> <span class="dt">Rational</span></span>
<span id="cb56-83"><a href="#cb56-83"></a>sampPeriod&#39;  <span class="ot">=</span> <span class="dv">1</span> <span class="op">/</span><span class="ot"> fSampling&#39;   ::</span> <span class="dt">Rational</span></span>
<span id="cb56-84"><a href="#cb56-84"></a>pulsePeriod&#39; <span class="ot">=</span> sampPeriod&#39; <span class="op">*</span> <span class="fu">realToFrac</span> nb</span></code></pre></div>
<p>We approach modeling of the object reflection signals from two perspectives: the first one is a simple “translation” of a numerical program, e.g. written in Matlab or Python, where we only abstract away the time representation as a function argument; the second one is a more proper description of the signal transformations and interactions through CT processes.</p>
<h3 data-number="4.1.1" id="sec:atom-radar-app1"><span class="header-section-number">4.1.1</span> Approach 1: Translating a Numerical Program</h3>
<p>In this approach we simply translate the Python script used to generate the AESA radar indata for the previous sections, included in this project source files. We do this in order to familiarize with the concept of continuum in ForSyDe as simply functions over (an abstract representation of) time. This way any numerical program can become a CT signal by defining it as a function which exposes the time variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> as an argument and passes it to an infinite signal generator.</p>
<p>The following function describes the value in time of the impulses reflected from a specific object with certain characteristics (see arguments list).</p>
<div class="sourceCode" id="cb57" data-startFrom="105"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 104;"><span id="cb57-105"><a href="#cb57-105"></a><span class="ot">reflectionFunc ::</span> <span class="dt">Float</span>   <span class="co">-- ^ initial phase, random between [0,2pi)</span></span>
<span id="cb57-106"><a href="#cb57-106"></a>               <span class="ot">-&gt;</span> <span class="dt">Float</span>   <span class="co">-- ^ object distance from radar, in meters</span></span>
<span id="cb57-107"><a href="#cb57-107"></a>               <span class="ot">-&gt;</span> <span class="dt">Float</span>   <span class="co">-- ^ $\theta$, angle relative to the radar element</span></span>
<span id="cb57-108"><a href="#cb57-108"></a>               <span class="ot">-&gt;</span> <span class="dt">Float</span>   <span class="co">-- ^ relative speed in m/s. Positive speed means approaching object</span></span>
<span id="cb57-109"><a href="#cb57-109"></a>               <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="co">-- ^ signal power</span></span>
<span id="cb57-110"><a href="#cb57-110"></a>               <span class="ot">-&gt;</span> <span class="dt">Int</span>     <span class="co">-- ^ index of the antenna element in [0..nA]</span></span>
<span id="cb57-111"><a href="#cb57-111"></a>               <span class="ot">-&gt;</span> <span class="dt">T.Time</span>  <span class="co">-- ^ Abstract time representation. Evaluated only when plotting</span></span>
<span id="cb57-112"><a href="#cb57-112"></a>               <span class="ot">-&gt;</span> <span class="dt">Complex</span> <span class="dt">Float</span> <span class="co">-- ^ Value of reflection signal for an antenna element (t)</span></span>
<span id="cb57-113"><a href="#cb57-113"></a>reflectionFunc phi distance angle relativeSpeed signalPower chanIx t</span>
<span id="cb57-114"><a href="#cb57-114"></a>  <span class="op">|</span> range_bin <span class="op">&gt;=</span> trefl_start <span class="op">&amp;&amp;</span> range_bin <span class="op">&lt;=</span> trefl_stop <span class="op">&amp;&amp;</span> <span class="fu">not</span> crossing_reflection <span class="ot">=</span> value</span>
<span id="cb57-115"><a href="#cb57-115"></a>  <span class="op">|</span> <span class="fu">not</span> (range_bin <span class="op">&gt;=</span> trefl_start <span class="op">&amp;&amp;</span> range_bin <span class="op">&lt;=</span> trefl_stop) <span class="op">&amp;&amp;</span> crossing_reflection <span class="ot">=</span> value</span>
<span id="cb57-116"><a href="#cb57-116"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb57-117"><a href="#cb57-117"></a>  <span class="kw">where</span></span>
<span id="cb57-118"><a href="#cb57-118"></a>    i&#39; <span class="ot">=</span> <span class="fu">realToFrac</span> chanIx</span>
<span id="cb57-119"><a href="#cb57-119"></a>    t&#39; <span class="ot">=</span> <span class="fu">realToFrac</span> t</span>
<span id="cb57-120"><a href="#cb57-120"></a>    </span>
<span id="cb57-121"><a href="#cb57-121"></a>    <span class="co">-- wd is 2*pi*doppler frequency</span></span>
<span id="cb57-122"><a href="#cb57-122"></a>    wd <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> relativeSpeed <span class="op">/</span> waveLength</span>
<span id="cb57-123"><a href="#cb57-123"></a>    </span>
<span id="cb57-124"><a href="#cb57-124"></a>    <span class="co">-- A is the power of the reflected signal (-5 =&gt; 1/32 of fullscale)</span></span>
<span id="cb57-125"><a href="#cb57-125"></a>    bigA <span class="ot">=</span> <span class="dv">2</span> <span class="op">^^</span> signalPower</span>
<span id="cb57-126"><a href="#cb57-126"></a></span>
<span id="cb57-127"><a href="#cb57-127"></a>    <span class="co">-- Large distances will fold to lower ones, assume infinite sequences</span></span>
<span id="cb57-128"><a href="#cb57-128"></a>    <span class="co">-- Otherwise the the first X pulses would be absent</span></span>
<span id="cb57-129"><a href="#cb57-129"></a>    trefl_start <span class="ot">=</span> <span class="fu">ceiling</span> ((<span class="dv">2</span> <span class="op">*</span> distance <span class="op">/</span> <span class="fl">3e8</span>) <span class="op">*</span> fSampling) <span class="ot">`mod`</span> nb </span>
<span id="cb57-130"><a href="#cb57-130"></a>    trefl_stop  <span class="ot">=</span> <span class="fu">ceiling</span> ((<span class="dv">2</span> <span class="op">*</span> distance <span class="op">/</span> <span class="fl">3e8</span> <span class="op">+</span> pulseWidth) <span class="op">*</span> fSampling) <span class="ot">`mod`</span> nb</span>
<span id="cb57-131"><a href="#cb57-131"></a>    range_bin   <span class="ot">=</span> <span class="fu">ceiling</span> (t&#39; <span class="op">*</span> fSampling) <span class="ot">`mod`</span> nb</span>
<span id="cb57-132"><a href="#cb57-132"></a></span>
<span id="cb57-133"><a href="#cb57-133"></a>    <span class="co">-- Handling for distances at the edge of the</span></span>
<span id="cb57-134"><a href="#cb57-134"></a>    crossing_reflection <span class="ot">=</span> trefl_stop <span class="op">&lt;</span> trefl_start</span>
<span id="cb57-135"><a href="#cb57-135"></a>    </span>
<span id="cb57-136"><a href="#cb57-136"></a>    <span class="co">-- Models the delay between the first antenna element and the current one    </span></span>
<span id="cb57-137"><a href="#cb57-137"></a>    channelDelay <span class="ot">=</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> i&#39; <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> <span class="fu">sin</span> angle</span>
<span id="cb57-138"><a href="#cb57-138"></a>    bigI  <span class="ot">=</span>        bigA <span class="op">*</span> <span class="fu">cos</span> (wd <span class="op">*</span> t&#39; <span class="op">+</span> phi)</span>
<span id="cb57-139"><a href="#cb57-139"></a>    bigQ  <span class="ot">=</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> bigA <span class="op">*</span> <span class="fu">sin</span> (wd <span class="op">*</span> t&#39; <span class="op">+</span> phi)</span>
<span id="cb57-140"><a href="#cb57-140"></a>    value <span class="ot">=</span> (bigI <span class="op">:+</span> bigQ) <span class="op">*</span> (<span class="fu">cos</span> channelDelay <span class="op">:+</span> <span class="fu">sin</span> channelDelay)</span></code></pre></div>
<p>The <code>reflectionFunc</code> function is then passed to a <code>CT.infinite1</code> process constructor which generates an infinite signal. The object reflection on all antennas in a AESA system is constructed with a <code>V.farm11</code> skeleton, which instantiates each signal generator characteristic function according to its antenna index.</p>
<div class="sourceCode" id="cb58" data-startFrom="144"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 143;"><span id="cb58-144"><a href="#cb58-144"></a><span class="ot">objectReflection ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb58-145"><a href="#cb58-145"></a>                 <span class="ot">-&gt;</span> <span class="dt">Vector</span> (<span class="dt">CTSignal</span> (<span class="dt">Complex</span> <span class="dt">Float</span>))</span>
<span id="cb58-146"><a href="#cb58-146"></a>objectReflection radix distance angle relativeSpeed power</span>
<span id="cb58-147"><a href="#cb58-147"></a>  <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> channelRefl (vector [<span class="dv">0</span><span class="op">..</span>nA<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb58-148"><a href="#cb58-148"></a>  <span class="kw">where</span> phi_start     <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> radix <span class="op">/</span> <span class="dv">360</span></span>
<span id="cb58-149"><a href="#cb58-149"></a>        channelRefl i <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-CT.html">CT.infinite1</a></span>
<span id="cb58-150"><a href="#cb58-150"></a>          (reflectionFunc phi_start distance angle relativeSpeed power i)</span></code></pre></div>
<h3 data-number="4.1.2" id="sec:atom-radar-app2"><span class="header-section-number">4.1.2</span> Approach 2: CT Signal Generators</h3>
<p>The second approach combines two CT signals to create the reflection model: a pulse width modulation (PWM) signal modeling the radar pulses, and an envelope signal containing the object’s phase information <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>+</mo><mi>i</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">I+iQ</annotation></semantics></math> as a function of time, like in Figure <a href="#fig:aesa-iq">22</a>. The envelope function is shown below. Observe that it only describes angle and relative speed, but not distance, since the distance is a function of the reflection time.</p>
<div class="sourceCode" id="cb59" data-startFrom="161"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 160;"><span id="cb59-161"><a href="#cb59-161"></a><span class="ot">reflectionEnvelope ::</span> <span class="dt">Float</span>   <span class="co">-- ^ initial phase, random between [0,2pi)</span></span>
<span id="cb59-162"><a href="#cb59-162"></a>                   <span class="ot">-&gt;</span> <span class="dt">Float</span>   <span class="co">-- ^ $\theta$, angle relative to the radar element</span></span>
<span id="cb59-163"><a href="#cb59-163"></a>                   <span class="ot">-&gt;</span> <span class="dt">Float</span>   <span class="co">-- ^ relative speed in m/s. Positive speed means approaching object</span></span>
<span id="cb59-164"><a href="#cb59-164"></a>                   <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="co">-- ^ signal power</span></span>
<span id="cb59-165"><a href="#cb59-165"></a>                   <span class="ot">-&gt;</span> <span class="dt">Int</span>     <span class="co">-- ^ index of the antenna element in [0..nA]</span></span>
<span id="cb59-166"><a href="#cb59-166"></a>                   <span class="ot">-&gt;</span> <span class="dt">T.Time</span>  <span class="co">-- ^ Abstract time representation. Evaluated only when plotting</span></span>
<span id="cb59-167"><a href="#cb59-167"></a>                   <span class="ot">-&gt;</span> <span class="dt">Complex</span> <span class="dt">Float</span> <span class="co">-- ^ envelope for one antenna element</span></span>
<span id="cb59-168"><a href="#cb59-168"></a>reflectionEnvelope phi angle relativeSpeed power chanIdx t</span>
<span id="cb59-169"><a href="#cb59-169"></a>  <span class="ot">=</span> (bigI <span class="op">:+</span> bigQ) <span class="op">*</span> (<span class="fu">cos</span> channelDelay <span class="op">:+</span> <span class="fu">sin</span> channelDelay)</span>
<span id="cb59-170"><a href="#cb59-170"></a>  <span class="kw">where</span></span>
<span id="cb59-171"><a href="#cb59-171"></a>   <span class="co">-- convert integer to floating point</span></span>
<span id="cb59-172"><a href="#cb59-172"></a>    i&#39;  <span class="ot">=</span> <span class="fu">realToFrac</span> chanIdx </span>
<span id="cb59-173"><a href="#cb59-173"></a>    <span class="co">-- convert &quot;real&quot; numbers to floating point (part of the spec)</span></span>
<span id="cb59-174"><a href="#cb59-174"></a>    t&#39;  <span class="ot">=</span> <span class="fu">realToFrac</span> t</span>
<span id="cb59-175"><a href="#cb59-175"></a>    </span>
<span id="cb59-176"><a href="#cb59-176"></a>    <span class="co">-- wd is 2*pi*doppler frequency</span></span>
<span id="cb59-177"><a href="#cb59-177"></a>    wd <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> relativeSpeed <span class="op">/</span> waveLength</span>
<span id="cb59-178"><a href="#cb59-178"></a>    </span>
<span id="cb59-179"><a href="#cb59-179"></a>    <span class="co">-- A is the power of the reflected signal (-5 =&gt; 1/32 of fullscale)</span></span>
<span id="cb59-180"><a href="#cb59-180"></a>    bigA <span class="ot">=</span> <span class="dv">2</span> <span class="op">^^</span> power</span>
<span id="cb59-181"><a href="#cb59-181"></a></span>
<span id="cb59-182"><a href="#cb59-182"></a>    channelDelay <span class="ot">=</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> i&#39; <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> <span class="fu">sin</span> angle</span>
<span id="cb59-183"><a href="#cb59-183"></a>    bigI  <span class="ot">=</span>        bigA <span class="op">*</span> <span class="fu">cos</span> (wd <span class="op">*</span> t&#39; <span class="op">+</span> phi)</span>
<span id="cb59-184"><a href="#cb59-184"></a>    bigQ  <span class="ot">=</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">*</span> bigA <span class="op">*</span> <span class="fu">sin</span> (wd <span class="op">*</span> t&#39; <span class="op">+</span> phi)</span></code></pre></div>
<figure>
<img src="figs/radar-env.png" id="fig:radar-env" alt="" /><figcaption>Figure 23: Modeling an object reflection signal in all channels</figcaption>
</figure>
<p>The reflection signal in a channel is modeled like in Figure <a href="#fig:radar-env">23</a> as the product between a PWM signal and an envelope generator. The <code>pwm</code> generator is a specialized instance of a <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-DE.html#v:state22"><code>DE.state11</code></a> process, and the reflection time <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math> is controlled with a <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-DE.html#v:delay"><code>DE.delay</code></a> process. <code>DE.hold1</code> is a MoC interface which transforms a DE signal into a CT signal of constant sub-signals (see <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mn>3</mn></msub><annotation encoding="application/x-tex">s_3</annotation></semantics></math> in Figure <a href="#fig:radar-env">23</a>).</p>
<div class="sourceCode" id="cb60" data-startFrom="194"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 193;"><span id="cb60-194"><a href="#cb60-194"></a><span class="ot">channelReflection&#39; ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb60-195"><a href="#cb60-195"></a>                   <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CTSignal</span> (<span class="dt">Complex</span> <span class="dt">Float</span>)</span>
<span id="cb60-196"><a href="#cb60-196"></a>channelReflection&#39; phi distance angle relativeSpeed power chanIndex</span>
<span id="cb60-197"><a href="#cb60-197"></a>  <span class="co">-- delay the modulated pulse reflections according to the object distance.</span></span>
<span id="cb60-198"><a href="#cb60-198"></a>  <span class="co">-- until the first reflection is observed, the signal is constant 0</span></span>
<span id="cb60-199"><a href="#cb60-199"></a>  <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-CT.html">CT.comb21</a> (<span class="op">*</span>) pulseSig (modulationSig chanIndex)</span>
<span id="cb60-200"><a href="#cb60-200"></a>  <span class="kw">where</span></span>
<span id="cb60-201"><a href="#cb60-201"></a>    <span class="co">-- convert floating point numbers to timestamp format</span></span>
<span id="cb60-202"><a href="#cb60-202"></a>    distance&#39;    <span class="ot">=</span> <span class="fu">realToFrac</span> distance</span>
<span id="cb60-203"><a href="#cb60-203"></a></span>
<span id="cb60-204"><a href="#cb60-204"></a>    <span class="co">-- reflection time, given as timestamp</span></span>
<span id="cb60-205"><a href="#cb60-205"></a>    reflTime      <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> distance&#39; <span class="op">/</span> <span class="fl">3e8</span></span>
<span id="cb60-206"><a href="#cb60-206"></a></span>
<span id="cb60-207"><a href="#cb60-207"></a>    <span class="co">-- a discrete (infinite) PWM signal with amplitude 1, converted to CT domain</span></span>
<span id="cb60-208"><a href="#cb60-208"></a>    pulseSig      <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-DE.html">DE.hold1</a> <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-DE.html">DE.delay</a> reflTime <span class="dv">0</span> <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-DE.html">DE.pwm</a> pulseWidth&#39; pulsePeriod&#39;</span>
<span id="cb60-209"><a href="#cb60-209"></a></span>
<span id="cb60-210"><a href="#cb60-210"></a>    <span class="co">-- an infinite CT signal describing the modulation for each channel</span></span>
<span id="cb60-211"><a href="#cb60-211"></a>    modulationSig <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-CT.html">CT.infinite1</a> <span class="op">.</span> reflectionEnvelope phi angle relativeSpeed power</span></code></pre></div>
<p>Finally, we describe an object reflection in all channels similarly to the previous approach, namely as a farm of <code>channelReflection</code> processes.</p>
<div class="sourceCode" id="cb61" data-startFrom="216"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 215;"><span id="cb61-216"><a href="#cb61-216"></a><span class="ot">objectReflection&#39; ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb61-217"><a href="#cb61-217"></a>                  <span class="ot">-&gt;</span> <span class="dt">Vector</span> (<span class="dt">CTSignal</span> (<span class="dt">Complex</span> <span class="dt">Float</span>))</span>
<span id="cb61-218"><a href="#cb61-218"></a>objectReflection&#39; radix distance angle relativeSpeed power</span>
<span id="cb61-219"><a href="#cb61-219"></a>  <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> channelRefl (vector [<span class="dv">0</span><span class="op">..</span>nA<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb61-220"><a href="#cb61-220"></a>  <span class="kw">where</span> phi_start   <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> radix <span class="op">/</span> <span class="dv">360</span></span>
<span id="cb61-221"><a href="#cb61-221"></a>        channelRefl <span class="ot">=</span></span>
<span id="cb61-222"><a href="#cb61-222"></a>          channelReflection&#39; phi_start distance angle relativeSpeed power</span></code></pre></div>
<p>Both approaches 1 and 2 are equivalent. The reader is free to test this statement using whatever method she chooses, but for the sake of readability we will only use approach 2 from now on, i.e. <code>objectReflection'</code>.</p>
<h2 data-number="4.2" id="sec:radar-noisy-data"><span class="header-section-number">4.2</span> Sampling Noisy Data. Using Distributions.</h2>
<p>Multiple reflected objects are described as a vector of vectors of complex CT signals, each originating from its corresponding <code>objectReflection'</code> farm. To obtain the composite signal from multiple object reflections we sum-reduce all object reflection models, like in Figure <a href="#fig:radar-adc">24</a>.</p>
<figure>
<img src="figs/radar-adc.png" id="fig:radar-adc" alt="" /><figcaption>Figure 24: Video indata acquisition model</figcaption>
</figure>
<div class="sourceCode" id="cb62" data-startFrom="237"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 236;"><span id="cb62-237"><a href="#cb62-237"></a><span class="ot">reflectionMix ::</span> <span class="dt">Vector</span> (<span class="dt">Vector</span> (<span class="dt">CTSignal</span> (<span class="dt">Complex</span> <span class="dt">Float</span>)))</span>
<span id="cb62-238"><a href="#cb62-238"></a>              <span class="ot">-&gt;</span> <span class="dt">Vector</span> (<span class="dt">CTSignal</span> (<span class="dt">Complex</span> <span class="dt">Float</span>))</span>
<span id="cb62-239"><a href="#cb62-239"></a>reflectionMix <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.reduce</a> <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm21</a> <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-CT.html">CT.comb21)</a> (<span class="op">+</span>) </span></code></pre></div>
<figure>
<img src="figs/if-ad.png" id="fig:radar-if-ad" alt="" /><figcaption>Figure 25: Ideal ADC model</figcaption>
</figure>
<p>The next step is to sample the CT signals using an analog/digital converter (ADC) model. An ADC is characterized by:</p>
<ol type="1">
<li><p>a sampling rate, whose principle is illustrated in Figure <a href="#fig:radar-if-ad">25</a>. In our case we describe a CT/SY MoC interface as a serialization of CT/DE and DE/SY interfaces.</p></li>
<li><p>an additive <em>white noise</em> for each channel. White noise is a side-effect of the physical environment, and any sampled value is randomly-dependent on a particular experiment/observation. To describe random distributions in a pure setting, we wrap the object reflection SY samples into a <code>N.normal</code> recipe for generating normally-distributed observations with a standard deviation dependent on the power of the noise.</p></li>
</ol>
<p>The <code>N.normal</code> wrapper is a function describing a Gaussian distribution, in our case the Box-Muller method to transform uniform distributions, and is dependent on a (pseudo-)random number generator, in our case <a href="https://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:StdGen"><code>StdGen</code></a>. A <code>StdGen</code> is acquired outside the model as an IO action and is only passed to the model as an argument. By all means, these recipes (pure functions of “random seeds”) can be propagated and transformed throughout the AESA model, <em>exactly</em> in the same way as CT signals (pure functions of “time”), using atoms and patterns from to the <code>Probability</code> layer. However, for the scope of this model we sample these distributions immediately, because the AESA system is expecting <em>numbers</em> as video indata, not distributions. Hence our ADC model looks as follows:</p>
<div class="sourceCode" id="cb63" data-startFrom="268"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 267;"><span id="cb63-268"><a href="#cb63-268"></a><span class="ot">adc ::</span> <span class="dt">Integer</span>                   <span class="co">-- ^ noise power</span></span>
<span id="cb63-269"><a href="#cb63-269"></a>    <span class="ot">-&gt;</span> <span class="dt">DESignal</span> ()               <span class="co">-- ^ global ADC sampler signal. Defines sampling rate</span></span>
<span id="cb63-270"><a href="#cb63-270"></a>    <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> <span class="dt">StdGen</span>          <span class="co">-- ^ signal of random generators used as &quot;seeds&quot;</span></span>
<span id="cb63-271"><a href="#cb63-271"></a>    <span class="ot">-&gt;</span> <span class="dt">CTSignal</span> (<span class="dt">Complex</span> <span class="dt">Float</span>)  <span class="co">-- ^ pure CT signal</span></span>
<span id="cb63-272"><a href="#cb63-272"></a>    <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Float</span>) <span class="co">-- ^ noisy, sampled/observed SY signal</span></span>
<span id="cb63-273"><a href="#cb63-273"></a>adc noisePow sampler seeds <span class="ot">=</span> probeSignal <span class="op">.</span> addNoise <span class="op">.</span> sampleAndHold</span>
<span id="cb63-274"><a href="#cb63-274"></a>  <span class="kw">where</span></span>
<span id="cb63-275"><a href="#cb63-275"></a>    sampleAndHold <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-DE.html">DE.toSY1</a> <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-CT.html">CT.sampDE1</a> sampler</span>
<span id="cb63-276"><a href="#cb63-276"></a>    addNoise      <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Prob-Normal.html">(N.normal</a> (<span class="dv">2</span><span class="op">^^</span>noisePow))</span>
<span id="cb63-277"><a href="#cb63-277"></a>    probeSignal   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb21</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Prob-Normal.html">N.sample</a> seeds</span></code></pre></div>
<p>The full acquisition model for the AESA signal processing system in Figure <a href="#fig:radar-adc">24</a> is thus the following, where each CT signal vector is generated with a specific instance of <code>objectReflection'</code>.</p>
<div class="sourceCode" id="cb64" data-startFrom="283"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 282;"><span id="cb64-283"><a href="#cb64-283"></a><span class="ot">videoInData ::</span> <span class="dt">Integer</span>                   <span class="co">-- ^ noise power</span></span>
<span id="cb64-284"><a href="#cb64-284"></a>            <span class="ot">-&gt;</span> <span class="dt">Vector</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> <span class="dt">StdGen</span>) <span class="co">-- ^ random seeds for sampling</span></span>
<span id="cb64-285"><a href="#cb64-285"></a>            <span class="ot">-&gt;</span> <span class="dt">Vector</span> (<span class="dt">Vector</span> (<span class="dt">CTSignal</span> (<span class="dt">Complex</span> <span class="dt">Float</span>))) <span class="co">-- ^ reflections for all objects</span></span>
<span id="cb64-286"><a href="#cb64-286"></a>            <span class="ot">-&gt;</span> <span class="dt">Vector</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Float</span>))         <span class="co">-- ^ video Indata</span></span>
<span id="cb64-287"><a href="#cb64-287"></a>videoInData noisePow seeds reflections <span class="ot">=</span> inData</span>
<span id="cb64-288"><a href="#cb64-288"></a>  <span class="kw">where</span></span>
<span id="cb64-289"><a href="#cb64-289"></a>    mixedRefl <span class="ot">=</span> reflectionMix reflections</span>
<span id="cb64-290"><a href="#cb64-290"></a>    inData    <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm21</a> (adc noisePow sampler) seeds mixedRefl</span>
<span id="cb64-291"><a href="#cb64-291"></a>    sampler   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-DE.html">DE.generate1</a> <span class="fu">id</span> (sampPeriod&#39;, ()) <span class="co">-- global ADC trigger</span></span></code></pre></div>
<p>The following code can be safely ignored. It enables to generate random <code>Complex</code> numbers, because their respective Haskell library does not define this instance.</p>
<div class="sourceCode" id="cb65" data-startFrom="295"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 294;"><span id="cb65-295"><a href="#cb65-295"></a><span class="kw">instance</span> <span class="dt">Random</span> (<span class="dt">Complex</span> <span class="dt">Float</span>) <span class="kw">where</span></span>
<span id="cb65-296"><a href="#cb65-296"></a>  randomR (lo,hi) g <span class="ot">=</span> <span class="kw">let</span> (i,g&#39;)  <span class="ot">=</span> randomR (realPart lo, realPart hi) g</span>
<span id="cb65-297"><a href="#cb65-297"></a>                          (q,g&#39;&#39;) <span class="ot">=</span> randomR (imagPart lo, imagPart hi) g&#39;</span>
<span id="cb65-298"><a href="#cb65-298"></a>                      <span class="kw">in</span> (i<span class="op">:+</span>q, g&#39;&#39;)</span>
<span id="cb65-299"><a href="#cb65-299"></a>  random g  <span class="ot">=</span> <span class="kw">let</span> (i,g&#39;)  <span class="ot">=</span> random g</span>
<span id="cb65-300"><a href="#cb65-300"></a>                  (q,g&#39;&#39;) <span class="ot">=</span> random g&#39;</span>
<span id="cb65-301"><a href="#cb65-301"></a>              <span class="kw">in</span> (i<span class="op">:+</span>q, g&#39;&#39;)</span></code></pre></div>
<h2 data-number="4.3" id="conclusions"><span class="header-section-number">4.3</span> Conclusions</h2>
<p>We have introduced a new MoC for describing continuous dynamics as functions of time, and a new layer for describing probability distributions as functions of a random number generator. Both have in common the fact that they represent models as pure functions by virtue of the functional programming host, Haskell, in which functions are first class citizens. This way their model remains mathematical and pure, by abstracting away their machine implementation, i.e. time representation, respectively pseudo-random number generator, these aspects becoming apparent only when sampling and tracing a simulation.</p>
<p>Using these new EDSLs, we have described the radar environment for a certain simulation scenario, by modeling the object reflection dynamics as continuous signals, drowned in white noise. When generating and dumping the generated antenna samples, we obtain a similar picture to the one in Figure <a href="#fig:aesa-indata">17 (a)</a>, respectively the AESA processed output looks similar to Figure <a href="#fig:aesa-odata-atom">17 (b)</a>.</p>
<h1 data-number="5" id="sec:props"><span class="header-section-number">5</span> Validating a ForSyDe Model Against the Specification</h1>
<blockquote>
<p><em>This section presents a practical and convenient method for verifying the conformance of a ForSyDe model against a set of specification properties. In order to do so we make use of the <a href="http://www.cse.chalmers.se/~rjmh/QuickCheck/">QuickCheck</a> framework, which offers an EDSL for specifying system model properties and a random test-case generation engine for validating a design under test (DUT) against these properties. Although the verification is not exhaustive, it is “smart” enough to quickly identify and correct discrepancies between specification and model implementation, making QuickCheck an ideal tool in a system designer’s toolbox.</em></p>
</blockquote>
<table>
<tbody>
<tr class="odd">
<td>Package</td>
<td>aesa-atom-0.1.0</td>
<td>path: <code>./aesa-atom/README.md</code></td>
</tr>
<tr class="even">
<td>Deps</td>
<td>forsyde-atom-0.3.1</td>
<td>url: <code>https://forsyde.github.io/forsyde-atom/api/</code></td>
</tr>
<tr class="odd">
<td></td>
<td>QuickCheck-2.13.1</td>
<td>url: <code>http://hackage.haskell.org/package/QuickCheck</code></td>
</tr>
<tr class="even">
<td>Suite</td>
<td>tests-cube</td>
<td>usage: <code>stack test :tests-cube</code></td>
</tr>
</tbody>
</table>
<p><a href="http://www.cse.chalmers.se/~rjmh/QuickCheck/">QuickCheck</a> <span class="citation" data-cites="claessen-2011-quick">(Claessen and Hughes <a href="#ref-claessen-2011-quick" role="doc-biblioref">2011</a>)</span> is a DSL embedded in Haskell for specifying denotational properties of functions, and a test case generator engine based on type algebras to obtain a good coverage of a DUT. As it is based on type algebras, it uses the insights from the DUT’s type constructors to build automatic or user-guided strategies for identifying edge or violating cases within a relatively small number of test cases. Due to its random nature it is capable of finding failing sequences of inputs, which are then  to define minimum violating cases, making it very useful in development iterations.</p>
<p>A very good article motivating QuickCheck’s usefulness in system design is found on <a href="https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html">Joe Nelson’s blog</a>, from which we extract the following paragraph: “Proponents of formal methods sometimes stress the notion of specification above that of implementation. However it is the inconsistencies between these two independent descriptions of the desired behavior that reveal the truth. We discover incomplete understanding in the specs and bugs in the implementation. Programming does not flow in a single direction from specifications to implementation but evolves by cross-checking and updating the two. Property-based testing quickens this evolution. Of course the only way to truly guarantee properties of programs is by mathematical proof. However property-based tests approximate deductive confidence with less work by checking properties for a finite number of randomized inputs called test cases.”</p>
<p><strong>DISCLAIMER:</strong> this section assumes that the reader is familiar with QuickCheck’s syntax and has gone through a few hands-on tutorials. For more information we recommend checking out either the article of <span class="citation" data-cites="hughes-2007">Hughes (<a href="#ref-hughes-2007" role="doc-biblioref">2007</a>)</span>, John Nelson’s <a href="https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html">blog article on QuickCheck</a>, or the (slightly outdated) <a href="http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html">official QuickCheck tutorial</a>.</p>
<h2 data-number="5.1" id="sec:prop-notation"><span class="header-section-number">5.1</span> Formal Notation</h2>
<p>Properties in the QuickCheck DSL are formulated as  <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> , where pre-conditions are defining generators for legal inputs under which the statement is evaluated.</p>
<p>In order to ease the understanding of the QuickCheck code, for each property we will also provide a short-hand mathematical notation using the  <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math>  format, using the following conventions:</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">Notation</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>α</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle\alpha\rangle</annotation></semantics></math></td>
<td style="text-align: left;"><code>Vector a</code></td>
</tr>
<tr class="even">
<td style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo></mrow><annotation encoding="application/x-tex">|v|</annotation></semantics></math></td>
<td style="text-align: left;"><code>length v</code></td>
</tr>
<tr class="odd">
<td style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>s</mi><mo accent="true">¯</mo></mover><annotation encoding="application/x-tex">\overline{s}</annotation></semantics></math></td>
<td style="text-align: left;">a signal with events with the type of <code>s</code></td>
</tr>
<tr class="even">
<td style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a,b,c,...\rangle</annotation></semantics></math></td>
<td style="text-align: left;"><code>vector [a,b,c,...]</code></td>
</tr>
<tr class="odd">
<td style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{a,b,c,...\}</annotation></semantics></math></td>
<td style="text-align: left;"><code>signal [a,b,c,...]</code></td>
</tr>
<tr class="even">
<td style="text-align: right;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Sigma(s)</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Sigma(v)</annotation></semantics></math></td>
<td style="text-align: left;">the (ordered) sequence with the elements from a signal <code>s</code> or a vector <code>v</code></td>
</tr>
</tbody>
</table>
<h2 data-number="5.2" id="sec:prop-defs"><span class="header-section-number">5.2</span> Properties</h2>
<p>In this subsection we formulate a handful of properties whose purpose is:</p>
<ol type="1">
<li><p>to test that the model implementation from section <a href="#sec:cube-atom-operation">2.2</a> does not violate in any circumstance these “contracts”; and</p></li>
<li><p>ensure that any future (iterative) model refinement does not alter or violate these “contracts”.</p></li>
</ol>
<p>Below you find the code written in a runnable module found at <code>aesa-atom/test</code>, which constitute the <code>:tests-cube</code> suite:</p>
<div class="sourceCode" id="cb66" data-startFrom="14"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 13;"><span id="cb66-14"><a href="#cb66-14"></a><span class="kw">module</span> <span class="dt">SpecCube</span> <span class="kw">where</span></span></code></pre></div>
<h3 data-number="5.2.1" id="imports"><span class="header-section-number">5.2.1</span> Imports</h3>
<p>A couple of modules need to be imported before we can proceed. The <a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a> and <a href="http://hackage.haskell.org/package/HTF">Framework</a> modules a provide the test DSL as well as a couple of handy utilities for writing and handling test suites.</p>
<div class="sourceCode" id="cb67" data-startFrom="23"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 22;"><span id="cb67-23"><a href="#cb67-23"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb67-24"><a href="#cb67-24"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck.Function</span></span>
<span id="cb67-25"><a href="#cb67-25"></a><span class="kw">import</span> <span class="dt">Test.Framework</span></span>
<span id="cb67-26"><a href="#cb67-26"></a><span class="kw">import</span> <span class="dt">Test.Framework.Providers.QuickCheck2</span> (testProperty)</span></code></pre></div>
<p>We import some relevant ForSyDe-Atom modules, mainly to get access to the internal structure of ForSyDe types such as <code>Vector</code> or <code>Signal</code>.</p>
<div class="sourceCode" id="cb68" data-startFrom="31"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 30;"><span id="cb68-31"><a href="#cb68-31"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb68-32"><a href="#cb68-32"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a> <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb68-33"><a href="#cb68-33"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.Matrix</span></a> (<span class="dt">Matrix</span>, size)</span>
<span id="cb68-34"><a href="#cb68-34"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.DSP</span></a> (fir)</span></code></pre></div>
<p>Obviously, we need to import the AESA designs modules as well.</p>
<div class="sourceCode" id="cb69" data-startFrom="38"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 37;"><span id="cb69-38"><a href="#cb69-38"></a><span class="kw">import</span> <span class="dt">AESA.CubesAtom</span></span>
<span id="cb69-39"><a href="#cb69-39"></a><span class="kw">import</span> <span class="dt">AESA.Coefs</span></span>
<span id="cb69-40"><a href="#cb69-40"></a><span class="kw">import</span> <span class="dt">AESA.Params</span></span></code></pre></div>
<p>Finally, we import some in-house data generators which will be used in formulating the pre-conditions below, as well as some Haskell data type libraries. The generators are further documented in section <a href="#sec:prop-gens">5.2.4</a>.</p>
<div class="sourceCode" id="cb70" data-startFrom="46"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 45;"><span id="cb70-46"><a href="#cb70-46"></a><span class="kw">import</span> <span class="dt">Generators</span></span>
<span id="cb70-47"><a href="#cb70-47"></a><span class="kw">import</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb70-48"><a href="#cb70-48"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span></code></pre></div>
<h3 data-number="5.2.2" id="formulations"><span class="header-section-number">5.2.2</span> Formulations</h3>
<p>The first property we want to check is that the main function in DBF (see section <a href="#sec:cube-dbf-atom">2.2.2.1</a>), <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><annotation encoding="application/x-tex">f_{DBF}</annotation></semantics></math> will always yield <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>B</mi></msub><annotation encoding="application/x-tex">n_B</annotation></semantics></math> beam samples, no matter what or how many inputs it has. Using the notation from section <a href="#sec:prop-notation">5.1</a> we can formalize this property as follows: <span id="eq:prop_dbf_num_outputs"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo><mo>&gt;</mo><mn>0</mn><mo>⇒</mo><mo stretchy="false" form="prefix">|</mo><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mo>=</mo><msub><mi>n</mi><mi>B</mi></msub><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>8</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall v \in \langle\mathbb{C}\rangle : |v| &gt; 0 \Rightarrow |f_{DBF}(v)|=n_B
\qquad(8)</annotation></semantics></math></span></p>
<p>Using our custom generator <code>nonNullVector</code> (see section <a href="#sec:prop-gens">5.2.4</a>) which satisfies <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mi>α</mi><mo stretchy="false" form="postfix">⟩</mo><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\forall v\in\langle\alpha\rangle:|v|&gt;0</annotation></semantics></math>. we translate eq. <a href="#eq:prop_dbf_num_outputs">8</a> to QuickCheck code:</p>
<div class="sourceCode" id="cb71" data-startFrom="64"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 63;"><span id="cb71-64"><a href="#cb71-64"></a>prop_dbf_num_outputs <span class="ot">=</span> forAll (nonNullVector arbitrary)</span>
<span id="cb71-65"><a href="#cb71-65"></a>                       <span class="op">$</span> \v <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> (fDBF v) <span class="op">==</span> nB</span></code></pre></div>
<p>This property ensures that the <code>Beam</code> dimension is respected, but what about the <code>Range</code> and <code>Pulse</code> dimensions of the indata video cube? These dimensions must not be altered. This is easy to prove, since the vector on those dimensions undergo a set of nested <code>farm</code> transformations, which <em>ensure by definition</em> that they do not alter the structure of the input data. However, let us be skeptical and assume that the library might be faulty, since <code>farm</code> is such an essential skeleton in the AESA system. A property which verifies that <code>farm</code> does not alter the structure of its input type, and thus any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-dimensional vector (e.g. <code>Matrix</code>, <code>Cube</code>) undergoing a <code>farm11</code> keeps its original dimensions, can be formulated as: <span id="eq:prop_generic_farm_structure"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo>⇒</mo><mo stretchy="false" form="prefix">|</mo><mtext mathvariant="monospace">𝚏𝚊𝚛𝚖𝟷𝟷</mtext><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mo>=</mo><mo stretchy="false" form="prefix">|</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>9</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall v \in \langle\mathbb{C}\rangle \Rightarrow |\texttt{farm11}(f,v)| = |v|
\qquad(9)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb72" data-startFrom="80"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 79;"><span id="cb72-80"><a href="#cb72-80"></a><span class="ot">prop_generic_farm_structure ::</span> <span class="dt">Fun</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb72-81"><a href="#cb72-81"></a>prop_generic_farm_structure f v <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> v <span class="op">==</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> (farm11 (apply f) v)</span></code></pre></div>
<p>Notice that if there are no special pre-conditions for the input data, e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\forall v \in \langle\mathbb{C}\rangle</annotation></semantics></math>, we don’t need to invoke our own generator with the <code>forAll</code> keyword, but rather just specify the input type and QuickCheck will automatically call the default <code>arbitrary</code> generator for that particular type. Also, we enable QuickCheck to generate <em>arbitrary unary functions</em> along with arbitrary data, by using its <code>Fun a b = Fun {apply :: a -&gt; b}</code> function wrapper.</p>
<p>Another property we want to make sure is not violated during any stage in the refinement flow is that the DBF block does not produce overflown numbers, i.e. the beam coefficients are well-scaled. At this abstraction level, we do not really consider the number representation, and for what it’s worth we can assume that our type <code>CpxData</code> is in fact <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}=a+bi</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">a,b\in\mathbb{R}</annotation></semantics></math>. However, we <em>know</em> from the specifications that the input values <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>a</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo>:</mo><mi>a</mi><mo>&gt;</mo><mo>=</mo><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>∧</mo><mi>a</mi><mo>&lt;</mo><mn>1</mn><mo>+</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\forall a\in\mathbb{C}:a&gt;=-1-i \wedge a&lt;1+i</annotation></semantics></math> and that we eventually need to find efficient implementation for these number representations. The engineering intuition/experience tells that a more efficient representation would deal only with decimal numbers and would not need to be concerned with the integer part (e.g. Qn fixed point representation). Thus, at the functional level we need to ensure that the outputs themselves remain within the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>,</mo><mn>1</mn><mo>+</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[-1-i,1+i)</annotation></semantics></math> value pool as well, in order to avoid overflow in an arbitrary number representation.</p>
<p>For the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><annotation encoding="application/x-tex">f_{DBF}</annotation></semantics></math>, the property ensuring legal value bounds would be formulated as: <span id="eq:prop_dbf_value_range"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo>,</mo><mi>a</mi><mo>∈</mo><mi>v</mi><mo>,</mo><mi>b</mi><mo>∈</mo><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo><mo>&gt;</mo><mn>0</mn><mo>∧</mo><mi>a</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>,</mo><mn>1</mn><mo>+</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>⇒</mo><mi>b</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>,</mo><mn>1</mn><mo>+</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>10</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall v \in \langle\mathbb{C}\rangle, a \in v, b \in f_{DBF}(v) : |v| &gt; 0 \wedge a \in [-1-i,1+i) \Rightarrow b \in [-1-i,1+i)
\qquad(10)</annotation></semantics></math></span></p>
<p>which translates into QuickCheck code<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> to:</p>
<div class="sourceCode" id="cb73" data-startFrom="112"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 111;"><span id="cb73-112"><a href="#cb73-112"></a>prop_dbf_value_range <span class="ot">=</span> forAll (nonNullVector decimalCpxNum)</span>
<span id="cb73-113"><a href="#cb73-113"></a>                       <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="fu">all</span> (withinRangeComplex (<span class="op">-</span><span class="dv">1</span>) <span class="dv">1</span>) <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector</a> (fDBF v)</span></code></pre></div>
<p>Recall that in section <a href="#sec:cube-dbf-atom">2.2.2.1</a> we have said that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><annotation encoding="application/x-tex">f_{DBF}</annotation></semantics></math> is the equivalent of a simple vector-matrix dot operation, and provided a simplified definition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><mi>′</mi></mrow><annotation encoding="application/x-tex">f_{DBF}&#39;</annotation></semantics></math> using the library-provided <code>dotvm</code> function. But <em>are</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><annotation encoding="application/x-tex">f_{DBF}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><mi>′</mi></mrow><annotation encoding="application/x-tex">f_{DBF}&#39;</annotation></semantics></math> really equivalent? We test this out by formulating a property: <span id="eq:prop_dbf_func_equiv"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo>⇒</mo><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>D</mi><mi>B</mi><mi>F</mi></mrow></msub><mi>′</mi><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>11</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall v \in \langle\mathbb{C}\rangle \Rightarrow f_{DBF}(v) = f_{DBF}&#39;(v)
\qquad(11)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb74" data-startFrom="125"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 124;"><span id="cb74-125"><a href="#cb74-125"></a>prop_dbf_func_equiv <span class="ot">=</span> forAll (nonNullVector arbitrary)</span>
<span id="cb74-126"><a href="#cb74-126"></a>                      <span class="op">$</span> \v <span class="ot">-&gt;</span> fDBF v <span class="op">==</span> fDBF&#39; v</span></code></pre></div>
<p>Next we target the PC component (see section <a href="#sec:cube-pc-atom">2.2.2.2</a>). The problem of dimension preserving has been solved by the previous <code>prop_generic_farm_structure</code> however, keeping our skeptical attitude, we want to check that the library-provided <code>fir</code> function performing a moving average, does not alter the dimensions of the input data</p>
<p><span id="eq:prop_pc_num_outputs"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo>⇒</mo><mo stretchy="false" form="prefix">|</mo><msub><mi>f</mi><mrow><mi>P</mi><mi>C</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mo>=</mo><mo stretchy="false" form="prefix">|</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>12</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall v \in \langle\mathbb{C}\rangle \Rightarrow |f_{PC}(v)| = |v|
\qquad(12)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb75" data-startFrom="137"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 136;"><span id="cb75-137"><a href="#cb75-137"></a><span class="ot">prop_pc_num_outputs ::</span> <span class="dt">Vector</span> <span class="dt">CpxData</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb75-138"><a href="#cb75-138"></a>prop_pc_num_outputs v <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> v <span class="op">==</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> (fPC v)</span></code></pre></div>
<p>or that it is indeed having the right response to an impulse sequence: <span id="eq:prop_pc_fir_response"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo>,</mo><mi>i</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">⟩</mo><mo>⇒</mo><mtext mathvariant="monospace">𝚏𝚒𝚛</mtext><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>v</mi><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>13</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\forall v \in \langle\mathbb{C}\rangle, i=\langle 1, 0,...\rangle \Rightarrow \texttt{fir} (v,i) = v
\qquad(13)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb76" data-startFrom="144"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 143;"><span id="cb76-144"><a href="#cb76-144"></a><span class="ot">prop_pc_fir_response ::</span> <span class="dt">Vector</span> <span class="dt">CpxData</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb76-145"><a href="#cb76-145"></a>prop_pc_fir_response v <span class="ot">=</span> <span class="fu">and</span> <span class="op">$</span> <span class="fu">zipWith</span> (<span class="op">==</span>) coefs response</span>
<span id="cb76-146"><a href="#cb76-146"></a>  <span class="kw">where</span></span>
<span id="cb76-147"><a href="#cb76-147"></a>    coefs    <span class="ot">=</span> fromVector v</span>
<span id="cb76-148"><a href="#cb76-148"></a>    response <span class="ot">=</span> fromVector <span class="op">$</span> fir v impulse</span>
<span id="cb76-149"><a href="#cb76-149"></a>    impulse  <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.vector</a> <span class="op">$</span> <span class="dv">1</span> <span class="op">:</span> <span class="fu">replicate</span> <span class="dv">100</span> <span class="dv">0</span></span></code></pre></div>
<p>Furthermore we need to check that the FIR coefficients are scaled correctly and the outputs are within the legal range to avoid future possible overflows. <span id="eq:prop_pc_value_range"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo>,</mo><mi>a</mi><mo>∈</mo><mi>v</mi><mo>,</mo><mi>b</mi><mo>∈</mo><msub><mi>f</mi><mrow><mi>P</mi><mi>C</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo><mo>&gt;</mo><mn>0</mn><mo>∧</mo><mi>a</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>,</mo><mn>1</mn><mo>+</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>⇒</mo><mi>b</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>,</mo><mn>1</mn><mo>+</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>14</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall v \in \langle\mathbb{C}\rangle, a \in v, b \in f_{PC}(v) : |v| &gt; 0 \wedge a \in [-1-i,1+i) \Rightarrow b \in [-1-i,1+i)
\qquad(14)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb77" data-startFrom="157"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 156;"><span id="cb77-157"><a href="#cb77-157"></a>prop_pc_value_range <span class="ot">=</span> forAll (nonNullVector decimalCpxNum)</span>
<span id="cb77-158"><a href="#cb77-158"></a>                      <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="fu">all</span> (withinRangeComplex (<span class="op">-</span><span class="dv">1</span>) <span class="dv">1</span>) <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector</a> (fPC v)</span></code></pre></div>
<p>Checking the <code>overlap</code> process in section <a href="#sec:cube-pc-atom">2.2.2.2</a> is a quite tricky to check due to the structure of the data: we would need to access and compare data wrapped in nested vectors with large dimensions, meaning that it will be a very slow process. The 50% overlap will be able to be tested more easily using a random test generator further in section <a href="#sec:refine">6</a>. For now we test that the cube dimensions are preserved by the <code>overlap</code> function: <span id="eq:prop_ct_dimensions"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>c</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">⟩</mo><mo>,</mo><mi>o</mi><mo>∈</mo><mtext mathvariant="monospace">𝚘𝚟𝚎𝚛𝚕𝚊𝚙</mtext><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>c</mi><mo stretchy="false" form="prefix">|</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>n</mi><mi>b</mi></msub><mo>,</mo><msub><mi>n</mi><mi>B</mi></msub><mo>,</mo><msub><mi>n</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>⇒</mo><mo stretchy="false" form="prefix">|</mo><mi>o</mi><mo stretchy="false" form="prefix">|</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>n</mi><mi>b</mi></msub><mo>,</mo><msub><mi>n</mi><mi>B</mi></msub><mo>,</mo><msub><mi>n</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>15</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall c \in \langle\langle\langle\mathbb{C}\rangle\rangle\rangle, o \in \texttt{overlap}(\overline{c}) : |c| = (n_b,n_B,n_{FFT}) \Rightarrow |o| = (n_b,n_B,n_{FFT})
\qquad(15)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb78" data-startFrom="170"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 169;"><span id="cb78-170"><a href="#cb78-170"></a>prop_ct_dimensions <span class="ot">=</span> forAll (sizedCube nFFT nB nb arbitrary)</span>
<span id="cb78-171"><a href="#cb78-171"></a>                     <span class="op">$</span> \c <span class="ot">-&gt;</span> dimensionsMatch <span class="op">$</span> overlap <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.signal</a> [c]</span>
<span id="cb78-172"><a href="#cb78-172"></a>  <span class="kw">where</span></span>
<span id="cb78-173"><a href="#cb78-173"></a>    dimensionsMatch s <span class="ot">=</span> <span class="kw">let</span> c <span class="ot">=</span> L.head <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a> <span class="op">$</span> s</span>
<span id="cb78-174"><a href="#cb78-174"></a>                            z <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> c</span>
<span id="cb78-175"><a href="#cb78-175"></a>                            y <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.first</a> c</span>
<span id="cb78-176"><a href="#cb78-176"></a>                            x <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.first</a> <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.first</a> c</span>
<span id="cb78-177"><a href="#cb78-177"></a>                        <span class="kw">in</span> z <span class="op">==</span> nFFT <span class="op">&amp;&amp;</span> y <span class="op">==</span> nB <span class="op">&amp;&amp;</span> x <span class="op">==</span> nb</span></code></pre></div>
<p>From DFB onward we deal with Doppler values which have a higher range, so we are no longer concerned with testing for overflowing output data, until we take a decision in the refinement process to fix a particular number representation. However, we would still like to test that the format and dimensions of the intermediate cubes is the same, thus we formulate:</p>
<div class="sourceCode" id="cb79" data-startFrom="185"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 184;"><span id="cb79-185"><a href="#cb79-185"></a>prop_dfb_num_outputs <span class="ot">=</span> forAll (sizedVector nFFT arbitrary)</span>
<span id="cb79-186"><a href="#cb79-186"></a>                       <span class="op">$</span> \v <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> v <span class="op">==</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> (fDFB v)</span></code></pre></div>
<div class="sourceCode" id="cb80" data-startFrom="188"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 187;"><span id="cb80-188"><a href="#cb80-188"></a>prop_cfar_num_outputs <span class="ot">=</span> forAll (nonNullVector <span class="op">$</span> nonNullVector arbitrary)</span>
<span id="cb80-189"><a href="#cb80-189"></a>                        <span class="op">$</span> \m <span class="ot">-&gt;</span> size m <span class="op">==</span> size (fCFAR m)</span></code></pre></div>
<p>The DFB contains a FFT function which is hard-coded to work for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><annotation encoding="application/x-tex">n_{FFT}</annotation></semantics></math> samples thus we need to fix the input size accordingly. For the CFAR output, we use the <code>Matrix</code> <code>size</code> utility.</p>
<p>We have tested that the <code>fir</code> implementation gives the correct impulse response, but what about our <code>fir'</code> network instantiation <code>firNet</code> defined in section <a href="#sec:cube-int-atom">2.2.2.6</a>? Does it act like a proper FIR filter? We test it by giving it an “impulse cube” signal, and test that the response is the expected one: <span id="eq:prop_int_fir_response"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo>,</mo><msub><mi>c</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>0</mn></msub><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">⟩</mo><mo>,</mo><msub><mi>e</mi><mn>1</mn></msub><mo>∈</mo><msub><mi>c</mi><mn>1</mn></msub><mo>,</mo><msub><mi>e</mi><mn>0</mn></msub><mo>∈</mo><msub><mi>c</mi><mn>0</mn></msub><mo>:</mo><msub><mi>e</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>∧</mo><msub><mi>e</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mo>⇒</mo><mtext mathvariant="monospace">𝚏𝚒𝚛𝙽𝚎𝚝</mtext><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo>,</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>c</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>0</mn></msub><mo>,</mo><msub><mi>c</mi><mn>0</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mover><msub><mi>s</mi><mi>v</mi></msub><mo accent="true">¯</mo></mover><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>16</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\forall v \in \langle\mathbb{R}\rangle, c_1, c_0 \in
\langle\langle\langle\mathbb{R}\rangle\rangle\rangle, e_1 \in c_1, e_0 \in c_0 : e_1 =
1 \wedge e_0=0 \Rightarrow \texttt{firNet} (v,\{c_1,c_0,c_0,...\}) = \overline{s_v}
\qquad(16)</annotation></semantics></math></span></p>
<p>where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>s</mi><mi>v</mi></msub><mo accent="true">¯</mo></mover><annotation encoding="application/x-tex">\overline{s_v}</annotation></semantics></math> is the response signal whose events are events are cubes containing the coefficients in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>. The generator <code>impulseSigOfCubes</code> is, again, defined in section <a href="#sec:prop-gens">5.2.4</a>.</p>
<div class="sourceCode" id="cb81" data-startFrom="208"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 207;"><span id="cb81-208"><a href="#cb81-208"></a><span class="ot">prop_int_fir_response ::</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">V.Vector</span></a> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb81-209"><a href="#cb81-209"></a>prop_int_fir_response cf <span class="ot">=</span> forAll (impulseSigOfCubes <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.length</a> cf)</span>
<span id="cb81-210"><a href="#cb81-210"></a>                           <span class="op">$</span> \i <span class="ot">-&gt;</span> correctResponse (firNet cf i)</span>
<span id="cb81-211"><a href="#cb81-211"></a> <span class="kw">where</span></span>
<span id="cb81-212"><a href="#cb81-212"></a>    correctResponse r <span class="ot">=</span> <span class="fu">and</span> <span class="op">$</span> <span class="fu">zipWith</span> checkEq coefsL (toLists r)</span>
<span id="cb81-213"><a href="#cb81-213"></a>    checkEq i <span class="ot">=</span> <span class="fu">all</span> (<span class="fu">all</span> (<span class="fu">all</span> (<span class="op">==</span>i)))</span>
<span id="cb81-214"><a href="#cb81-214"></a>    coefsL    <span class="ot">=</span> L.reverse <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector</a> cf</span>
<span id="cb81-215"><a href="#cb81-215"></a>    toLists   <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">map</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector</a> <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector)</a> <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector)</a> <span class="op">.</span> fromSignal</span></code></pre></div>
<h3 data-number="5.2.3" id="main-function"><span class="header-section-number">5.2.3</span> Main function</h3>
<p>Finally we gather all the properties defined in this section in a bundle of tests called “Cube HL Model Tests”, using the utilities provided by the <code>Test.Framework</code> library. <code>withMaxSuccess</code> determines how many random tests will be generated per property during one run.</p>
<div class="sourceCode" id="cb82" data-startFrom="224"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 223;"><span id="cb82-224"><a href="#cb82-224"></a><span class="ot">tests ::</span> [<span class="dt">Test</span>]</span>
<span id="cb82-225"><a href="#cb82-225"></a>tests <span class="ot">=</span> [</span>
<span id="cb82-226"><a href="#cb82-226"></a>  testGroup <span class="st">&quot; Cube HL Model Tests &quot;</span></span>
<span id="cb82-227"><a href="#cb82-227"></a>    [ testProperty <span class="st">&quot;GENERIC farm does not alter the input structure         &quot;</span></span>
<span id="cb82-228"><a href="#cb82-228"></a>      (withMaxSuccess <span class="dv">100</span> prop_generic_farm_structure)</span>
<span id="cb82-229"><a href="#cb82-229"></a>    , testProperty <span class="st">&quot;DBF  right number of outputs                            &quot;</span></span>
<span id="cb82-230"><a href="#cb82-230"></a>      (withMaxSuccess <span class="dv">100</span> prop_dbf_num_outputs)</span>
<span id="cb82-231"><a href="#cb82-231"></a>    , testProperty <span class="st">&quot;DBF  legal value range                                  &quot;</span></span>
<span id="cb82-232"><a href="#cb82-232"></a>      (withMaxSuccess <span class="dv">200</span> prop_dbf_value_range)</span>
<span id="cb82-233"><a href="#cb82-233"></a>    , testProperty <span class="st">&quot;DBF  equivalence with simple dot product operation      &quot;</span></span>
<span id="cb82-234"><a href="#cb82-234"></a>      (withMaxSuccess <span class="dv">200</span> prop_dbf_func_equiv)</span>
<span id="cb82-235"><a href="#cb82-235"></a>    , testProperty <span class="st">&quot;PC   right number of outputs                            &quot;</span></span>
<span id="cb82-236"><a href="#cb82-236"></a>      (withMaxSuccess <span class="dv">100</span> prop_pc_num_outputs)</span>
<span id="cb82-237"><a href="#cb82-237"></a>    , testProperty <span class="st">&quot;PC   right unit impulse response                        &quot;</span></span>
<span id="cb82-238"><a href="#cb82-238"></a>      (withMaxSuccess <span class="dv">100</span> prop_pc_fir_response)</span>
<span id="cb82-239"><a href="#cb82-239"></a>    , testProperty <span class="st">&quot;PC   legal value range                                  &quot;</span></span>
<span id="cb82-240"><a href="#cb82-240"></a>      (withMaxSuccess <span class="dv">200</span> prop_pc_value_range)</span>
<span id="cb82-241"><a href="#cb82-241"></a>    , testProperty <span class="st">&quot;CT   both channels have cubes of the same dimensions    &quot;</span></span>
<span id="cb82-242"><a href="#cb82-242"></a>      (withMaxSuccess <span class="dv">100</span> prop_ct_dimensions)</span>
<span id="cb82-243"><a href="#cb82-243"></a>    , testProperty <span class="st">&quot;DFB  right number of outputs                            &quot;</span></span>
<span id="cb82-244"><a href="#cb82-244"></a>      (withMaxSuccess <span class="dv">100</span> prop_dfb_num_outputs)</span>
<span id="cb82-245"><a href="#cb82-245"></a>    , testProperty <span class="st">&quot;CFAR right number of outputs                            &quot;</span></span>
<span id="cb82-246"><a href="#cb82-246"></a>      (withMaxSuccess <span class="dv">100</span> prop_cfar_num_outputs)</span>
<span id="cb82-247"><a href="#cb82-247"></a>    , testProperty <span class="st">&quot;INT  right unit impulse response                        &quot;</span></span>
<span id="cb82-248"><a href="#cb82-248"></a>      (withMaxSuccess  <span class="dv">70</span> prop_int_fir_response)</span>
<span id="cb82-249"><a href="#cb82-249"></a>    ]</span>
<span id="cb82-250"><a href="#cb82-250"></a>  ]</span></code></pre></div>
<div class="sourceCode" id="cb83" data-startFrom="252"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 251;"><span id="cb83-252"><a href="#cb83-252"></a><span class="ot">main ::</span> <span class="dt">IO</span>()</span>
<span id="cb83-253"><a href="#cb83-253"></a>main <span class="ot">=</span> defaultMain tests</span></code></pre></div>
<h3 data-number="5.2.4" id="sec:prop-gens"><span class="header-section-number">5.2.4</span> Data Generators</h3>
<p>The data generators used to formulate pre-conditions in this section, as well as a couple of utility functions are defined in this in-house module found at <code>aesa-atom/tests</code>. The documentation for each function is provided as in-line comments.</p>
<div class="sourceCode" id="cb84" data-startFrom="8"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 7;"><span id="cb84-8"><a href="#cb84-8"></a><span class="kw">module</span> <span class="dt">Generators</span> <span class="kw">where</span></span>
<span id="cb84-9"><a href="#cb84-9"></a></span>
<span id="cb84-10"><a href="#cb84-10"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb84-11"><a href="#cb84-11"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb84-12"><a href="#cb84-12"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a>  <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb84-13"><a href="#cb84-13"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">ForSyDe.Atom.MoC.SDF</span></a> <span class="kw">as</span> <span class="dt">SDF</span></span>
<span id="cb84-14"><a href="#cb84-14"></a><span class="kw">import</span> <span class="kw">qualified</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.Matrix</span></a> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb84-15"><a href="#cb84-15"></a><span class="kw">import</span> <span class="kw">qualified</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Cube.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.Cube</span></a> <span class="kw">as</span> <span class="dt">C</span></span>
<span id="cb84-16"><a href="#cb84-16"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-Stream.html"><span class="dt">ForSyDe.Atom.MoC.Stream</span></a></span>
<span id="cb84-17"><a href="#cb84-17"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span>
<span id="cb84-18"><a href="#cb84-18"></a><span class="kw">import</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></span></code></pre></div>
<div class="sourceCode" id="cb85" data-startFrom="20"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 19;"><span id="cb85-20"><a href="#cb85-20"></a><span class="co">-- | Generator for complex numbers within the range $[-1-i,1+i)$</span></span>
<span id="cb85-21"><a href="#cb85-21"></a><span class="ot">decimalCpxNum ::</span> <span class="dt">Gen</span> (<span class="dt">Complex</span> <span class="dt">Float</span>)</span>
<span id="cb85-22"><a href="#cb85-22"></a>decimalCpxNum <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb85-23"><a href="#cb85-23"></a>  realPart <span class="ot">&lt;-</span> choose (<span class="op">-</span><span class="dv">1</span>,<span class="fl">0.99999999999</span>)</span>
<span id="cb85-24"><a href="#cb85-24"></a>  imagPart <span class="ot">&lt;-</span> choose (<span class="op">-</span><span class="dv">1</span>,<span class="fl">0.99999999999</span>)</span>
<span id="cb85-25"><a href="#cb85-25"></a>  <span class="fu">return</span> (realPart <span class="op">:+</span> imagPart)</span></code></pre></div>
<div class="sourceCode" id="cb86" data-startFrom="28"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 27;"><span id="cb86-28"><a href="#cb86-28"></a><span class="co">-- | Generates non-null vectors, i.e. which satisfy &#39;forall v . length v &gt; 0&#39;.</span></span>
<span id="cb86-29"><a href="#cb86-29"></a><span class="ot">nonNullVector ::</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Vector</span> a)</span>
<span id="cb86-30"><a href="#cb86-30"></a>nonNullVector a <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb86-31"><a href="#cb86-31"></a>  ld <span class="ot">&lt;-</span> listOf a <span class="ot">`suchThat`</span> (<span class="fu">not</span> <span class="op">.</span> L.null)</span>
<span id="cb86-32"><a href="#cb86-32"></a>  <span class="fu">return</span> <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.vector</a> ld </span></code></pre></div>
<div class="sourceCode" id="cb87" data-startFrom="34"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 33;"><span id="cb87-34"><a href="#cb87-34"></a><span class="co">-- | Generator for vector of fixed size.</span></span>
<span id="cb87-35"><a href="#cb87-35"></a><span class="ot">sizedVector ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Vector</span> a)</span>
<span id="cb87-36"><a href="#cb87-36"></a>sizedVector n a <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb87-37"><a href="#cb87-37"></a>  v <span class="ot">&lt;-</span> QC.vectorOf n a</span>
<span id="cb87-38"><a href="#cb87-38"></a>  <span class="fu">return</span> <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.vector</a> v</span></code></pre></div>
<div class="sourceCode" id="cb88" data-startFrom="40"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 39;"><span id="cb88-40"><a href="#cb88-40"></a><span class="co">-- | Generator for cube of fixed size.</span></span>
<span id="cb88-41"><a href="#cb88-41"></a><span class="ot">sizedCube ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">C.Cube</span> a)</span>
<span id="cb88-42"><a href="#cb88-42"></a>sizedCube z y x  <span class="ot">=</span> sizedVector z <span class="op">.</span> sizedVector y <span class="op">.</span> sizedVector x</span></code></pre></div>
<div class="sourceCode" id="cb89" data-startFrom="44"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 43;"><span id="cb89-44"><a href="#cb89-44"></a><span class="co">-- | Generator for a SY signal</span></span>
<span id="cb89-45"><a href="#cb89-45"></a><span class="ot">sigOfSmallCubes ::</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> (<span class="dt">C.Cube</span> a))</span>
<span id="cb89-46"><a href="#cb89-46"></a>sigOfSmallCubes g <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb89-47"><a href="#cb89-47"></a>  x <span class="ot">&lt;-</span> choose (<span class="dv">2</span>, <span class="dv">20</span>)  <span class="co">-- do not choose too large dimensions otherwise</span></span>
<span id="cb89-48"><a href="#cb89-48"></a>  y <span class="ot">&lt;-</span> choose (<span class="dv">2</span>, <span class="dv">20</span>)  <span class="co">-- the tests will take too long... small tests are</span></span>
<span id="cb89-49"><a href="#cb89-49"></a>  z <span class="ot">&lt;-</span> choose (<span class="dv">2</span>, <span class="dv">20</span>)  <span class="co">-- good enough   </span></span>
<span id="cb89-50"><a href="#cb89-50"></a>  sigData <span class="ot">&lt;-</span> listOf1 <span class="op">$</span> sizedCube z y x g</span>
<span id="cb89-51"><a href="#cb89-51"></a>  <span class="fu">return</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(SY.signal</a> sigData)</span></code></pre></div>
<div class="sourceCode" id="cb90" data-startFrom="53"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 52;"><span id="cb90-53"><a href="#cb90-53"></a><span class="co">-- | Generator for an impulse signal of (small) cubes:</span></span>
<span id="cb90-54"><a href="#cb90-54"></a><span class="ot">impulseSigOfCubes ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> (<span class="dt">C.Cube</span> <span class="dt">Int</span>))</span>
<span id="cb90-55"><a href="#cb90-55"></a>impulseSigOfCubes n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb90-56"><a href="#cb90-56"></a>  x <span class="ot">&lt;-</span> choose (<span class="dv">2</span>, <span class="dv">20</span>)  <span class="co">-- do not choose too large dimensions otherwise</span></span>
<span id="cb90-57"><a href="#cb90-57"></a>  y <span class="ot">&lt;-</span> choose (<span class="dv">2</span>, <span class="dv">20</span>)  <span class="co">-- the tests will take too long... small tests are</span></span>
<span id="cb90-58"><a href="#cb90-58"></a>  z <span class="ot">&lt;-</span> choose (<span class="dv">2</span>, <span class="dv">20</span>)  <span class="co">-- good enough</span></span>
<span id="cb90-59"><a href="#cb90-59"></a>  impulse <span class="ot">&lt;-</span> sizedCube z y x <span class="op">$</span> elements [<span class="dv">1</span>] </span>
<span id="cb90-60"><a href="#cb90-60"></a>  trail   <span class="ot">&lt;-</span> sizedCube z y x <span class="op">$</span> elements [<span class="dv">0</span>]</span>
<span id="cb90-61"><a href="#cb90-61"></a>  <span class="fu">return</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(SY.signal</a> (impulse <span class="op">:</span> <span class="fu">replicate</span> n trail))</span></code></pre></div>
<div class="sourceCode" id="cb91" data-startFrom="63"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 62;"><span id="cb91-63"><a href="#cb91-63"></a><span class="co">-- | The default &#39;Arbitrary&#39; instance for the different ForSyDe-Atom types used in</span></span>
<span id="cb91-64"><a href="#cb91-64"></a><span class="co">-- the report.</span></span>
<span id="cb91-65"><a href="#cb91-65"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(<span class="dt">V.Vector</span></a> a) <span class="kw">where</span></span>
<span id="cb91-66"><a href="#cb91-66"></a>  arbitrary <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb91-67"><a href="#cb91-67"></a>    x <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb91-68"><a href="#cb91-68"></a>    <span class="fu">return</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.vector</a> x)</span>
<span id="cb91-69"><a href="#cb91-69"></a></span>
<span id="cb91-70"><a href="#cb91-70"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Stream</span> a) <span class="kw">where</span></span>
<span id="cb91-71"><a href="#cb91-71"></a>  arbitrary <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb91-72"><a href="#cb91-72"></a>    x <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb91-73"><a href="#cb91-73"></a>    <span class="fu">return</span> (stream x)</span>
<span id="cb91-74"><a href="#cb91-74"></a></span>
<span id="cb91-75"><a href="#cb91-75"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.SY</span></a> a) <span class="kw">where</span></span>
<span id="cb91-76"><a href="#cb91-76"></a>  arbitrary <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb91-77"><a href="#cb91-77"></a>    x <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb91-78"><a href="#cb91-78"></a>    <span class="fu">return</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.SY</span></a> x)</span>
<span id="cb91-79"><a href="#cb91-79"></a>    </span>
<span id="cb91-80"><a href="#cb91-80"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.SDF</span></a> a) <span class="kw">where</span></span>
<span id="cb91-81"><a href="#cb91-81"></a>  arbitrary <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb91-82"><a href="#cb91-82"></a>    x <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb91-83"><a href="#cb91-83"></a>    <span class="fu">return</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.SDF</span></a> x)</span></code></pre></div>
<div class="sourceCode" id="cb92" data-startFrom="85"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 84;"><span id="cb92-85"><a href="#cb92-85"></a><span class="co">-- | Utility which tests whether a complex number is within the range $[-1-i,1+i)$</span></span>
<span id="cb92-86"><a href="#cb92-86"></a><span class="ot">withinRangeComplex ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Complex</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb92-87"><a href="#cb92-87"></a>withinRangeComplex a b c</span>
<span id="cb92-88"><a href="#cb92-88"></a>  <span class="op">|</span> realPart c <span class="op">&lt;</span>  a <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb92-89"><a href="#cb92-89"></a>  <span class="op">|</span> imagPart c <span class="op">&lt;</span>  a <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb92-90"><a href="#cb92-90"></a>  <span class="op">|</span> realPart c <span class="op">&gt;=</span> b <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb92-91"><a href="#cb92-91"></a>  <span class="op">|</span> imagPart c <span class="op">&gt;=</span> b <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb92-92"><a href="#cb92-92"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<h2 data-number="5.3" id="running-the-test-suite.-conclusion"><span class="header-section-number">5.3</span> Running the Test Suite. Conclusion</h2>
<p>The file shown in section <a href="#sec:prop-defs">5.2</a> can be compiled using any means available. We have included it as a test suite for the <code>aesa-atom</code> package. Please refer to the package’s <code>README</code> file for instructions on how to compile an run the tools.</p>
<p>As expected (in a public report) the test suite output looks like below:</p>
<pre><code>aesa-atom-0.1.0.0: test (suite: tests-cube)

 Cube HL Model Tests :
  GENERIC farm does not alter the input structure         : [OK, passed 100 tests]
  DBF  right number of outputs                            : [OK, passed 100 tests]
  DBF  legal value range                                  : [OK, passed 200 tests]
  DBF  equivalence with simple dot product operation      : [OK, passed 200 tests]
  PC   right number of outputs                            : [OK, passed 100 tests]
  PC   right unit impulse response                        : [OK, passed 100 tests]
  PC   legal value range                                  : [OK, passed 200 tests]
  CT   both channels have cubes of the same dimensions    : [OK, passed 100 tests]
  DFB  right number of outputs                            : [OK, passed 100 tests]
  CFAR right number of outputs                            : [OK, passed 100 tests]
  INT  right unit impulse response                        : [OK, passed 70 tests]

         Properties   Total       
 Passed  11           11          
 Failed  0            0           
 Total   11           11          

aesa-atom-0.1.0.0: Test suite tests-cube passed
</code></pre>
<p>However it should not be taken for granted that during the development process the printed output is <em>this</em> flawless. As mentioned in this section’s introduction, like any other software project, a ForSyDe model grows organically with consecutive iterations between system specification and model implementation, often held accountable by different parties or groups. Along with traditional unit tests (not covered by this report), property checking is a powerful tool which shortens these iteration cycles by setting a formal “legal frame” within which each (sub-)component in a a model needs to operate. Apart from helping in understanding the specification better, these properties ensure that further in the refinement process we do not mistakenly introduce new flaws. This will be demonstrated in the next sections.</p>
<h1 data-number="6" id="sec:refine"><span class="header-section-number">6</span> Refining the Model Behavior. A Streaming Interpretation of AESA</h1>
<blockquote>
<p><em>In this section we refine the behavior of the high-level AESA model presented in section <a href="#sec:atom">2</a> focusing on a more fine-grained timed (i.e. streaming) aspects of the computation. We do this in an attempt to expose the inherent parallelism of the AESA application, by describing it as parallel networks of concurrent, independent processes operating on streaming elements rather than monolithic blocks operating on cubes. This perspective should pave the way for a more efficient exploration of the available design space in future refinement decisions. We present an alternative streaming-oriented model of the AESA system, validate it against test data and verify the properties previously formulated.</em></p>
</blockquote>
<table>
<tbody>
<tr class="odd">
<td>Package</td>
<td>aesa-atom-0.1.0</td>
<td>path: <code>./aesa-atom/README.md</code></td>
</tr>
<tr class="even">
<td>Deps</td>
<td>forsyde-atom-0.3.1</td>
<td>url: <code>https://forsyde.github.io/forsyde-atom/api/</code></td>
</tr>
<tr class="odd">
<td></td>
<td>QuickCheck-2.13.1</td>
<td>url: <code>http://hackage.haskell.org/package/QuickCheck</code></td>
</tr>
<tr class="even">
<td>Suite</td>
<td>tests-stream</td>
<td>usage: <code>stack test :tests-stream</code></td>
</tr>
<tr class="odd">
<td>Bin</td>
<td>aesa-stream</td>
<td>usage: <code>aesa-stream --help</code></td>
</tr>
</tbody>
</table>
<p>The high-level behavioral model of the AESA signal processing chain presented in this section is semantically equivalent to the one presented in section <a href="#sec:atom">2</a>, however it exposes a more fine-grained temporal behavior of the individual operations performed on the complex indata samples. While most design choices are driven by a didactic purpose to consolidate the new modeling concepts presented in section <a href="#sec:crash-atom">2.1</a>, they can also be justified by the need to capture the essential properties in a formal way, in order to be exploitable in future stages of a design flow towards efficient implementations. The main design approach is to exploit the relative independence between each data path associated with each antenna element or beam, and to model these paths as skeletons (e.g. farms) of (chains of) processes. Each design decision will infer a re-partitioning of the indata cubes between the time (i.e. causality) and space dimensions following the design patters depicted earlier in Figure <a href="#fig:atom-layers">3</a>, namely:</p>
<ul>
<li><p><em>skeletons of processes</em> which: 1) express parallelism at the process level; 2) depicts processes as operating on elementary streams of data, e.g. originating from each antenna element in particular, and skeletons as the structured interactions between these streams; 3) expose a fine-grained modular view allowing to quantify the potential for <em>load distribution</em>, since each “operation” (i.e. process) clearly captures the aspect of precedence constraints.</p></li>
<li><p><em>process of skeletons</em> which : 1) express parallelism at the datum level; 2) depicts processes as operating on structures of data (e.g. vectors, matrices or cubes); 3) expose a monolithic view of processes where precedence constraints are expressed “outside” of the algorithm, and where the algorithm itself expresses potential for <em>data parallelism</em>.</p></li>
</ul>
<h2 data-number="6.1" id="sec:atom-network"><span class="header-section-number">6.1</span> The High-Level Model</h2>
<p>The code for this section is written in the following module, see section <a href="#sec:usage">1.2</a> on how to use it:</p>
<div class="sourceCode" id="cb94" data-startFrom="7"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 6;"><span id="cb94-7"><a href="#cb94-7"></a><span class="kw">module</span> <span class="dt">AESA.StreamsAtom</span> <span class="kw">where</span></span></code></pre></div>
<h3 data-number="6.1.1" id="libraries-and-aliases"><span class="header-section-number">6.1.1</span> Libraries and Aliases</h3>
<p>We import exactly the same libraries as in section <a href="#sec:cube-atom-operation">2.2</a>, so we don’t need to explain what each one does. However, in this model we introduce a new MoC. For describing streaming behavior of the application our design will use a heterogeneous approach, using a combination of <em>synchronous reactive (SY)</em> processes <span class="citation" data-cites="leeseshia-15 Benveniste03">(Edward A. Lee and Seshia <a href="#ref-leeseshia-15" role="doc-biblioref">2016</a>; Benveniste et al. <a href="#ref-Benveniste03" role="doc-biblioref">2003</a>)</span>, where the main assumption is that all events in the system are synchronized; and <em>synchronous data flow (SDF)</em> processes <span class="citation" data-cites="leeseshia-15 lee95">(Edward A. Lee and Seshia <a href="#ref-leeseshia-15" role="doc-biblioref">2016</a>; Lee and Parks <a href="#ref-lee95" role="doc-biblioref">1995</a>)</span>, where the temporal behavior is formulated in terms of partial order constraints between events. We also use the Boolean dataflow model, which is an extension to SDF to allow for dynamic behaviors <span class="citation" data-cites="buck93">(Buck and Lee <a href="#ref-buck93" role="doc-biblioref">1993</a>)</span>. We import the <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>SY</code></a>, <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><code>SDF</code></a> and <code>BDF</code> libraries described in the <em><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC.html">MoC</a> layer</em>, see <span class="citation" data-cites="ungureanu17">(Ungureanu and Sander <a href="#ref-ungureanu17" role="doc-biblioref">2017</a>)</span>, using an appropriate alias for each.</p>
<div class="sourceCode" id="cb95" data-startFrom="26"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 25;"><span id="cb95-26"><a href="#cb95-26"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a>                 <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb95-27"><a href="#cb95-27"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">ForSyDe.Atom.MoC.SDF</span></a>                <span class="kw">as</span> <span class="dt">SDF</span></span>
<span id="cb95-28"><a href="#cb95-28"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF-BDF.html"><span class="dt">ForSyDe.Atom.MoC.SDF.BDF</span></a>            <span class="kw">as</span> <span class="dt">BDF</span></span>
<span id="cb95-29"><a href="#cb95-29"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a>        <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb95-30"><a href="#cb95-30"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.Matrix</span></a> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb95-31"><a href="#cb95-31"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.DSP</span></a></span>
<span id="cb95-32"><a href="#cb95-32"></a><span class="kw">import</span> <span class="dt">AESA.Coefs</span></span>
<span id="cb95-33"><a href="#cb95-33"></a><span class="kw">import</span> <span class="dt">AESA.Params</span></span>
<span id="cb95-34"><a href="#cb95-34"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span></code></pre></div>
<div class="sourceCode" id="cb96" data-startFrom="36"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 35;"><span id="cb96-36"><a href="#cb96-36"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">AESA.CubesAtom</span> <span class="kw">as</span> <span class="dt">CAESA</span></span></code></pre></div>
<p>We use the same internal aliases to name the different types employed in this model:</p>
<div class="sourceCode" id="cb97" data-startFrom="40"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 39;"><span id="cb97-40"><a href="#cb97-40"></a><span class="kw">type</span> <span class="dt">Antenna</span>  <span class="ot">=</span> <span class="dt">Vector</span> <span class="co">-- length: nA</span></span>
<span id="cb97-41"><a href="#cb97-41"></a><span class="kw">type</span> <span class="dt">Beam</span>     <span class="ot">=</span> <span class="dt">Vector</span> <span class="co">-- length: nB</span></span>
<span id="cb97-42"><a href="#cb97-42"></a><span class="kw">type</span> <span class="dt">Range</span>    <span class="ot">=</span> <span class="dt">Vector</span> <span class="co">-- length: nb</span></span>
<span id="cb97-43"><a href="#cb97-43"></a><span class="kw">type</span> <span class="dt">Window</span>   <span class="ot">=</span> <span class="dt">Vector</span> <span class="co">-- length: nFFT</span></span>
<span id="cb97-44"><a href="#cb97-44"></a><span class="kw">type</span> <span class="dt">CpxData</span>  <span class="ot">=</span> <span class="dt">Complex</span> <span class="dt">Float</span></span>
<span id="cb97-45"><a href="#cb97-45"></a><span class="kw">type</span> <span class="dt">RealData</span> <span class="ot">=</span> <span class="dt">Float</span></span></code></pre></div>
<h3 data-number="6.1.2" id="video-processing-stages"><span class="header-section-number">6.1.2</span> Video Processing Stages</h3>
<p>In this section we follow each stage earlier described in described in section <a href="#sec:cube-atom-operation">2.2</a>, and exploit the initial assumption on the order of events stating: <em>“For each antenna the data arrives <em>pulse by pulse</em>, and each pulse arrives <em>range bin by range bin</em>. This happens <em>for all antennas in parallel</em>, and all complex samples are synchronized with the same sampling rate, e.g. of the A/D converter.”</em></p>
<p>This allows us to “unroll” the indata video cubes into <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>A</mi></msub><annotation encoding="application/x-tex">N_A</annotation></semantics></math> parallel synchronous streams, each stream being able to be processed as soon as it contains enough data. This unrolling is depicted in Figure <a href="#fig:cube-unrolling">26</a> as streaming the pulses as soon as they arrive: range bin by range bin. We say that we partition the data <em>in time</em> rather than <em>in space</em>, which is a more appropriate partition judging by the assumption above.</p>
<figure>
<img src="figs/cube-unrolling.png" id="fig:cube-unrolling" alt="" /><figcaption>Figure 26: Video cube unrolling</figcaption>
</figure>
<h4 data-number="6.1.2.1" id="sec:dbf-atom"><span class="header-section-number">6.1.2.1</span> Digital Beamforming (DBF)</h4>
<p>The role of the DBF stage is explained in section <a href="#sec:cube-dbf-atom">2.2.2.1</a>. Depicted from a streaming point of view, DBF would like in Figure <a href="#fig:dbf-samp">27</a>.</p>
<figure>
<img src="figs/dbf-samp.png" id="fig:dbf-samp" alt="" /><figcaption>Figure 27: Digital Beam Forming on streams of complex samples</figcaption>
</figure>
<p>As can be seen in Figure <a href="#fig:dbf-samp">27</a>, a beam can be formed <em>as soon as</em> all antennas have produced a complex sample. The parallel streams of data coming from each antenna element are represented as a <em>vector of synchronous (SY) signals</em>, i.e. vector of signals where each event is synchronous with each other. This allows us to depict the dataflow interaction between the streams during digital beamforming as the process network in Figure <a href="#fig:dbf-net-atom">28</a>, where an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊕</mo><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> represents a combinational process <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC.html#v:comb22"><code>comb</code></a>.</p>
<figure>
<img src="figs/dbf-net-atom.png" id="fig:dbf-net-atom" alt="" /><figcaption>Figure 28: DBF network</figcaption>
</figure>
<div class="sourceCode" id="cb98" data-startFrom="82"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 81;"><span id="cb98-82"><a href="#cb98-82"></a><span class="ot">dbf ::</span> <span class="dt">Antenna</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> <span class="dt">CpxData</span>)</span>
<span id="cb98-83"><a href="#cb98-83"></a>    <span class="ot">-&gt;</span> <span class="dt">Beam</span>    <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> <span class="dt">CpxData</span>)</span>
<span id="cb98-84"><a href="#cb98-84"></a>dbf antennaSigs <span class="ot">=</span> beamSigs</span>
<span id="cb98-85"><a href="#cb98-85"></a>  <span class="kw">where</span></span>
<span id="cb98-86"><a href="#cb98-86"></a>    beamSigs   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.reduce</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.farm21</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(SY.comb21</a> (<span class="op">+</span>))) beamMatrix</span>
<span id="cb98-87"><a href="#cb98-87"></a>    beamMatrix <span class="ot">=</span> M.farm21 (\c <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> (<span class="op">*</span>c)) beamConsts sigMatrix</span>
<span id="cb98-88"><a href="#cb98-88"></a>    sigMatrix  <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fanout</a> antennaSigs</span>
<span id="cb98-89"><a href="#cb98-89"></a>    beamConsts <span class="ot">=</span> mkBeamConsts dElements waveLength nA<span class="ot"> nB ::</span> <span class="dt">Matrix</span> <span class="dt">CpxData</span></span></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>farm11</code>, <code>reduce</code>, <code>length</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>farm21</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><code>ForSyDe.Atom.Skel.FastVector.Matrix</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>comb11</code>, <code>comb21</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>ForSyDe.Atom.MoC.SY</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>mkBeamConsts</code></td>
<td><code>AESA.Coefs</code></td>
<td>aesa-atom</td>
</tr>
<tr class="odd">
<td><code>dElements</code>, <code>waveLength</code>, <code>nA</code>, <code>nB</code></td>
<td><code>AESA.Params</code></td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<p>The previous code listing, depicted in Figure <a href="#fig:dbf-net-atom">28</a>, is actually showing the <em>exact same</em> “internals” as the vector-matrix dot product presented in section <a href="#sec:cube-dbf-atom">2.2.2.1</a>. However, the elementary operations, instead of regular arithmetic operations <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>×</mo><annotation encoding="application/x-tex">\times</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>, are <em>processes</em> applying these operations on SY streams. As such, the <code>fanout</code> skeleton distributes one signal to a whole row (i.e. vector) of processes, the matrix <code>farm</code> applies pair-wise a matrix of partially applied processes on this matrix of signals, and <code>reduce</code> creates a reduction network of binary processes pair-wise applying the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math> on all events in signals. Practically the DBF network transforms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>A</mi></msub><annotation encoding="application/x-tex">N_A</annotation></semantics></math> synchronous signals originating from each antenna element into <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>B</mi></msub><annotation encoding="application/x-tex">N_B</annotation></semantics></math> synchronous signals for each beam. The internal structure of this transformation exposes multiple degrees of potential distribution on parallel synchronous resources.</p>
<h4 data-number="6.1.2.2" id="sec:pc-atom"><span class="header-section-number">6.1.2.2</span> Pulse Compression (PC)</h4>
<p>The role of the DBF stage is explained in section <a href="#sec:cube-pc-atom">2.2.2.2</a>. The sliding window, or moving average (MAV), is now applied on the range bin samples in the order of their arrival.</p>
<figure>
<img src="figs/pc-samp.png" id="fig:pc-samp" alt="" /><figcaption>Figure 29: Pulse Compression on streams of complex samples</figcaption>
</figure>
<p>In Figure <a href="#fig:pc-samp">29</a> we can see that, in order to apply the MAV algorithm on all the range bins of every pulse, we need to accumulate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>b</mi></msub><annotation encoding="application/x-tex">N_b</annotation></semantics></math> samples and process them in batches. Intuitively this can be done by processing each beam with a <em>synchronous dataflow</em> (SDF) actor which, with each firing, consumes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>b</mi></msub><annotation encoding="application/x-tex">N_b</annotation></semantics></math> samples and produces <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>b</mi></msub><annotation encoding="application/x-tex">N_b</annotation></semantics></math> samples. Note that at this stage of modeling we value intuition and the capturing of the right application properties rather than target implementation efficiency. We will tackle this problem later in the design stages (see section <a href="#sec:synth">7</a>) where we will try to transform the model toward more efficient implementation models (with respect to some constraint, e.g. throughput) which preserve these behavioral properties.</p>
<div class="sourceCode" id="cb99" data-startFrom="131"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 130;"><span id="cb99-131"><a href="#cb99-131"></a><span class="ot">pc ::</span> <span class="dt">Beam</span> ( <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> <span class="dt">CpxData</span>)</span>
<span id="cb99-132"><a href="#cb99-132"></a>   <span class="ot">-&gt;</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> <span class="dt">CpxData</span>)</span>
<span id="cb99-133"><a href="#cb99-133"></a>pc <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> (procPC <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.toSDF1)</a></span></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>farm11</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>toSDF1</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>ForSyDe.Atom.MoC.SY</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>comb11</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><code>ForSyDe.Atom.MoC.SDF</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>fir</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><code>ForSyDe.Atom.Skel.FastVector.DSP</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>mkPcCoefs</code></td>
<td><code>AESA.Coefs</code></td>
<td>aesa-atom</td>
</tr>
<tr class="even">
<td><code>nb</code></td>
<td><code>AESA.Params</code></td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<figure>
<img src="figs/pc-proc-atom.png" id="fig:pc-proc-atom" alt="" /><figcaption>Figure 30: PC stage process</figcaption>
</figure>
<p>Following the reasoning above, we instantiate the PC video processing stage as a <code>farm</code> of SDF processes <code>procPC</code> as depicted in Figure <a href="#fig:pc-proc-atom">30</a>. Notice that before being able to apply the SDF actors we need to translate the SY signals yielded by the DBF stage into SDF signals. This is done by the <code>toSDF</code> interface which is an injective mapping from the (timed) domain of a SY MoC tag system, to the (untimed) co-domain of a SDF MoC tag system. For more on tag systems please consult <span class="citation" data-cites="lee98">(Lee and Sangiovanni-Vincentelli <a href="#ref-lee98" role="doc-biblioref">1998</a>)</span>.</p>
<div class="sourceCode" id="cb100" data-startFrom="153"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 152;"><span id="cb100-153"><a href="#cb100-153"></a><span class="ot">procPC ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">SDF.Signal</span></a> a <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">SDF.Signal</span></a> a </span>
<span id="cb100-154"><a href="#cb100-154"></a>procPC <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.actor11</a> (nb, nb, <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector</a> <span class="op">.</span> fir (mkPcCoefs pcTap) <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.vector)</a></span></code></pre></div>
<p>The <code>procPC</code> actor consumes and produces <code>nb</code> tokens each firing, forms a <code>Vector</code> from these tokens, and applies the same <code>fir</code> function used in section <a href="#sec:cube-pc-atom">2.2.2.2</a> on these vectors. Also notice that the type signature for <code>procPC</code> is left polymorphic as to be more convenient later when we formulate properties over it.</p>
<h4 data-number="6.1.2.3" id="sec:ct-atom"><span class="header-section-number">6.1.2.3</span> Corner Turn (CT) with 50% overlap</h4>
<p>The role of the CT stage is explained in section <a href="#sec:cube-ct-atom">2.2.2.3</a>. In this model we make use of the knowledge that for each beam sample arrives in order, one range bin at a time, in the direction of consumption suggested in Figure <a href="#fig:ct-samp">31</a>, and “fill back in” the video cube in the direction of production. In order to maximize the efficiency of the AESA processing the datapath is split into two concurrent processing channels with 50% overlapped data, as shown in Figure <a href="#fig:cube-ct-cube">7</a> from section <a href="#sec:cube-ct-atom">2.2.2.3</a>.</p>
<figure>
<img src="figs/ct-samp.png" id="fig:ct-samp" alt="" /><figcaption>Figure 31: Building matrices of complex samples during CT</figcaption>
</figure>
<!-- ![Concurrent processing on 50% overlapped data](figs/ct-cube.pdf){#fig:ct-cube}  -->
<div class="sourceCode" id="cb101" data-startFrom="174"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 173;"><span id="cb101-174"><a href="#cb101-174"></a><span class="ot">ct ::</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> <span class="dt">CpxData</span>)</span>
<span id="cb101-175"><a href="#cb101-175"></a>   <span class="ot">-&gt;</span> (<span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> <span class="dt">CpxData</span>),</span>
<span id="cb101-176"><a href="#cb101-176"></a>       <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> <span class="dt">CpxData</span>))</span>
<span id="cb101-177"><a href="#cb101-177"></a>ct <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm12</a> procCT</span></code></pre></div>
<p>Our CT network thus maps on each beam signal a corner turn process which, under the SDF execution semantics, consumes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>×</mo><msub><mi>N</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">N_{FFT}\times N_b</annotation></semantics></math> ordered samples, interprets them as a matrix, transposes this matrix, and produces <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub><mo>×</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub></mrow><annotation encoding="application/x-tex">N_b\times N_{FFT}</annotation></semantics></math> samples ordered in the direction suggested in Figure <a href="#fig:ct-samp">31</a>.</p>
<div class="sourceCode" id="cb102" data-startFrom="184"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 183;"><span id="cb102-184"><a href="#cb102-184"></a><span class="ot">procCT ::</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">SDF.Signal</span></a> a <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> a, <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">SDF.Signal</span></a> a)</span>
<span id="cb102-185"><a href="#cb102-185"></a>procCT sig <span class="ot">=</span> (corner rightCh, corner leftCh)</span>
<span id="cb102-186"><a href="#cb102-186"></a>  <span class="kw">where</span></span>
<span id="cb102-187"><a href="#cb102-187"></a>    leftCh      <span class="ot">=</span> sig</span>
<span id="cb102-188"><a href="#cb102-188"></a>    (_,rightCh) <span class="ot">=</span> BDF.bSwitch <span class="dv">1</span> selectSig sig</span>
<span id="cb102-189"><a href="#cb102-189"></a>    selectSig   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.delay</a> (<span class="fu">replicate</span> (nb <span class="op">*</span> nFFT <span class="ot">`div`</span> <span class="dv">2</span>) <span class="dt">False</span>)</span>
<span id="cb102-190"><a href="#cb102-190"></a>                  <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.constant1</a> [<span class="dt">True</span>]</span>
<span id="cb102-191"><a href="#cb102-191"></a>    corner      <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.actor11</a> (nFFT <span class="op">*</span> nb, nb <span class="op">*</span> nFFT,</span>
<span id="cb102-192"><a href="#cb102-192"></a>                              fromMatrix <span class="op">.</span> M.transpose <span class="op">.</span> matrix nb nFFT)</span></code></pre></div>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 47%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>farm12</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td>(<code>from</code>-)<code>matrix</code>, <code>transpose</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><code>ForSyDe.Atom.Skel.FastVector.Matrix</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>comb11</code>, <code>delay</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><code>ForSyDe.Atom.MoC.SDF</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>nb</code>, <code>nFFT</code></td>
<td><code>AESA.Params</code></td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<p>Recall that, in order to achieve 50% overlapping between the two output channels, in the initial high-level model in section <a href="#sec:cube-ct-atom">2.2.2.3</a> we “delayed” the left channel with half a cube of “useless data” which we later ignored in the testbench. While it is possible to do the same trick here, i.e. delay the left channel with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub><mo>×</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N_b \times N_{FFT}/2</annotation></semantics></math> samples per beam, which is the equivalent of half a cube, we agreed upon it being a simulation artifice to avoid undefined behavior, but not really reflecting the target implementation. The end artifact would start streaming the left channels only after the first half cube. We can think of three ways how to model such a behavior <em>without stepping outside the data flow paradigm</em><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>:</p>
<ol type="1">
<li><p>“starting” the <em>entire</em> system (i.e. considering time 0) once we <em>know</em> the values for half a cube. This means that the behavior of the AESA system does not include the acquisition of the first half video cube, which would be described in its <em>history</em> (i.e. initial state, e.g. passed as top-level argument).</p></li>
<li><p><em>using absent semantics</em>, which would be the <em>correct</em> way to define such an abstract behavior, but would render the description of the whole system more complicated, since every block would then need to be aware of the “absence” aspect of computation.</p></li>
<li><p><em>using a dynamic dataflow MoC</em>, which is a bit more risky, because in general most of these MoCs are undecidable and might lead to deadlocks if not used properly, but are less abstract and much closer to what you would expect from a dynamic “start/stop” mechanism.</p></li>
</ol>
<figure>
<img src="figs/ct-net-atom.png" id="fig:ct-net-atom" alt="" /><figcaption>Figure 32: CT network</figcaption>
</figure>
<p>Since we are already considering a refined behavior model of the AESA system, we have chosen the third approach, as hinted in Figure <a href="#fig:ct-net-atom">32</a>. We use the Boolean dataflow (BDF) MoC introduced by <span class="citation" data-cites="buck93">Buck and Lee (<a href="#ref-buck93" role="doc-biblioref">1993</a>)</span> to express the dynamic switching behavior. BDF <em>extends</em> SDF with two actors <code>switch</code> and <code>select</code> which are able to redirect the flow of data to/from separate channels based on an input selection signal carrying Boolean tokens. We use the BDF <code>switch</code> process which uses the <em>hard-coded</em> <code>selectSig</code> signal to redirect the first <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>b</mi></msub><mo>×</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N_b \times N_{FFT}/2</annotation></semantics></math> tokens for each beam (the equivalent of half a cube of indata) to a “null” channel, and only after that to start streaming into the right channel.</p>
<p><strong>OBS:</strong> in general it is advised to <em>avoid</em> BDF, which does not benefit from static analysis methods for schedulability and deadlock detection, in favor of a more analyzable one, such as scenario aware dataflow (SADF) <span class="citation" data-cites="stuijk-2011">(Stuijk et al. <a href="#ref-stuijk-2011" role="doc-biblioref">2011</a>)</span>. However, in our case we base our modeling choice based on the knowledge that, lacking any type of feedback composition, the AESA signal processing system cannot cause any deadlock in any of its possible states. Even so, hard-coding the selection signal can also be considered a safe practice, because it is possible to derive a fixed set of SDF scenarios based on a known reconfiguration stream.</p>
<h4 data-number="6.1.2.4" id="sec:dfb-cfar-atom"><span class="header-section-number">6.1.2.4</span> Doppler Filter Bank (DFB) and Constant False Alarm Ratio (CFAR)</h4>
<p>For these two processing stages presented in sections <a href="#sec:cube-dfb-atom">2.2.2.4</a>, <a href="#sec:cube-cfar-atom">2.2.2.5</a>, we do not change the functional description at all, but rather the granularity of their timed description. We continue to work over the premise that signals are streaming samples of data, which have recently been arranged to arrive in <em>pulse order</em>, as suggested by Figure <a href="#fig:dfb-samp">33</a>. As such, both stages are modeled as farms of SDF processes operating over beam streams, and for each stream they consume the necessary data, apply their (vector) function, and produce their respective data.</p>
<figure>
<img src="figs/dfb-samp.png" id="fig:dfb-samp" alt="" /><figcaption>Figure 33: Doppler Filter Bank on streams of complex samples</figcaption>
</figure>
<figure>
<img src="figs/dfb-cfar-net-atom.png" id="fig:dfb-net-atom" alt="" /><figcaption>Figure 34: DFB + CFAR networks</figcaption>
</figure>
<div class="sourceCode" id="cb103" data-startFrom="269"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 268;"><span id="cb103-269"><a href="#cb103-269"></a><span class="ot">dfb ::</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> <span class="dt">CpxData</span>)</span>
<span id="cb103-270"><a href="#cb103-270"></a>    <span class="ot">-&gt;</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> <span class="dt">RealData</span>)</span>
<span id="cb103-271"><a href="#cb103-271"></a>dfb <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> procDFB</span></code></pre></div>
<div class="sourceCode" id="cb104" data-startFrom="273"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 272;"><span id="cb104-273"><a href="#cb104-273"></a><span class="ot">cfar ::</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> <span class="dt">RealData</span>)</span>
<span id="cb104-274"><a href="#cb104-274"></a>     <span class="ot">-&gt;</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb104-275"><a href="#cb104-275"></a>cfar <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> procCFAR</span></code></pre></div>
<div class="sourceCode" id="cb105" data-startFrom="277"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 276;"><span id="cb105-277"><a href="#cb105-277"></a>procDFB  <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.actor11</a> (nFFT, nFFT, fromVector <span class="op">.</span> CAESA.fDFB <span class="op">.</span> vector)</span>
<span id="cb105-278"><a href="#cb105-278"></a>procCFAR <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.actor11</a> (nb <span class="op">*</span> nFFT, <span class="dv">1</span>, (<span class="op">:</span>[]) <span class="op">.</span> CAESA.fCFAR <span class="op">.</span> M.matrix nFFT nb)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>farm11</code>,(<code>from</code>-)<code>vector</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>matrix</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><code>ForSyDe.Atom.Skel.FastVector.Matrix</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>nb</code>, <code>nFFT</code></td>
<td><code>AESA.Params</code></td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<p>Notice how we reuse the <em>exact same</em> functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>D</mi><mi>F</mi><mi>B</mi></mrow></msub><annotation encoding="application/x-tex">f_{DFB}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>C</mi><mi>F</mi><mi>A</mi><mi>R</mi></mrow></msub><annotation encoding="application/x-tex">f_{CFAR}</annotation></semantics></math> imported from the <code>AESA.CubesAtom</code> previously defined in section <a href="#sec:cube-atom-operation">2.2</a>. This way we are sure that we have not introduced coding errors. Also, notice that after the CFAR process we do not unwrap the matrices any longer, but produce them as <em>individual tokens</em>. This is because the subsequent INT block, as seen in the next paragraph, operates much more efficiently on matrices, and thus we spare some intermediate wrapping/unwrapping.</p>
<p><strong>OBS:</strong> each function composing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>D</mi><mi>F</mi><mi>B</mi></mrow></msub><annotation encoding="application/x-tex">f_{DFB}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>C</mi><mi>F</mi><mi>A</mi><mi>R</mi></mrow></msub><annotation encoding="application/x-tex">f_{CFAR}</annotation></semantics></math> is itself inherently parallel, as it is described in terms of parallel skeletons. We could have “lifted” these skeletons as far as associating a process for each elementary arithmetic operation, following the example set by the DBF network in section <a href="#sec:dbf-atom">6.1.2.1</a>. The two representations (if carefully modeled) are semantically equivalent and, thanks to the chosen formal description, can be transformed (ideally being aided by a computer/tool in the future) from one to another. In fact there are multiple degrees of freedom to partition the application on the time/space domains, thus a particular representation should be chosen in order to be more appropriate to the target platform model. However in this report we are not planning to refine these blocks even further, so for the purpose of simulation and visualization, this abstraction level is good enough for now. The skeleton lifting to the process network level is left as an exercise for the reader. The interested reader is also recommended to read the skeletons chapter in the technical manual <span class="citation" data-cites="atom-manual">(Ungureanu <a href="#ref-atom-manual" role="doc-biblioref">2018</a>)</span> to see how the <code>fft</code> skeleton used in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mrow><mi>D</mi><mi>F</mi><mi>B</mi></mrow></msub><annotation encoding="application/x-tex">f_{DFB}</annotation></semantics></math> is defined, and how it behaves during different instantiations, as network of processes or as function.</p>
<h4 data-number="6.1.2.5" id="sec:int-atom"><span class="header-section-number">6.1.2.5</span> Integrator (INT)</h4>
<p>During the last stage of the video processing chain each data sample of the video cube is integrated against its 8 previous values using an 8-tap FIR filter.</p>
<figure>
<img src="figs/int-cube.png" id="fig:int-cube-atom" alt="" /><figcaption>Figure 35: Integration on cubes of complex samples</figcaption>
</figure>
<p>The integration, re-drawn in Figure <a href="#fig:int-cube-atom">35</a>, like each stage until now, can be modeled in different ways based on how the designer envisions the partitioning of the data “in time” or “in space”. This partitioning could be as coarse-grained as streams of cubes of samples, or as fine-grained as networks of streams of individual samples. For convenience and for simulation efficiency<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> we choose a middle approach: video cubes are represented as farms (i.e. vectors) of streams of matrices, as conveniently bundled by the previous DFB stages. We pass the responsibility of re-partitioning and interpreting the data accordingly to the downstream process, e.g. a control/monitoring system, or a testbench sink.</p>
<div class="sourceCode" id="cb106" data-startFrom="328"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 327;"><span id="cb106-328"><a href="#cb106-328"></a><span class="ot">int ::</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb106-329"><a href="#cb106-329"></a>    <span class="ot">-&gt;</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb106-330"><a href="#cb106-330"></a>    <span class="ot">-&gt;</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a>  (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb106-331"><a href="#cb106-331"></a>int <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm21</a> procINT</span></code></pre></div>
<p>Please review section <a href="#sec:cube-int-atom">2.2.2.6</a> concerning the up-sampler <code>interleave</code> used as a SY utility process. Here, since you have been already introduced to the SDF MoC, we can “unmask” how an interleaving process actually operates underneath. It is in fact a SDF actor which consumes one token from each input and interleaves them at the output.</p>
<figure>
<img src="figs/int-net.png" id="fig:int-net-atom" alt="" /><figcaption>Figure 36: INT network</figcaption>
</figure>
<div class="sourceCode" id="cb107" data-startFrom="340"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 339;"><span id="cb107-340"><a href="#cb107-340"></a><span class="ot">procINT ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">SDF.Signal</span></a> (<span class="dt">Matrix</span> a) <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">SDF.Signal</span></a> (<span class="dt">Matrix</span> a) <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Matrix</span> a)</span>
<span id="cb107-341"><a href="#cb107-341"></a>procINT cr <span class="ot">=</span> firNet mkIntCoefs <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.toSY1&#39;</a> <span class="op">.</span> merge cr</span>
<span id="cb107-342"><a href="#cb107-342"></a>  <span class="kw">where</span></span>
<span id="cb107-343"><a href="#cb107-343"></a>    merge   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.actor21</a> ((<span class="dv">1</span>,<span class="dv">1</span>), <span class="dv">2</span>, \[r] [l] <span class="ot">-&gt;</span> [r, l])</span></code></pre></div>
<p>As for the FIR network, we prefer working in the SY MoC domain, which describes more naturally a streaming <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-tap filter, hence we use translate back using the <code>toSY</code> MoC interface.</p>
<div class="sourceCode" id="cb108" data-startFrom="349"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 348;"><span id="cb108-349"><a href="#cb108-349"></a><span class="ot">firNet ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Matrix</span> a) <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Matrix</span> a)</span>
<span id="cb108-350"><a href="#cb108-350"></a>firNet coefs <span class="ot">=</span> fir&#39; addSM mulSM dlySM coefs</span>
<span id="cb108-351"><a href="#cb108-351"></a>  <span class="kw">where</span></span>
<span id="cb108-352"><a href="#cb108-352"></a>    addSM   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb21</a> (M.farm21 (<span class="op">+</span>))</span>
<span id="cb108-353"><a href="#cb108-353"></a>    mulSM c <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> (M.farm11 (<span class="op">*</span>c))</span>
<span id="cb108-354"><a href="#cb108-354"></a>    dlySM   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.delay</a>  (M.fanout <span class="dv">0</span>)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>farm21</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>farm21</code>,<code>farm11</code>,<code>fanout</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><code>ForSyDe.Atom.Skel.FastVector.Matrix</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>fir'</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><code>ForSyDe.Atom.Skel.FastVector.DSP</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>comb21</code>,<code>comb11</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><code>ForSyDe.Atom.MoC.SDF</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>mkIntCoefs</code></td>
<td>AESA.Coefs</td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<h3 data-number="6.1.3" id="system-process-network-1"><span class="header-section-number">6.1.3</span> System Process Network</h3>
<p>Finally, when putting all the blocks together in an equation, we obtain the system <code>aesa'</code> in Figure <a href="#fig:aesa-net-atom">37</a>.</p>
<figure>
<img src="figs/aesa-net-atom.png" id="fig:aesa-net-atom" alt="" /><figcaption>Figure 37: AESA network as black-box components</figcaption>
</figure>
<div class="sourceCode" id="cb109" data-startFrom="373"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 372;"><span id="cb109-373"><a href="#cb109-373"></a><span class="ot">aesa&#39; ::</span> <span class="dt">Antenna</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> <span class="dt">CpxData</span>) <span class="ot">-&gt;</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb109-374"><a href="#cb109-374"></a>aesa&#39; video <span class="ot">=</span> int rCfar lCfar</span>
<span id="cb109-375"><a href="#cb109-375"></a>  <span class="kw">where</span></span>
<span id="cb109-376"><a href="#cb109-376"></a>    lCfar     <span class="ot">=</span> cfar <span class="op">$</span> dfb lCt</span>
<span id="cb109-377"><a href="#cb109-377"></a>    rCfar     <span class="ot">=</span> cfar <span class="op">$</span> dfb rCt</span>
<span id="cb109-378"><a href="#cb109-378"></a>    (rCt,lCt) <span class="ot">=</span> ct <span class="op">$</span> pc <span class="op">$</span> dbf video</span></code></pre></div>
<p>At least for the sake of code elegance if not for more, we refine the system <code>aesa'</code> in Figure <a href="#fig:aesa-net-atom">37</a> to avoid unnecessary merging-splitting of vectors between stages, by <em>fusing</em> the <code>farm</code> skeletons between the PC and INT stages, like in Figure <a href="#fig:aesa-net-atom2">38</a>. While for simulation this transformation does not make much of a difference (thanks to Haskell’s lazy evaluation mechanisms), for future synthesis stages it might be a valuable insight, e.g. it increases the potential of parallel distribution. As both models are semantically equivalent an automated or tool-assisted transformation process should be trivial.</p>
<div class="sourceCode" id="cb110" data-startFrom="389"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 388;"><span id="cb110-389"><a href="#cb110-389"></a><span class="ot">aesa ::</span> <span class="dt">Antenna</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> <span class="dt">CpxData</span>) <span class="ot">-&gt;</span> <span class="dt">Beam</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> (<span class="dt">Range</span> (<span class="dt">Window</span> <span class="dt">RealData</span>)))</span>
<span id="cb110-390"><a href="#cb110-390"></a>aesa <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> pcToInt <span class="op">.</span> dbf</span></code></pre></div>
<div class="sourceCode" id="cb111" data-startFrom="392"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 391;"><span id="cb111-392"><a href="#cb111-392"></a>pcToInt beam <span class="ot">=</span> <span class="kw">let</span> (rb,lb) <span class="ot">=</span> procCT <span class="op">$</span> procPC <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.toSDF1</a> beam</span>
<span id="cb111-393"><a href="#cb111-393"></a>                   lCFAR   <span class="ot">=</span> procCFAR <span class="op">$</span> procDFB lb</span>
<span id="cb111-394"><a href="#cb111-394"></a>                   rCFAR   <span class="ot">=</span> procCFAR <span class="op">$</span> procDFB rb</span>
<span id="cb111-395"><a href="#cb111-395"></a>               <span class="kw">in</span>  procINT rCFAR lCFAR</span></code></pre></div>
<figure>
<img src="figs/aesa-net-atom2.png" id="fig:aesa-net-atom2" alt="" /><figcaption>Figure 38: AESA network when fusing the related <code>farm</code>s</figcaption>
</figure>
<h2 data-number="6.2" id="sec:stream-atom-sim"><span class="header-section-number">6.2</span> Model Simulation Against Test Data</h2>
<p>Just like before in section <a href="#sec:cube-atom-sim">2.3</a> we test the compiled model built from the blocks defined in section <a href="#sec:atom-network">6.1</a> within the <code>AESA.StreamsAtom</code> module against the same generated input data. Please refer to the the project’s <code>README</code> file on how to compile and run the necessary software tools.</p>
<p>The 13 objects described in tbl. <a href="#tbl:in-objects">2</a> and plotted in Figure <a href="#fig:aesa-indata">17 (a)</a> are again identified in the AESA radar processing output plotted in Figure <a href="#fig:aesa-odata-atom-stream">39</a>. Again we notice a slight difference in the cross-correlation values due to a different chaining of floating point operations, but in general the detected objects are within the same range.</p>
<figure>
<img src="figs/AESA_OUT_S.png" id="fig:aesa-odata-atom-stream" alt="" /><figcaption>Figure 39: One output cube with radar data</figcaption>
</figure>
<h2 data-number="6.3" id="sec:stream-prop-defs"><span class="header-section-number">6.3</span> Checking System Properties</h2>
<p>In section <a href="#sec:props">5</a> we preached the need for ways of verifying that an (executable) model satisfies a set of specification properties, and that those properties are not being violated during the refinement process. We presented <code>QuickCheck</code> as a practical and easy means for formulating properties and validating them against randomly-generated test cases. Following the same mindset, in this subsection we will try to validate through simulation<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> that the semantics of the main blocks in the AESA signal processing system defined in section <a href="#sec:atom-network">6.1</a> preserve the semantics of their initial high-level description from section <a href="#sec:cube-atom-operation">2.2</a>, with respect to the properties formulated in section <a href="#sec:prop-defs">5.2</a>.</p>
<p>Below you find the code written in a runnable module found at <code>aesa-atom/test</code>, which constitute the <code>:tests-cube</code> suite:</p>
<div class="sourceCode" id="cb112" data-startFrom="18"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 17;"><span id="cb112-18"><a href="#cb112-18"></a><span class="kw">module</span> <span class="dt">SpecStream</span> <span class="kw">where</span></span></code></pre></div>
<h3 data-number="6.3.1" id="imports-1"><span class="header-section-number">6.3.1</span> Imports</h3>
<p>We import the necessary libraries, such as <a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a> the two AESA model implementations <code>AESA.CubesAtom</code> and <code>AESA.StreamsAtom</code>, some ForSyDe-Atom libraries and a couple of other utility libraries. We use the data generators defined in the <code>Generators</code> module defined in section <a href="#sec:prop-gens">5.2.4</a>.</p>
<div class="sourceCode" id="cb113" data-startFrom="28"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 27;"><span id="cb113-28"><a href="#cb113-28"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb113-29"><a href="#cb113-29"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck.Function</span></span>
<span id="cb113-30"><a href="#cb113-30"></a><span class="kw">import</span> <span class="dt">Test.Framework</span></span>
<span id="cb113-31"><a href="#cb113-31"></a><span class="kw">import</span> <span class="dt">Test.Framework.Providers.QuickCheck2</span> (testProperty)</span>
<span id="cb113-32"><a href="#cb113-32"></a></span>
<span id="cb113-33"><a href="#cb113-33"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb113-34"><a href="#cb113-34"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a> <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb113-35"><a href="#cb113-35"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">ForSyDe.Atom.MoC.SDF</span></a> <span class="kw">as</span> <span class="dt">SDF</span></span>
<span id="cb113-36"><a href="#cb113-36"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Matrix.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.Matrix</span></a> <span class="kw">as</span> <span class="dt">M</span> (transpose)</span>
<span id="cb113-37"><a href="#cb113-37"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-Cube.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.Cube</span></a>   <span class="kw">as</span> <span class="dt">C</span> (<span class="dt">Cube</span>, transpose, transpose&#39;)</span>
<span id="cb113-38"><a href="#cb113-38"></a></span>
<span id="cb113-39"><a href="#cb113-39"></a><span class="kw">import</span> <span class="dt">AESA.CubesAtom</span>   <span class="kw">as</span> <span class="dt">AESAC</span></span>
<span id="cb113-40"><a href="#cb113-40"></a><span class="kw">import</span> <span class="dt">AESA.StreamsAtom</span> <span class="kw">as</span> <span class="dt">AESAS</span></span>
<span id="cb113-41"><a href="#cb113-41"></a><span class="kw">import</span> <span class="dt">AESA.Params</span></span>
<span id="cb113-42"><a href="#cb113-42"></a></span>
<span id="cb113-43"><a href="#cb113-43"></a><span class="kw">import</span> <span class="dt">Generators</span></span>
<span id="cb113-44"><a href="#cb113-44"></a><span class="kw">import</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb113-45"><a href="#cb113-45"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span></code></pre></div>
<h3 data-number="6.3.2" id="sec:atom-stream-props"><span class="header-section-number">6.3.2</span> Properties</h3>
<p>Perhaps the most noticeable transformation has been performed on the DBF module, since all the primitive operations performed by the vector-matrix dot product have become synchronous processes instead. In order to show that the two models are in fact sematically equivalent <em>with respect to the values and their structured order</em>, but not necessarily to the causal order or time implications, we formulate a property which degrades the signals and vectors to lists and compares them. Lists do not capture any temporal or spatial semantics, but they do have a clearly-defined <em>ordering</em> relation, which is equally valuable in our case. The formulations below follow the notation from section <a href="#sec:prop-notation">5.1</a>, and we denote the vector dimensions <code>Rn</code> for <em>range</em>, <code>Wn</code> for <em>window</em>, <code>An</code> for <em>antenna</em>, <code>Bm</code> for <em>beam</em> and <code>Ps</code> for <em>pulse</em>. <span id="eq:prop_dbf_transf_equiv"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>c</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle></msub><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝚆</mi><mi>𝚗</mi></mstyle></msub><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝙰</mi><mi>𝚗</mi></mstyle></msub><mo>⇒</mo><msub><mi>Σ</mi><mrow><mstyle mathvariant="monospace"><mi>𝙰</mi><mi>𝚗</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚆</mi><mi>𝚗</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="monospace"><mi>𝚍</mi><mi>𝚋</mi><mi>𝚏</mi></mstyle><mtext mathvariant="normal">cube</mtext></msub><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>Σ</mi><mrow><mstyle mathvariant="monospace"><mi>𝙰</mi><mi>𝚗</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚆</mi><mi>𝚗</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="monospace"><mi>𝚍</mi><mi>𝚋</mi><mi>𝚏</mi></mstyle><mtext mathvariant="normal">stream</mtext></msub><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>17</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall c \in \langle\langle\langle\mathbb{C}\rangle_{\mathtt{Rn}}\rangle_{\mathtt{Wn}}\rangle_{\mathtt{An}} \Rightarrow \Sigma_{\mathtt{An}\rightarrow\mathtt{Wn}\rightarrow\mathtt{Rn}}(\mathtt{dbf}_{\text{cube}}(\overline{c})) =
\Sigma_{\mathtt{An}\rightarrow\mathtt{Wn}\rightarrow\mathtt{Rn}}(\mathtt{dbf}_{\text{stream}}(\overline{c}))
\qquad(17)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb114" data-startFrom="66"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 65;"><span id="cb114-66"><a href="#cb114-66"></a>prop_dbf_transf_equiv <span class="ot">=</span> forAll (sigOfSmallCubes arbitrary) <span class="op">$</span> \sc <span class="ot">-&gt;</span> same (cbRes sc) (stRes sc)</span>
<span id="cb114-67"><a href="#cb114-67"></a>  <span class="kw">where</span></span>
<span id="cb114-68"><a href="#cb114-68"></a>    <span class="co">-- Compare all the values in the resulting nested lists</span></span>
<span id="cb114-69"><a href="#cb114-69"></a>    same c s <span class="ot">=</span> (<span class="fu">all</span> <span class="op">.</span> <span class="fu">all</span>) <span class="fu">id</span> <span class="op">$</span> (<span class="fu">zipWith</span> <span class="op">.</span> <span class="fu">zipWith</span>) (<span class="op">==</span>) c s</span>
<span id="cb114-70"><a href="#cb114-70"></a>    <span class="co">-- Results of the cube version of DBF as nested lists. Outputs are re-arranged</span></span>
<span id="cb114-71"><a href="#cb114-71"></a>    cbRes sc <span class="ot">=</span> toLists <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> unroll <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.unzipx</a> <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> C.transpose&#39; <span class="op">$</span> AESAC.dbf sc</span>
<span id="cb114-72"><a href="#cb114-72"></a>    <span class="co">-- Results of the stream version of DBF as nested lists. Inputs are re-arranged </span></span>
<span id="cb114-73"><a href="#cb114-73"></a>    stRes sc <span class="ot">=</span> toLists <span class="op">$</span> AESAS.dbf <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> unroll <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.unzipx</a> sc</span>
<span id="cb114-74"><a href="#cb114-74"></a>    <span class="co">-- Transforms a vector of signals into a list of lists</span></span>
<span id="cb114-75"><a href="#cb114-75"></a>    toLists  <span class="ot">=</span> <span class="fu">map</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a> <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector</a></span>
<span id="cb114-76"><a href="#cb114-76"></a>    <span class="co">-- Flattens a signal of matrices into a signal of ordered samples</span></span>
<span id="cb114-77"><a href="#cb114-77"></a>    unroll   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.signal</a> <span class="op">.</span> <span class="fu">concatMap</span> (<span class="fu">concatMap</span> fromVector <span class="op">.</span> fromVector) <span class="op">.</span>  <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a></span></code></pre></div>
<p>Let us now test the transformed PC block for the same property. Although the innermost operation is still <code>fir</code>, we would like to make sure that changing the MoC domain of the process from SY (on vectors) to SDF (on tokens) did affect in any way the ordering (and values) of the data. <span id="eq:prop_pc_transf_equiv"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>c</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle></msub><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝚆</mi><mi>𝚗</mi></mstyle></msub><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝙱</mi><mi>𝚖</mi></mstyle></msub><mo>,</mo><mi>r</mi><mo>∈</mo><msub><mi>c</mi><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle></msub><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>r</mi><mo stretchy="false" form="prefix">|</mo><mo>=</mo><msub><mi>N</mi><mi>b</mi></msub><mo>⇒</mo><msub><mi>Σ</mi><mrow><mstyle mathvariant="monospace"><mi>𝙱</mi><mi>𝚖</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚆</mi><mi>𝚗</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="monospace"><mi>𝚙</mi><mi>𝚌</mi></mstyle><mtext mathvariant="normal">cube</mtext></msub><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>Σ</mi><mrow><mstyle mathvariant="monospace"><mi>𝙱</mi><mi>𝚖</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚆</mi><mi>𝚗</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="monospace"><mi>𝚙</mi><mi>𝚌</mi></mstyle><mtext mathvariant="normal">stream</mtext></msub><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>18</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall c \in \langle\langle\langle\mathbb{C}\rangle_{\mathtt{Rn}}\rangle_{\mathtt{Wn}}\rangle_{\mathtt{Bm}},
r\in c_{\mathtt{Rn}} : |r| = N_b \Rightarrow
\Sigma_{\mathtt{Bm}\rightarrow\mathtt{Wn}\rightarrow\mathtt{Rn}}(\mathtt{pc}_{\text{cube}}(\overline{c})) =
\Sigma_{\mathtt{Bm}\rightarrow\mathtt{Wn}\rightarrow\mathtt{Rn}}(\mathtt{pc}_{\text{stream}}(\overline{c}))
\qquad(18)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb115" data-startFrom="90"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 89;"><span id="cb115-90"><a href="#cb115-90"></a><span class="co">-- We need an custom generator for cubes with &#39;nb&#39;-sized range vectors</span></span>
<span id="cb115-91"><a href="#cb115-91"></a><span class="ot">sigOfRnCubes ::</span> <span class="dt">Gen</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(<span class="dt">SY.Signal</span></a> (<span class="dt">C.Cube</span> (<span class="dt">Complex</span> <span class="dt">Float</span>)))</span>
<span id="cb115-92"><a href="#cb115-92"></a>sigOfRnCubes <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb115-93"><a href="#cb115-93"></a>  rangeL  <span class="ot">&lt;-</span> elements [nb]  <span class="co">-- range vector needs to have exactly &#39;nb&#39; samples  </span></span>
<span id="cb115-94"><a href="#cb115-94"></a>  windowL <span class="ot">&lt;-</span> choose (<span class="dv">2</span>, <span class="dv">10</span>)  </span>
<span id="cb115-95"><a href="#cb115-95"></a>  beamL   <span class="ot">&lt;-</span> choose (<span class="dv">2</span>, <span class="dv">10</span>)  </span>
<span id="cb115-96"><a href="#cb115-96"></a>  sigData <span class="ot">&lt;-</span> listOf1 <span class="op">$</span> sizedCube beamL windowL rangeL arbitrary</span>
<span id="cb115-97"><a href="#cb115-97"></a>  <span class="fu">return</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(SY.signal</a> sigData)</span></code></pre></div>
<div class="sourceCode" id="cb116" data-startFrom="99"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 98;"><span id="cb116-99"><a href="#cb116-99"></a>prop_pc_transf_equiv <span class="ot">=</span> forAll sigOfRnCubes <span class="op">$</span> \sc <span class="ot">-&gt;</span> same (cbRes sc) (stRes sc)</span>
<span id="cb116-100"><a href="#cb116-100"></a>  <span class="kw">where</span></span>
<span id="cb116-101"><a href="#cb116-101"></a>    <span class="co">-- Compare all the values in the resulting nested lists</span></span>
<span id="cb116-102"><a href="#cb116-102"></a>    same c s <span class="ot">=</span> (<span class="fu">all</span> <span class="op">.</span> <span class="fu">all</span>) <span class="fu">id</span> <span class="op">$</span> (<span class="fu">zipWith</span> <span class="op">.</span> <span class="fu">zipWith</span>) (<span class="op">==</span>) c s</span>
<span id="cb116-103"><a href="#cb116-103"></a>    <span class="co">-- Results of the cube version of DBF as nested lists. Outputs are re-arranged</span></span>
<span id="cb116-104"><a href="#cb116-104"></a>    cbRes sc <span class="ot">=</span> syToLst <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> unroll <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.unzipx</a></span>
<span id="cb116-105"><a href="#cb116-105"></a>               <span class="co">-- inverse the transposes during DBF and PC, align cubes with streams</span></span>
<span id="cb116-106"><a href="#cb116-106"></a>               <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> M.transpose <span class="op">$</span> AESAC.pc <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> C.transpose sc</span>
<span id="cb116-107"><a href="#cb116-107"></a>    <span class="co">-- Results of the stream version of DBF as nested lists. Inputs are re-arranged </span></span>
<span id="cb116-108"><a href="#cb116-108"></a>    stRes sc <span class="ot">=</span> sdfToLst <span class="op">$</span> AESAS.pc <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> unroll <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.unzipx</a> sc</span>
<span id="cb116-109"><a href="#cb116-109"></a>    <span class="co">-- Transforms a vector of signals into a list of lists</span></span>
<span id="cb116-110"><a href="#cb116-110"></a>    syToLst  <span class="ot">=</span> <span class="fu">map</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a>  <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector</a></span>
<span id="cb116-111"><a href="#cb116-111"></a>    sdfToLst <span class="ot">=</span> <span class="fu">map</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.fromSignal</a> <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector</a></span>
<span id="cb116-112"><a href="#cb116-112"></a>    <span class="co">-- Flattens a signal of matrices into a signal of ordered samples</span></span>
<span id="cb116-113"><a href="#cb116-113"></a>    unroll   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.signal</a> <span class="op">.</span> <span class="fu">concatMap</span> (<span class="fu">concatMap</span> fromVector <span class="op">.</span> fromVector) <span class="op">.</span>  <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a></span></code></pre></div>
<p><em>N.B.:</em> after a few iterations we realized that the property <code>prop_pc_transf_equiv</code> would not hold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>c</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\forall c \in \langle\langle\langle\mathbb{C}\rangle\rangle\rangle</annotation></semantics></math> because of the consumption rules of <code>SDF.comb11</code>. The streaming version of PC would not produce the same result as the cube version had the <code>Rn</code> dimension not been an integer multiple of the consumption rate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>b</mi></msub><annotation encoding="application/x-tex">N_b</annotation></semantics></math>, simply because if there are not enough tokens at the input, a SDF actor does not execute, whereas a scalable vector operation is evaluated regardless of how many elements it operates on. We thus had to adjust the property in eq. <a href="#eq:prop_pc_transf_equiv">18</a> accordingly having this insight, which means that we <em>restrict</em> the legal inputs pool to fit more to the specifications in section <a href="#sec:aesa-parameters">2.2.AESA parameters</a>, otherwise we cannot guarantee the property above.</p>
<p>When evaluating the corner turning (CT) it is now easier to verify the 50% overlap because we have access to the streams directly. We thus formulate the property <span id="eq:prop_ct_50_overlap"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mover><mi>a</mi><mo accent="true">¯</mo></mover><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> large enough</mtext></mrow><mo>,</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mi>α</mi><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝚆</mi><mi>𝚗</mi></mstyle></msub><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo><mo>=</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>∧</mo><mstyle mathvariant="monospace"><mi>𝚌</mi><mi>𝚝</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>a</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>v</mi><mo accent="true">¯</mo></mover><mtext mathvariant="normal">right</mtext></msub><mo>,</mo><msub><mover><mi>v</mi><mo accent="true">¯</mo></mover><mtext mathvariant="normal">left</mtext></msub><mo stretchy="false" form="postfix">)</mo><mo>⇒</mo><msub><mi>v</mi><mtext mathvariant="normal">right</mtext></msub><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><msub><mi>v</mi><mtext mathvariant="normal">left</mtext></msub><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>+</mo><mfrac><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mn>2</mn></mfrac><mo stretchy="false" form="postfix">]</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>19</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall \overline{a} \text{ large enough}, v\in \langle\alpha\rangle_{\mathtt{Wn}} :
|v|=N_{FFT} \wedge \mathtt{ct}(\overline{a}) = (\overline{v}_{\text{right}},\overline{v}_{\text{left}}) \Rightarrow
v_{\text{right}}[i] = v_{\text{left}}[i+\frac{N_{FFT}}{2}]
\qquad(19)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb117" data-startFrom="134"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 133;"><span id="cb117-134"><a href="#cb117-134"></a><span class="co">-- We need a generator for signals of size larger than &#39;nFFT/2&#39;</span></span>
<span id="cb117-135"><a href="#cb117-135"></a><span class="ot">largeSigs ::</span> <span class="dt">Gen</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> <span class="dt">Int</span>)</span>
<span id="cb117-136"><a href="#cb117-136"></a>largeSigs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb117-137"><a href="#cb117-137"></a>  n <span class="ot">&lt;-</span> choose (nb <span class="op">*</span> nFFT <span class="ot">`div`</span> <span class="dv">2</span>, nb <span class="op">*</span> nFFT)</span>
<span id="cb117-138"><a href="#cb117-138"></a>  sigData <span class="ot">&lt;-</span> vectorOf n arbitrary</span>
<span id="cb117-139"><a href="#cb117-139"></a>  <span class="fu">return</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(SDF.signal</a> sigData)</span></code></pre></div>
<div class="sourceCode" id="cb118" data-startFrom="141"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 140;"><span id="cb118-141"><a href="#cb118-141"></a>prop_ct_50_overlap <span class="ot">=</span> forAll largeSigs <span class="op">$</span> \s <span class="ot">-&gt;</span> over (AESAS.procCT s)</span>
<span id="cb118-142"><a href="#cb118-142"></a>  <span class="kw">where</span></span>
<span id="cb118-143"><a href="#cb118-143"></a>    over (rc,lc) <span class="ot">=</span> <span class="fu">all</span> <span class="fu">id</span> <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.fromSignal</a></span>
<span id="cb118-144"><a href="#cb118-144"></a>                   <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.actor21</a> ((nFFT,nFFT), nFFT <span class="ot">`div`</span> <span class="dv">2</span>, overF) rc lc</span>
<span id="cb118-145"><a href="#cb118-145"></a>    overF rl ll  <span class="ot">=</span> <span class="fu">zipWith</span> (<span class="op">==</span>) rl (L.drop (nFFT <span class="ot">`div`</span> <span class="dv">2</span>) ll)</span></code></pre></div>
<p>For the rest of the blocks, DFB, CFAR and INT we can follow the model set by <code>prop_pc_transf_equiv</code> to formulate properties testing for functional equivalence. We only mention these properties as formulas, and we leave the writing of the QuickCheck code as an exercise to the reader. <span id="eq:prop_dfb_transf_equiv"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>c</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝚆</mi><mi>𝚗</mi></mstyle></msub><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle></msub><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝙱</mi><mi>𝚖</mi></mstyle></msub><mo>,</mo><mi>w</mi><mo>∈</mo><msub><mi>c</mi><mstyle mathvariant="monospace"><mi>𝚆</mi><mi>𝚗</mi></mstyle></msub><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>w</mi><mo stretchy="false" form="prefix">|</mo><mo>=</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>⇒</mo><msub><mi>Σ</mi><mrow><mstyle mathvariant="monospace"><mi>𝙱</mi><mi>𝚖</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝙿</mi><mi>𝚜</mi></mstyle></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="monospace"><mi>𝚍</mi><mi>𝚏</mi><mi>𝚋</mi></mstyle><mtext mathvariant="normal">cube</mtext></msub><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>Σ</mi><mrow><mstyle mathvariant="monospace"><mi>𝙱</mi><mi>𝚖</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝙿</mi><mi>𝚜</mi></mstyle></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="monospace"><mi>𝚍</mi><mi>𝚏</mi><mi>𝚋</mi></mstyle><mtext mathvariant="normal">stream</mtext></msub><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>20</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall c \in \langle\langle\langle\mathbb{C}\rangle_{\mathtt{Wn}}\rangle_{\mathtt{Rn}}\rangle_{\mathtt{Bm}},
w\in c_{\mathtt{Wn}} : |w| = N_{FFT} \Rightarrow
\Sigma_{\mathtt{Bm}\rightarrow\mathtt{Rn}\rightarrow\mathtt{Ps}}(\mathtt{dfb}_{\text{cube}}(\overline{c})) =
\Sigma_{\mathtt{Bm}\rightarrow\mathtt{Rn}\rightarrow\mathtt{Ps}}(\mathtt{dfb}_{\text{stream}}(\overline{c}))
\qquad(20)</annotation></semantics></math></span> <span id="eq:prop_cfar_transf_equiv"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>c</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝙿</mi><mi>𝚜</mi></mstyle></msub><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle></msub><msub><mo stretchy="false" form="postfix">⟩</mo><mstyle mathvariant="monospace"><mi>𝙱</mi><mi>𝚖</mi></mstyle></msub><mo>,</mo><mi>w</mi><mo>∈</mo><msub><mi>c</mi><mstyle mathvariant="monospace"><mi>𝚆</mi><mi>𝚗</mi></mstyle></msub><mo>,</mo><mi>r</mi><mo>∈</mo><msub><mi>c</mi><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle></msub><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>w</mi><mo stretchy="false" form="prefix">|</mo><mo>=</mo><msub><mi>N</mi><mrow><mi>F</mi><mi>F</mi><mi>T</mi></mrow></msub><mo>∧</mo><mo stretchy="false" form="prefix">|</mo><mi>r</mi><mo stretchy="false" form="prefix">|</mo><mo>=</mo><msub><mi>N</mi><mi>b</mi></msub><mo>⇒</mo><msub><mi>Σ</mi><mrow><mstyle mathvariant="monospace"><mi>𝙱</mi><mi>𝚖</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝙿</mi><mi>𝚜</mi></mstyle></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="monospace"><mi>𝚌</mi><mi>𝚏</mi><mi>𝚊</mi><mi>𝚛</mi></mstyle><mtext mathvariant="normal">cube</mtext></msub><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>Σ</mi><mrow><mstyle mathvariant="monospace"><mi>𝙱</mi><mi>𝚖</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝚁</mi><mi>𝚗</mi></mstyle><mo>→</mo><mstyle mathvariant="monospace"><mi>𝙿</mi><mi>𝚜</mi></mstyle></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="monospace"><mi>𝚌</mi><mi>𝚏</mi><mi>𝚊</mi><mi>𝚛</mi></mstyle><mtext mathvariant="normal">stream</mtext></msub><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>21</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall c \in \langle\langle\langle\mathbb{C}\rangle_{\mathtt{Ps}}\rangle_{\mathtt{Rn}}\rangle_{\mathtt{Bm}},
w\in c_{\mathtt{Wn}}, r\in c_{\mathtt{Rn}} : |w| = N_{FFT} \wedge  |r| = N_{b} \Rightarrow
\Sigma_{\mathtt{Bm}\rightarrow\mathtt{Rn}\rightarrow\mathtt{Ps}}(\mathtt{cfar}_{\text{cube}}(\overline{c})) =
\Sigma_{\mathtt{Bm}\rightarrow\mathtt{Rn}\rightarrow\mathtt{Ps}}(\mathtt{cfar}_{\text{stream}}(\overline{c}))
\qquad(21)</annotation></semantics></math></span> <span id="eq:prop_int_transf_equiv"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><msub><mi>c</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">⟩</mo><mo>⇒</mo><mi>Σ</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="monospace"><mi>𝚒</mi><mi>𝚗</mi><mi>𝚝</mi></mstyle><mtext mathvariant="normal">cube</mtext></msub><mo stretchy="false" form="prefix">(</mo><mover><msub><mi>c</mi><mn>1</mn></msub><mo accent="true">¯</mo></mover><mo>,</mo><mover><msub><mi>c</mi><mn>2</mn></msub><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>Σ</mi><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="monospace"><mi>𝚒</mi><mi>𝚗</mi><mi>𝚝</mi></mstyle><mtext mathvariant="normal">stream</mtext></msub><mo stretchy="false" form="prefix">(</mo><mover><msub><mi>c</mi><mn>1</mn></msub><mo accent="true">¯</mo></mover><mo>,</mo><mover><msub><mi>c</mi><mn>2</mn></msub><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>22</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall c_1,c_2 \in \langle\langle\langle\mathbb{C}\rangle\rangle\rangle \Rightarrow
\Sigma(\mathtt{int}_{\text{cube}}(\overline{c_1},\overline{c_2})) =
\Sigma(\mathtt{int}_{\text{stream}}(\overline{c_1},\overline{c_2}))
\qquad(22)</annotation></semantics></math></span></p>
<h3 data-number="6.3.3" id="main-function.-test-suite-results"><span class="header-section-number">6.3.3</span> Main function. Test Suite Results</h3>
<p>We gather the QuickCheck properties defined above into one runnable suite:</p>
<div class="sourceCode" id="cb119" data-startFrom="173"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 172;"><span id="cb119-173"><a href="#cb119-173"></a><span class="ot">tests ::</span> [<span class="dt">Test</span>]</span>
<span id="cb119-174"><a href="#cb119-174"></a>tests <span class="ot">=</span> [</span>
<span id="cb119-175"><a href="#cb119-175"></a>  testGroup <span class="st">&quot; Stream HL Model Tests &quot;</span></span>
<span id="cb119-176"><a href="#cb119-176"></a>    [ testProperty <span class="st">&quot;DBF transformation preserves the order of elements &quot;</span></span>
<span id="cb119-177"><a href="#cb119-177"></a>      (withMaxSuccess <span class="dv">50</span> prop_dbf_transf_equiv)</span>
<span id="cb119-178"><a href="#cb119-178"></a>    , testProperty <span class="st">&quot;PC transformation preserves the order of elements  &quot;</span></span>
<span id="cb119-179"><a href="#cb119-179"></a>      (withMaxSuccess <span class="dv">20</span> prop_pc_transf_equiv)</span>
<span id="cb119-180"><a href="#cb119-180"></a>    , testProperty <span class="st">&quot;CT 50% overlap                                     &quot;</span></span>
<span id="cb119-181"><a href="#cb119-181"></a>      (withMaxSuccess <span class="dv">20</span> prop_ct_50_overlap)</span>
<span id="cb119-182"><a href="#cb119-182"></a>    ]</span>
<span id="cb119-183"><a href="#cb119-183"></a>  ]</span></code></pre></div>
<div class="sourceCode" id="cb120" data-startFrom="185"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 184;"><span id="cb120-185"><a href="#cb120-185"></a><span class="ot">main ::</span> <span class="dt">IO</span>()</span>
<span id="cb120-186"><a href="#cb120-186"></a>main <span class="ot">=</span> defaultMain tests</span></code></pre></div>
<p>which we execute, as per the instructions in the project’s <code>README</code> file. Since we are generating random tests on cubes of noticeable dimensions, the execution time is also quite long, hence the smaller number of test cases generated per suite. The expected printout is:</p>
<pre><code>aesa-atom-0.1.0.0: test (suite: tests-stream)

 Stream HL Model Tests :
  DBF transformation preserves the order of elements : [OK, passed 50 tests]
  PC transformation preserves the order of elements  : [OK, passed 20 tests]
  CT 50% overlap                                     : [OK, passed 20 tests]

         Properties  Total      
 Passed  3           3          
 Failed  0           0          
 Total   3           3          

aesa-atom-0.1.0.0: Test suite tests-stream passed
</code></pre>
<p>This means that, at least when concerning the functionality of the AESA signal video processing chain, we have not introduced any unwanted flaws with our model refinement process. We also have a better understanding of the conditions and restrictions within which the new refined model operates as expected.</p>
<h2 data-number="6.4" id="conclusion-2"><span class="header-section-number">6.4</span> Conclusion</h2>
<p>In this section we have presented an alternative model of the AESA signal processing chain which refines its behavior in order to expose its streaming characteristics inferred from the specification statement <em>“For each antenna the data arrives <em>pulse by pulse</em>, and each pulse arrives <em>range bin by range bin</em>. This happens <em>for all antennas in parallel</em>, and all complex samples are synchronized with the same sampling rate, e.g. of the A/D converter.”</em> While still regarded from a high abstraction level (e.g. SDF actors are assumed to execute “instantaneously” once they have enough data to operate on), the refined processing blocks now describe a more fine-grained causal ordering between individual samples arriving in streams. This enables their potential of better resources exploitation (e.g. hardware/software pipelining, or distribution) during future mapping, scheduling and synthesis design stages. We have (unit) tested this refined model against the high-level “golden model” presented in section <a href="#sec:atom">2</a>, by confronting the two models’ responses against the same set of input stimuli. We have also formulated a couple of properties to ensure that the functional description of some of the blocks is still the expected one, and we have not introduced hidden bugs, or rather flaws in the model description.</p>
<p>In the following section we plan to synthesize one functional block down to VHDL code targeting FPGA hardware implementation. This means that we will continue gradually refining the (sub-)system model until we reach enough detail level to start the code synthesis process. As each refinement process is prone to introducing hidden mistakes or logical flaws due to its nonsemantic-preserving nature, we will monitor the correctness of the resulting artifact with the help of the existing, as well as newly-formulated, properties.</p>
<h1 data-number="7" id="sec:synth"><span class="header-section-number">7</span> Model Synthesis to VHDL</h1>
<blockquote>
<p><em>In this section we choose one sub-system in the AESA signal processing stage and gradually refine to synthesizable VHDL code, by applying a series of semantic- and nonsemantic-preserving transformations. In order to validate the resulting design we gradually wrap each refined component in order to co-simulate it with the original model, test it against the same input data as the previous sections, and formulate design properties that ensure the desired behavior is preserved. As input model we use the refined streaming behavior from section <a href="#sec:refine">6</a> and we focus only on its PC stage. Throughout this section we will introduce another framework in the ForSyDe ecosystem: ForSyDe-Deep, which is able to parse an input ForSyDe program and translate it to different backends.</em></p>
</blockquote>
<table>
<tbody>
<tr class="odd">
<td>Package</td>
<td>aesa-deep-0.1.0</td>
<td>path: <code>./aesa-deep/README.md</code></td>
</tr>
<tr class="even">
<td>Deps</td>
<td>forsyde-atom-0.3.1</td>
<td>url: <code>https://forsyde.github.io/forsyde-atom/api/</code></td>
</tr>
<tr class="odd">
<td></td>
<td>forsyde-deep-0.2.1</td>
<td>url: <code>http://hackage.haskell.org/package/forsyde-deep</code></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>note: 0.2.1 is found in a local experimental branch.</td>
</tr>
<tr class="odd">
<td></td>
<td>QuickCheck-2.13.1</td>
<td>url: <code>http://hackage.haskell.org/package/QuickCheck</code></td>
</tr>
<tr class="even">
<td>Suite</td>
<td>tests-deep</td>
<td>usage: <code>stack test :tests-deep</code></td>
</tr>
<tr class="odd">
<td>Bin</td>
<td>aesa-deep</td>
<td>usage: <code>aesa-deep --help</code></td>
</tr>
</tbody>
</table>
<p>The system in section <a href="#sec:refine">6</a>, although exposing a more fine-grained streaming behavior for each data channel, is still far from a physical realization. In order to reach a suitable implementation one has to take into consideration a multitude of aspects from one or several target platforms (architectures), which form the <em>design space</em>. Mapping a behavior onto a platform often involves a (series of) transformation(s) that do not fully preserve the original semantics any longer, yet still offer a good realization of the intended behavior. We call these <em>nonsemantic-preserving</em> transformations <span class="citation" data-cites="raudvere2008application">(Raudvere, Sander, and Jantsch <a href="#ref-raudvere2008application" role="doc-biblioref">2008</a>)</span>.</p>
<p>In this section we will focus on synthesizing the PC signal processing stage, as specified in section <a href="#sec:video-chain-spec">1.Application Specification</a> and modeled in section <a href="#sec:atom-network">6.1</a>, into an FPGA component. We do that by applying four subsequent refinement phases, guided by design <em>decisions</em> to reach a correct and/or efficient implementation. Each decision is tested against a set of properties as introduced in section <a href="#sec:props">5</a>, and each refined component is co-simulated within the entire AESA high-level model.</p>
<h2 data-number="7.1" id="refinement-1-untimed-mav-to-timed-fir"><span class="header-section-number">7.1</span> Refinement 1: Untimed MAV to Timed FIR</h2>
<p>The first refinement comes from the observation that the PC block from section <a href="#sec:atom-network">6.1</a>, although operating on streams, exposes an instantaneous, untimed behavior over fixed sized-vectors of numbers. In other words, the SDF process associated with a channel’s PC stage is more concerned that a moving average (MAV) algorithm is applied on a vector of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>b</mi></msub><annotation encoding="application/x-tex">N_b</annotation></semantics></math> samples as soon as they arrive, but it is not really concerned on <em>how</em> the MAV is performed. This type of under-specification can derive a family of possible implementations, but does not bide well with the register transfer level (RTL) style of modeling specific to hardware implementations, which requires a more specific total order between actions. For example, translating the “instantaneous” MAV function (i.e. <code>fir (mkPcCoef pcTap)</code>) word-by-word into RTL would create a terribly un-efficient and wasteful circuit! Luckily, we have already seen a similar, more fine-grained streaming behavior for the same MAV function in section <a href="#sec:cube-int-atom">2.2.2.6</a>, and respectively section <a href="#sec:int-atom">6.1.2.5</a>, namely the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-tap systolic FIR structure created with the <code>fir'</code> skeleton<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
<h3 data-number="7.1.1" id="model"><span class="header-section-number">7.1.1</span> Model</h3>
<p>In this first refinement phase we translate the SDF process <code>procPC</code> from section <a href="#sec:pc-atom">6.1.2.2</a> into systolic network of SY processes <code>procPC'</code> much more appropriate and efficient for RTL-based implementations.</p>
<div class="sourceCode" id="cb122" data-startFrom="26"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 25;"><span id="cb122-26"><a href="#cb122-26"></a><span class="kw">module</span> <span class="dt">AESA.PC.R1</span> <span class="kw">where</span></span></code></pre></div>
<p>Customary, we import the needed modules from the <code>ForSyDe.Atom</code> suite:</p>
<div class="sourceCode" id="cb123" data-startFrom="30"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 29;"><span id="cb123-30"><a href="#cb123-30"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a>  <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb123-31"><a href="#cb123-31"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">ForSyDe.Atom.MoC.SDF</span></a> <span class="kw">as</span> <span class="dt">SDF</span></span>
<span id="cb123-32"><a href="#cb123-32"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb123-33"><a href="#cb123-33"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><span class="dt">ForSyDe.Atom.Skel.FastVector.DSP</span></a> (fir&#39;)</span></code></pre></div>
<p>To make sure we use exactly the same coefficients and constants as the ones used with the high-level model in section <a href="#sec:atom-network">6.1</a>, we import them directly from the <code>aesa-atom</code> package.</p>
<div class="sourceCode" id="cb124" data-startFrom="39"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 38;"><span id="cb124-39"><a href="#cb124-39"></a><span class="kw">import</span> <span class="dt">AESA.Coefs</span> (mkPcCoefs)</span>
<span id="cb124-40"><a href="#cb124-40"></a><span class="kw">import</span> <span class="dt">AESA.Params</span> (pcTap, nb)</span></code></pre></div>
<p>Lastly, we need to import the <code>Complex</code> type.</p>
<div class="sourceCode" id="cb125" data-startFrom="44"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 43;"><span id="cb125-44"><a href="#cb125-44"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span></code></pre></div>
<p>First we define the coefficients which will be used throughout all the refinement phases. If you read the API documentation of <code>fir'</code> you will see that the order of application of FIR tap processes is <em>from right to left</em>, thus we need to reverse the order of PC coefficients.</p>
<div class="sourceCode" id="cb126" data-startFrom="51"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 50;"><span id="cb126-51"><a href="#cb126-51"></a><span class="ot">coefsR1 ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Vector</span> a</span>
<span id="cb126-52"><a href="#cb126-52"></a>coefsR1 <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.reverse</a> <span class="op">$</span> mkPcCoefs pcTap</span></code></pre></div>
<p>Then we define the interface for the PC’ stage, which is the same as for PC in section <a href="#sec:pc-atom">6.1.2.2</a>. This means that, as far as the type checker is concerned, we can simply replace <code>pc</code> with <code>pc'</code> in the original high level model and simulate as part of the entire AESA signal processing chain.</p>
<div class="sourceCode" id="cb127" data-startFrom="59"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 58;"><span id="cb127-59"><a href="#cb127-59"></a><span class="ot">pc&#39; ::</span> <span class="dt">Vector</span> ( <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Float</span>))</span>
<span id="cb127-60"><a href="#cb127-60"></a>    <span class="ot">-&gt;</span> <span class="dt">Vector</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Float</span>))</span>
<span id="cb127-61"><a href="#cb127-61"></a>pc&#39; <span class="ot">=</span> farm11 <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(SY.toSDF1</a> <span class="op">.</span> procPC&#39;)</span></code></pre></div>
<p>the <code>procPC'</code> process is, as mentioned earlier, a SY <code>fir'</code> process network which defines a particular timed (in the causality sense) behavior for the SDF <code>procPC</code> in section <a href="#sec:pc-atom">6.1.2.2</a>.</p>
<p><strong>OBS:</strong> for didactic purpose, we define <code>procPC'</code> as an instance of a custom process constructor <code>pcFIR</code> defined below. The role of <code>pcFIR</code> is to decouple whatever happens in the <em>function layer</em><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> from the layers above. This will come in handy in the next refinement phase, which affects <em>only</em> the function layer, and thus we can reuse the same code patterns from this module.</p>
<figure>
<img src="figs/fir-proc-shallow.png" id="fig:fir-pc" alt="" /><figcaption>Figure 40: The internals of the <code>pcFIR</code> process constructor</figcaption>
</figure>
<div class="sourceCode" id="cb128" data-startFrom="77"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 76;"><span id="cb128-77"><a href="#cb128-77"></a><span class="ot">pcFIR ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)               <span class="co">-- ^ /function layer/ addition</span></span>
<span id="cb128-78"><a href="#cb128-78"></a>      <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)               <span class="co">-- ^ /function layer/ multiplication</span></span>
<span id="cb128-79"><a href="#cb128-79"></a>      <span class="ot">-&gt;</span> a                           <span class="co">-- ^ /function layer/ initial state</span></span>
<span id="cb128-80"><a href="#cb128-80"></a>      <span class="ot">-&gt;</span> <span class="dt">Vector</span>    a                 <span class="co">-- ^ vector of coefficients</span></span>
<span id="cb128-81"><a href="#cb128-81"></a>      <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> a                 <span class="co">-- ^ input signal</span></span>
<span id="cb128-82"><a href="#cb128-82"></a>      <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> a                 <span class="co">-- ^ output signal</span></span>
<span id="cb128-83"><a href="#cb128-83"></a>pcFIR <span class="fu">sum</span> mul initial coefs <span class="ot">=</span> fir&#39; sumP mulP resetDly coefs</span>
<span id="cb128-84"><a href="#cb128-84"></a>  <span class="kw">where</span></span>
<span id="cb128-85"><a href="#cb128-85"></a>    sumP     <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb21</a> <span class="fu">sum</span></span>
<span id="cb128-86"><a href="#cb128-86"></a>    mulP c   <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> (mul c)</span>
<span id="cb128-87"><a href="#cb128-87"></a>    resetDly <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.moore11</a> countReset <span class="fu">snd</span> (<span class="dv">0</span>,initial)</span>
<span id="cb128-88"><a href="#cb128-88"></a>    countReset (c,_) p <span class="op">|</span> c <span class="op">==</span> nb<span class="op">-</span><span class="dv">1</span> <span class="ot">=</span> (<span class="dv">0</span>,initial)</span>
<span id="cb128-89"><a href="#cb128-89"></a>                       <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (c<span class="op">+</span><span class="dv">1</span>,p)</span></code></pre></div>
<p>When we change the time domain of the process we lose the information on the partial order between events. In SY there is no MoC-induced mechanism that tells us <em>when</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>b</mi></msub><annotation encoding="application/x-tex">N_b</annotation></semantics></math> events have been consumed/processed: this mechanism needs to be hand-crafted. <em>One</em> solution is to embed a count-reset Moore state machine inside each delay element associated with every FIR tap. This way, each Moore machine stores a counter value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><msub><mi>N</mi><mi>b</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\in [0,N_b)</annotation></semantics></math> along with the previous complex sample, and would reset its state after after propagating <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>b</mi></msub><annotation encoding="application/x-tex">N_b</annotation></semantics></math> samples.</p>
<p>Finally, we define <code>procPC'</code> by filling in the function layer entities needed by the <code>pcFIR</code> process constructor.</p>
<div class="sourceCode" id="cb129" data-startFrom="102"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 101;"><span id="cb129-102"><a href="#cb129-102"></a><span class="ot">procPC&#39; ::</span> <span class="dt">Fractional</span> a</span>
<span id="cb129-103"><a href="#cb129-103"></a>        <span class="ot">=&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> a</span>
<span id="cb129-104"><a href="#cb129-104"></a>        <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> a</span>
<span id="cb129-105"><a href="#cb129-105"></a>procPC&#39; <span class="ot">=</span> pcFIR (<span class="op">+</span>) (<span class="op">*</span>) <span class="dv">0</span> coefsR1</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Original module</th>
<th>Package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mealy11</code>, <code>comb11</code>, <code>comb21</code>, <code>toSDF1</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><code>ForSyDe.Atom.MoC.SY</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>farm11</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><code>ForSyDe.Atom.Skel.FastVector</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="odd">
<td><code>fir'</code></td>
<td><a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector-DSP.html"><code>ForSyDe.Atom.Skel.FastVector.DSP</code></a></td>
<td>forsyde-atom</td>
</tr>
<tr class="even">
<td><code>mkPcCoefs</code></td>
<td><code>AESA.Coefs</code></td>
<td>aesa-atom</td>
</tr>
<tr class="odd">
<td><code>pcTap</code>, <code>nb</code></td>
<td><code>AESA.Params</code></td>
<td>aesa-atom</td>
</tr>
</tbody>
</table>
<h3 data-number="7.1.2" id="simulation"><span class="header-section-number">7.1.2</span> Simulation</h3>
<p>As mentioned above, the PC’ component can be “plugged in” and used with the AESA signal processing chain. Please refer to the project’s <code>README</code> file, respectively the binary help menu instructions, on how to execute the model containing the PC’ block against the same test input data as the previous high-level models. For the sake of space we do not include the output image, however we encourage the reader to try it out and plot it herself. For now we can only assure you that it looks similar to Figure <a href="#fig:aesa-odata-atom-stream">39</a>, except for the detection values, whose (slight) differences are induced by floating point calculation errors.</p>
<h3 data-number="7.1.3" id="properties"><span class="header-section-number">7.1.3</span> Properties</h3>
<p>The main property we want to test now is that the process <code>procPC'</code> defined above is <em>sequence equivalent</em> with the original <code>procPC</code> from section <a href="#sec:pc-atom">6.1.2.2</a> and hence, as of <code>prop_pc_transf_equiv</code> defined in eq. <a href="#eq:prop_dbf_transf_equiv">17</a>, the PC’ stage is an exact <em>functional</em> replacement for the high-level PC operating on video cubes.</p>
<p>We define a new module as part of these refinements’ test suite:</p>
<div class="sourceCode" id="cb130" data-startFrom="10"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 9;"><span id="cb130-10"><a href="#cb130-10"></a><span class="ot">{-# LANGUAGE PackageImports #-}</span></span>
<span id="cb130-11"><a href="#cb130-11"></a><span class="kw">module</span> <span class="dt">TestR1</span> <span class="kw">where</span></span></code></pre></div>
<p>We need to be able to pack/unpack signals, so we import the <code>SY</code> and respectively <code>SDF</code> modules.</p>
<div class="sourceCode" id="cb131" data-startFrom="15"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 14;"><span id="cb131-15"><a href="#cb131-15"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a> <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb131-16"><a href="#cb131-16"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">ForSyDe.Atom.MoC.SDF</span></a> <span class="kw">as</span> <span class="dt">SDF</span></span></code></pre></div>
<p>We import the QuickCheck DSL, along with a couple of local utilities, mainly arbitrary data type generators.</p>
<div class="sourceCode" id="cb132" data-startFrom="21"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 20;"><span id="cb132-21"><a href="#cb132-21"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></span>
<span id="cb132-22"><a href="#cb132-22"></a><span class="kw">import</span> <span class="dt">Generators</span> (largeSdfSigs, rationals)</span></code></pre></div>
<p>Finally, we import the DUTs: the SDF <code>procPC</code> from the high-level streamed model and the SY <code>procPC'</code> from Refinement 1.</p>
<div class="sourceCode" id="cb133" data-startFrom="27"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 26;"><span id="cb133-27"><a href="#cb133-27"></a><span class="kw">import</span> <span class="dt">AESA.StreamsAtom</span> <span class="kw">as</span> <span class="dt">M1</span></span>
<span id="cb133-28"><a href="#cb133-28"></a><span class="kw">import</span> <span class="dt">AESA.PC.R1</span> <span class="kw">as</span> <span class="dt">R1</span></span></code></pre></div>
<p>The property we need to test is <span id="eq:prop_refine1_equiv"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>c</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo>⇒</mo><mi>Σ</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="monospace"><mi>𝚙</mi><mi>𝚛</mi><mi>𝚘</mi><mi>𝚌</mi><mi>𝙿</mi><mi>𝙲</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>Σ</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="monospace"><mi>𝚙</mi><mi>𝚛</mi><mi>𝚘</mi><mi>𝚌</mi><mi>𝙿</mi><mi>𝙲</mi><mi>′</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>23</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall c \in \mathbb{C} \Rightarrow
\Sigma(\mathtt{procPC}(\overline{c})) =
\Sigma(\mathtt{procPC&#39;}(\overline{c}))
\qquad(23)</annotation></semantics></math></span></p>
<p>In order to test sequence equivalence between the two processes we need to take into account two very important matters:</p>
<ol type="1">
<li><p>a SDF process’ output signal contains a number of elements which is a multiple of its production rate, whereas a SY process does not have this restriction. Sequence equivalence means that both output signals have the same initial segments, property which is handled by the <code>zip</code> list function.</p></li>
<li><p>floating point numbers <em>cannot</em> be used to test for equality, especially now since the order of operations is different. Luckily we have defined both <code>procPC</code> and <code>procPC'</code>, as well as their coefficient vectors as polymorphic, thus as a practical alternative <code>Complex Float</code> (i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>), we can use <code>Rational</code> numbers (i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℚ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math>) which have a strict notion of equality. Sequence equivalence over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℚ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{Q}</annotation></semantics></math> is sufficient to later demonstrate through inference eq. <a href="#eq:prop_refine1_equiv">23</a>.</p></li>
</ol>
<div class="sourceCode" id="cb134" data-startFrom="54"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 53;"><span id="cb134-54"><a href="#cb134-54"></a>prop_refine1_equiv <span class="ot">=</span> forAll (largeSdfSigs rationals) <span class="op">$</span> \s <span class="ot">-&gt;</span> equiv s <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(SDF.toSY1&#39;</a> s)</span>
<span id="cb134-55"><a href="#cb134-55"></a>  <span class="kw">where</span></span>
<span id="cb134-56"><a href="#cb134-56"></a>    equiv sdf sy <span class="ot">=</span> <span class="fu">all</span> (\(a,b) <span class="ot">-&gt;</span> a <span class="op">==</span> b) <span class="op">$</span> <span class="fu">zip</span></span>
<span id="cb134-57"><a href="#cb134-57"></a>                   <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(SDF.fromSignal</a> <span class="op">$</span> M1.procPC sdf)</span>
<span id="cb134-58"><a href="#cb134-58"></a>                   ( <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a> <span class="op">$</span> R1.procPC&#39; sy)</span></code></pre></div>
<p>When running the test suite (refer to the <code>README</code> instructions) <code>prop_refine1_equiv</code> passes all tests, which means that the two behaviors are compatible and PC’ can be used as source for further refinements.</p>
<h2 data-number="7.2" id="refinement-2-floating-point-to-q19"><span class="header-section-number">7.2</span> Refinement 2: Floating Point to Q19</h2>
<p>Due to it widespread usage with general purpose computing, IEEE floating point number representation is the de-facto standard for non-integer numerical applications. However, although common and even taken for granted in CPUs, floating point units are in general much larger and more expensive circuits than their integer counterparts. Moreover, judging by the application specification in section <a href="#sec:video-chain-spec">1.Application Specification</a>, synthesizing floating point arithmetics on FPGA would be overkill, because:</p>
<ul>
<li><p>we do not need a large span of numbers. On the contrary, the specification says that at the PC stage the samples are within <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>,</mo><mn>1</mn><mo>+</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[-1-i,1+i)</annotation></semantics></math>, i.e. only decimals;</p></li>
<li><p>according to tbl. <a href="#tbl:sizes">1</a>, for the calculations within PC we do not need a precision higher than 20 bits.</p></li>
</ul>
<p>Driven by these statements, we decide that a much more appropriate number representation for synthesizing the PC signal processing stage to FPGA is the fixed point Q19 representation which, under the hood, consists simply in integer calculations. We thus refine further the PC’ stage as to operate on complex fixed point Q19 numbers instead of complex floating point numbers, or more specific <em>refine only its function layer</em> to operate on this type of numbers.</p>
<h3 data-number="7.2.1" id="model-1"><span class="header-section-number">7.2.1</span> Model</h3>
<p>We code the second refinement in its own module.</p>
<div class="sourceCode" id="cb135" data-startFrom="28"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 27;"><span id="cb135-28"><a href="#cb135-28"></a><span class="ot">{-# LANGUAGE PackageImports #-}</span> <span class="co">--can be ignored</span></span>
<span id="cb135-29"><a href="#cb135-29"></a><span class="kw">module</span> <span class="dt">AESA.PC.R2</span> <span class="kw">where</span></span></code></pre></div>
<p>We import the ForSyDe-Atom libraries that are used:</p>
<div class="sourceCode" id="cb136" data-startFrom="33"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 32;"><span id="cb136-33"><a href="#cb136-33"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a>  <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb136-34"><a href="#cb136-34"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">ForSyDe.Atom.MoC.SDF</span></a> <span class="kw">as</span> <span class="dt">SDF</span></span>
<span id="cb136-35"><a href="#cb136-35"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a> <span class="kw">as</span> <span class="dt">V</span></span></code></pre></div>
<p>We import the <code>Complex</code> type. However, unlike previously, we now use our in-house <code>ForSyDe.Deep.Complex</code> module. This module is in fact re-exporting <code>Data.Complex</code> along with some additional instances which makes it synthesizable, plus a couple of custom arithmetic operators <code>(+:)</code>, <code>(-:)</code>, <code>(*:)</code> which do not force the base type of <code>Complex a</code> to be a part of <code>RealFloat</code> class (see <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Complex.html"><code>Data.Complex</code> API</a>), but rather any <code>Num</code> type.</p>
<div class="sourceCode" id="cb137" data-startFrom="45"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 44;"><span id="cb137-45"><a href="#cb137-45"></a><span class="kw">import</span> <span class="dt">ForSyDe.Deep.Complex</span></span></code></pre></div>
<p>We import our in-house fixed point data types. This module exports the usual types such as <code>Fixed8</code>, <code>Fixed16</code>, <code>Fixed32</code> and <code>Fixed64</code>. For this report we have extended the <code>forsyde-deep</code> package with a custom (synthesizable) <code>Fixed20</code> type, hard-coded across the full compiler stack. Future versions of ForyDe-Deep will most likely support arbitrary-precision fixed point types using type-level numerals instead, similar to <code>FSVec</code>, but for simple demonstration purposes <code>Fixed20</code> suffices at the moment.</p>
<div class="sourceCode" id="cb138" data-startFrom="54"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 53;"><span id="cb138-54"><a href="#cb138-54"></a><span class="kw">import</span> <span class="dt">ForSyDe.Deep.Fixed</span></span></code></pre></div>
<p>Finally, we import the functions defined in the previous refinement stage.</p>
<div class="sourceCode" id="cb139" data-startFrom="58"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 57;"><span id="cb139-58"><a href="#cb139-58"></a><span class="kw">import</span> <span class="dt">AESA.PC.R1</span> (coefsR1, pcFIR)</span></code></pre></div>
<p>We translate the floating point FIR coefficients from the first refinement phase to Q19 complex numbers.</p>
<div class="sourceCode" id="cb140" data-startFrom="63"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 62;"><span id="cb140-63"><a href="#cb140-63"></a>coefsR2 <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.farm11</a> ((<span class="op">:+</span><span class="dv">0</span>) <span class="op">.</span> realToFixed20)<span class="ot"> coefsR1 ::</span> <span class="dt">Vector</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span></code></pre></div>
<p>For <code>procPC''</code> we use the previously defined <code>pcFIR</code> process constructor whose function layer entities are now replaced with operations over <code>Complex Fixed20</code> numbers. This eases the validation process: we now need to test only that the function layer refinements respect the specifications, and not the whole system.</p>
<div class="sourceCode" id="cb141" data-startFrom="70"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 69;"><span id="cb141-70"><a href="#cb141-70"></a><span class="ot">procPC&#39;&#39; ::</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb141-71"><a href="#cb141-71"></a>         <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb141-72"><a href="#cb141-72"></a>procPC&#39;&#39; <span class="ot">=</span> pcFIR (<span class="op">+:</span>) (<span class="op">*:</span>) (<span class="dv">0</span><span class="op">:+</span><span class="dv">0</span>) coefsR2</span></code></pre></div>
<p>The PC’’ stage process (network) is the same one as in the previous refinement, except that it uses the <code>procPC''</code> as the base process.</p>
<div class="sourceCode" id="cb142" data-startFrom="77"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 76;"><span id="cb142-77"><a href="#cb142-77"></a><span class="ot">pc&#39;&#39; ::</span> <span class="dt">Vector</span> ( <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>))</span>
<span id="cb142-78"><a href="#cb142-78"></a>     <span class="ot">-&gt;</span> <span class="dt">Vector</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>))</span>
<span id="cb142-79"><a href="#cb142-79"></a>pc&#39;&#39; <span class="ot">=</span> farm11 <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(SY.toSDF1</a> <span class="op">.</span> procPC&#39;&#39;)</span></code></pre></div>
<h3 data-number="7.2.2" id="simulation-1"><span class="header-section-number">7.2.2</span> Simulation</h3>
<p>In order to be able to “plug in” PC’’ into the AESA signal processing system, we need to wrap it so that its type signature is the one expected. We thus define the following wrapper which translates the floating point numbers fed into PC to fixed point Q19 and back:</p>
<div class="sourceCode" id="cb143" data-startFrom="88"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 87;"><span id="cb143-88"><a href="#cb143-88"></a>wrapR2 f <span class="ot">=</span> farm11 <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(SDF.actor11</a> (<span class="dv">1</span>,<span class="dv">1</span>,(<span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span>) fixed20ToReal))</span>
<span id="cb143-89"><a href="#cb143-89"></a>           <span class="op">.</span> f <span class="op">.</span> farm11 <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(SY.comb11</a> (<span class="fu">fmap</span> realToFixed20))</span></code></pre></div>
<p>which is then used to wrap <code>pc''</code> so that it looks like <code>pc</code>.</p>
<div class="sourceCode" id="cb144" data-startFrom="93"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 92;"><span id="cb144-93"><a href="#cb144-93"></a><span class="ot">wrappedPC&#39;&#39; ::</span> <span class="dt">Vector</span> ( <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Float</span>))</span>
<span id="cb144-94"><a href="#cb144-94"></a>            <span class="ot">-&gt;</span> <span class="dt">Vector</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Float</span>))</span>
<span id="cb144-95"><a href="#cb144-95"></a>wrappedPC&#39;&#39; <span class="ot">=</span> wrapR2 pc&#39;&#39;</span></code></pre></div>
<p>The effect of the refined PC’’ signal processing stage can be observed by simulating the AESA application instantiating <code>wrappedPC''</code>. Please refer to the project’s <code>README</code> file on how to execute the program. When plotting the results against the same input data, we can see that the same 13 objects are detected, albeit having different numerical values.</p>
<h3 data-number="7.2.3" id="properties-1"><span class="header-section-number">7.2.3</span> Properties</h3>
<p>In the second refinement phase the properties target mainly the translations between the floating point and fixed point representations. We define a new module with the usual preamble:</p>
<div class="sourceCode" id="cb145" data-startFrom="7"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 6;"><span id="cb145-7"><a href="#cb145-7"></a><span class="ot">{-# LANGUAGE PackageImports #-}</span></span>
<span id="cb145-8"><a href="#cb145-8"></a><span class="kw">module</span> <span class="dt">TestR2</span> <span class="kw">where</span></span></code></pre></div>
<blockquote>
<div class="sourceCode" id="cb146" data-startFrom="10"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 9;"><span id="cb146-10"><a href="#cb146-10"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a> <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb146-11"><a href="#cb146-11"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">ForSyDe.Atom.MoC.SDF</span></a> <span class="kw">as</span> <span class="dt">SDF</span></span>
<span id="cb146-12"><a href="#cb146-12"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a> (farm11)</span>
<span id="cb146-13"><a href="#cb146-13"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></span>
<span id="cb146-14"><a href="#cb146-14"></a><span class="kw">import</span> <span class="dt">ForSyDe.Deep.Complex</span></span>
<span id="cb146-15"><a href="#cb146-15"></a><span class="kw">import</span> <span class="dt">ForSyDe.Deep.Fixed</span></span></code></pre></div>
<div class="sourceCode" id="cb147" data-startFrom="17"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 16;"><span id="cb147-17"><a href="#cb147-17"></a><span class="kw">import</span> <span class="dt">Generators</span> (sySignals, decimalCpxNum, decimalCpxRat)</span>
<span id="cb147-18"><a href="#cb147-18"></a><span class="kw">import</span> <span class="dt">AESA.PC.R1</span> <span class="kw">as</span> <span class="dt">R1</span></span>
<span id="cb147-19"><a href="#cb147-19"></a><span class="kw">import</span> <span class="dt">AESA.PC.R2</span> <span class="kw">as</span> <span class="dt">R2</span></span>
<span id="cb147-20"><a href="#cb147-20"></a><span class="kw">import</span> <span class="dt">AESA.Params</span> (pcTap)</span></code></pre></div>
</blockquote>
<p>The first property we check is that even when wrapped (i.e. going through two translations), the <code>procPC''</code> does not overflow its legal input/output value range, i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>,</mo><mn>1</mn><mo>+</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[-1-i,1+i)</annotation></semantics></math>. For this we write a local process wrapper <code>wrapProc</code>. <span id="eq:prop_refine2_values"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>v</mi><mo>∈</mo><mo stretchy="false" form="prefix">⟨</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo stretchy="false" form="postfix">⟩</mo><mo>,</mo><mi>a</mi><mo>∈</mo><mi>v</mi><mo>,</mo><mi>b</mi><mo>∈</mo><mstyle mathvariant="monospace"><mi>𝚙</mi><mi>𝚛</mi><mi>𝚘</mi><mi>𝚌</mi><mi>𝙿</mi><mi>𝙲</mi><mi>″</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>v</mi><mo stretchy="false" form="prefix">|</mo><mo>&gt;</mo><mn>0</mn><mo>∧</mo><mi>a</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>,</mo><mn>1</mn><mo>+</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>⇒</mo><mi>b</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi><mo>,</mo><mn>1</mn><mo>+</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>24</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall v \in \langle\mathbb{C}\rangle, a \in v, b \in \mathtt{procPC&#39;&#39;}(v) : |v| &gt; 0 \wedge a \in [-1-i,1+i) \Rightarrow b \in [-1-i,1+i)
\qquad(24)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb148" data-startFrom="29"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 28;"><span id="cb148-29"><a href="#cb148-29"></a>prop_refine2_values <span class="ot">=</span> forAll (sySignals decimalCpxNum)</span>
<span id="cb148-30"><a href="#cb148-30"></a>                      <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="fu">all</span> (withinRangeComplex (<span class="op">-</span><span class="dv">1</span>) <span class="dv">1</span>)</span>
<span id="cb148-31"><a href="#cb148-31"></a>                              <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a> <span class="op">$</span> wrapProc R2.procPC&#39;&#39; <span class="op">$</span> s</span>
<span id="cb148-32"><a href="#cb148-32"></a>  <span class="kw">where</span></span>
<span id="cb148-33"><a href="#cb148-33"></a>    wrapProc p <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> (<span class="fu">fmap</span> fixed20ToReal) <span class="op">.</span> p <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> (<span class="fu">fmap</span> realToFixed20)</span>
<span id="cb148-34"><a href="#cb148-34"></a>    withinRangeComplex a b c</span>
<span id="cb148-35"><a href="#cb148-35"></a>      <span class="op">|</span> realPart c <span class="op">&lt;</span>  a <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb148-36"><a href="#cb148-36"></a>      <span class="op">|</span> imagPart c <span class="op">&lt;</span>  a <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb148-37"><a href="#cb148-37"></a>      <span class="op">|</span> realPart c <span class="op">&gt;=</span> b <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb148-38"><a href="#cb148-38"></a>      <span class="op">|</span> imagPart c <span class="op">&gt;=</span> b <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb148-39"><a href="#cb148-39"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>The second property we want to test is that the cumulative quantization error stays within a constant, accepted range. Again, we cannot use floating point numbers as samples for comparison, due to the dynamic quantization error of their own representation. As before, we fall back to rationals which constitute a good model. The cumulative error for one PC’’ channel, supposing that both multiplications and addition results are truncated back to Q19, can be calculated with:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>=</mo><msub><mi>ϵ</mi><mrow><mi>Q</mi><mn>19</mn></mrow></msub><mo>*</mo><msub><mi>N</mi><mrow><mi>t</mi><mi>a</mi><mi>p</mi></mrow></msub><mo>=</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>19</mn></mrow></msup><mo>×</mo><msub><mi>N</mi><mrow><mi>t</mi><mi>a</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">
\epsilon = \epsilon_{Q19} * N_{tap} = 2^{-19} \times N_{tap}
</annotation></semantics></math></p>
<div class="sourceCode" id="cb149" data-startFrom="52"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 51;"><span id="cb149-52"><a href="#cb149-52"></a>prop_refine2_error <span class="ot">=</span> forAll (sySignals decimalCpxRat)</span>
<span id="cb149-53"><a href="#cb149-53"></a>                     <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="fu">all</span> acceptable <span class="op">$</span> <span class="fu">zip</span> (rationalPcVals s) (fixed20PcVals s)</span>
<span id="cb149-54"><a href="#cb149-54"></a>  <span class="kw">where</span></span>
<span id="cb149-55"><a href="#cb149-55"></a>    rationalPcVals s <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a> <span class="op">$</span> procPCRationals s</span>
<span id="cb149-56"><a href="#cb149-56"></a>    fixed20PcVals  s <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a> <span class="op">$</span> procPC&#39;&#39; <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.comb11</a> (<span class="fu">fmap</span> realToFixed20) s</span>
<span id="cb149-57"><a href="#cb149-57"></a>    procPCRationals  <span class="ot">=</span> pcFIR (<span class="op">+:</span>) (<span class="op">*:</span>) (<span class="dv">0</span><span class="op">:+</span><span class="dv">0</span>) (farm11 ((<span class="op">:+</span><span class="dv">0</span>) <span class="op">.</span> <span class="fu">realToFrac</span>) coefsR1)</span>
<span id="cb149-58"><a href="#cb149-58"></a>    <span class="co">-----------------------------------</span></span>
<span id="cb149-59"><a href="#cb149-59"></a>    acceptable (rat, f20) <span class="ot">=</span> <span class="kw">let</span> rp <span class="ot">=</span> <span class="fu">abs</span> (realPart rat <span class="op">-</span> (fixed20ToReal <span class="op">$</span> realPart f20))</span>
<span id="cb149-60"><a href="#cb149-60"></a>                                ip <span class="ot">=</span> <span class="fu">abs</span> (imagPart rat <span class="op">-</span> (fixed20ToReal <span class="op">$</span> imagPart f20))</span>
<span id="cb149-61"><a href="#cb149-61"></a>                            <span class="kw">in</span> rp <span class="op">&lt;=</span> epsilon <span class="op">&amp;&amp;</span> ip <span class="op">&lt;=</span> epsilon</span>
<span id="cb149-62"><a href="#cb149-62"></a>    epsilon <span class="ot">=</span> (<span class="fu">realToFrac</span> pcTap) <span class="op">*</span> <span class="dv">2</span><span class="op">^^</span>(<span class="op">-</span><span class="dv">19</span>)</span></code></pre></div>
<p>Notice that we have instantiated a clone <code>procPC''</code> which works on rational numbers called <code>procPCRationals</code> using the <code>pcFIR</code> process constructor. We needed this process to compare the rational outputs against the fixed point ones.</p>
<h2 data-number="7.3" id="sec:synth-r3"><span class="header-section-number">7.3</span> Refinement 3: Deep Language Embedding</h2>
<p>In this refinement phase we translate the PC’’ system defined in the previous phase to a language more appropriate for synthesis. Up until now we have used the shallow-embedded DSLs of ForSyDe, namely ForSyDe-Atom and ForSyDe-Shallow. In this section we will start using ForSyDe-Deep, a deep-embedded DSL, capable of extracting a system’s internal structure as a netlist and synthesizing it to different backends (at present GraphML and VHDL).</p>
<h3 data-number="7.3.1" id="sec:crash-deep"><span class="header-section-number">7.3.1</span> Quick Introduction to ForSyDe-Deep</h3>
<p>ForSyDe-Deep was originally created as a replacement for ForSyDe-Shallow. It provides a sub-set of the ForSyDe-Shallow language and, in principle, is based on the same modeling concepts. However its deep-embedded features (such as netlist traversing and language parsing) makes it much more verbose than its shallow counterparts. This is why its syntax appeals less to new users, hence it became it a fall-back framework for synthesis purposes only. Nevertheless translating from a shallow ForSyDe model to a deep one is straightforward, once you understand the principles listed as follows. For more on ForSyDe-Deep modeling, refer to the beginner tutorials on the ForSyDe <a href="https://forsyde.github.io/forsyde-deep/">homepage</a>.</p>
<figure>
<img src="figs/deep-syntax.png" id="fig:deep-syntax" alt="" /><figcaption>Figure 41: The difference between a shallow ForSyDe system (left) and a deep one (right)</figcaption>
</figure>
<ul>
<li><p>process functions are parsed to their AST using a language extension of Haskell called TemplateHaskell. The function parser is able to recognize a subset of the Haskell language written between the so-called banana brackets <code>[d| function |]</code>, and needs to <em>explicitly specify its type signature</em>. Whatever code is written within the banana brackets is parsed as-is and needs to be self-contained, i.e. information cannot be inferred from global/system-wide definitions. In order to instantiate a parsable ForSyDe-Deep function from a Haskell function, it needs to be wrapped into a <code>ProcFun</code> type, using one of the <a href="http://hackage.haskell.org/package/forsyde-deep-0.2.0/docs/ForSyDe-Deep-Process.html">function wrappers</a> provided by the API.</p></li>
<li><p>processes are instantiated using the ForSyDe-Deep equivalents of the main ForSyDe-Shallow <a href="http://hackage.haskell.org/package/forsyde-deep-0.2.0/docs/ForSyDe-Deep-Process-SynchProc.html">SY process constructors</a>. The main difference is that they need a string identifier as well as <code>ProcFun</code>-wrapped functions instead of regular Haskell functions.</p></li>
<li><p>in order to be able to simulate, parse or synthesize a process, it needs to be wrapped within a <code>SysDef</code> type, similarly to parsable functions, using one of the API-provided <a href="http://hackage.haskell.org/package/forsyde-deep-0.2.0/docs/ForSyDe-Deep-System.html">system definition wrappers</a>. These system wrappers, apart from a fully applied process, need also a unique string identifier for the new system, as well as name identifiers for all its input and output ports.</p></li>
<li><p>in order to use a defined system hierarchically as a component, it needs to be <a href="http://hackage.haskell.org/package/forsyde-deep-0.2.0/docs/ForSyDe-Deep-System.html">instantiated</a> back to a composable function. A process instance needs a unique name identifier, as well as a <code>SysDef</code> object.</p></li>
</ul>
<p><strong>N.B.:</strong> That is quite a mouthful of wrappers and, as you will see in the PC example below, it implies a quite some unpleasant verbosity, especially for one used to the elegant compactness of Haskell programs. Future iterations of the ForSyDe language will most likely have a unified syntax and translation from shallow (for efficient simulation) to deep (for structure parsing and synthesis) versions will be done automatically. For now the current (type-extended) version of ForSyDe-Deep suffices for demonstration purposes since the modeling principles are the same no matter the frontend language.</p>
<h3 data-number="7.3.2" id="model-2"><span class="header-section-number">7.3.2</span> Model</h3>
<p>We create a new module for this refinement phase. The <code>TemplateHaskell</code> and <code>FlexibleContexts</code> language extensions are mandatory.</p>
<div class="sourceCode" id="cb150" data-startFrom="69"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 68;"><span id="cb150-69"><a href="#cb150-69"></a><span class="ot">{-# LANGUAGE PackageImports, TemplateHaskell, FlexibleContexts #-}</span></span>
<span id="cb150-70"><a href="#cb150-70"></a><span class="kw">module</span> <span class="dt">AESA.PC.R3</span> <span class="kw">where</span></span></code></pre></div>
<p>We import some ForSyDe-Atom types, only for co-simulation wrapping.</p>
<div class="sourceCode" id="cb151" data-startFrom="74"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 73;"><span id="cb151-74"><a href="#cb151-74"></a><span class="kw">import</span> <span class="kw">qualified</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a>  <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb151-75"><a href="#cb151-75"></a><span class="kw">import</span> <span class="kw">qualified</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html"><span class="dt">ForSyDe.Atom.MoC.SDF</span></a> <span class="kw">as</span> <span class="dt">SDF</span></span>
<span id="cb151-76"><a href="#cb151-76"></a><span class="kw">import</span> <span class="kw">qualified</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">ForSyDe.Atom.Skel.FastVector</span></a> <span class="kw">as</span> <span class="dt">V</span></span></code></pre></div>
<p>We import the ForSyDe-Deep libraries. The <code>ForSyDe.Deep.Skeletons</code> library belongs to the package extension built for this case study and contains a couple of deep-embedded (synthesizable) skeletons, as presented in sections <a href="#sec:atom">2</a>, <a href="#sec:refine">6</a>.</p>
<div class="sourceCode" id="cb152" data-startFrom="82"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 81;"><span id="cb152-82"><a href="#cb152-82"></a><span class="kw">import</span> <span class="dt">ForSyDe.Deep</span></span>
<span id="cb152-83"><a href="#cb152-83"></a><span class="kw">import</span> <span class="dt">ForSyDe.Deep.Skeleton</span> <span class="kw">as</span> <span class="dt">Sk</span></span></code></pre></div>
<p>We need some additional type libraries. <code>Data.Param.FSVec</code> defines fixed-size vectors as compared to the shallow vectors used until now, e.g. <code>ForSyDe.Atom.Skel.FastVector</code>. Fixed-size vectors have their length captured in the type signature as type-level numerals imported from <code>Data.TypeLevel.Num</code>. For example <code>(FSVec D8 a)</code> denotes a fixed-size vector of type a, with the size of 8 elements. We also use list functions, thus we can tell their functions apart by loading the two libraries using different aliases.</p>
<div class="sourceCode" id="cb153" data-startFrom="93"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 92;"><span id="cb153-93"><a href="#cb153-93"></a><span class="kw">import</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb153-94"><a href="#cb153-94"></a><span class="kw">import</span> <span class="dt">Data.Param.FSVec</span> <span class="kw">as</span> <span class="dt">FSV</span></span>
<span id="cb153-95"><a href="#cb153-95"></a><span class="kw">import</span> <span class="dt">Data.TypeLevel.Num</span> <span class="kw">hiding</span> ((+), (-), (==)) </span></code></pre></div>
<p>Finally, we import some functions from the previous refinement phase, as well as some system constants.</p>
<div class="sourceCode" id="cb154" data-startFrom="100"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 99;"><span id="cb154-100"><a href="#cb154-100"></a><span class="kw">import</span> <span class="dt">AESA.PC.R2</span> (coefsR2, wrapR2)</span>
<span id="cb154-101"><a href="#cb154-101"></a><span class="kw">import</span> <span class="dt">AESA.Params</span> (nb)</span></code></pre></div>
<p>For starters, let us define the adder process used in the <code>fir'</code> skeleton. According to the crash course in section <a href="#sec:crash-deep">7.3.1</a> we need to gradually wrap its elements until it becomes a system definition <code>SysDef</code>. First, we need to declare a <code>ProcFun</code> element from a Haskell addition function. As already mentioned, whatever is written between the banana brackets needs to be self-contained. This means that the <code>Num</code> type instance of <code>Complex</code> which overloads the <code>(+)</code> operator is not of much use here. Complex number addition needs to be explicitly written so that the parser know what to synthesize (N.B. type class support is listed among the “todo” items of future ForSyDe language versions).</p>
<div class="sourceCode" id="cb155" data-startFrom="113"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 112;"><span id="cb155-113"><a href="#cb155-113"></a><span class="ot">addFun ::</span> <span class="dt">ProcFun</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span> <span class="dt">Fixed20</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb155-114"><a href="#cb155-114"></a>addFun <span class="ot">=</span> <span class="op">$</span>(newProcFun</span>
<span id="cb155-115"><a href="#cb155-115"></a>           [d|addf :: Complex Fixed20 -&gt; Complex Fixed20 -&gt; Complex Fixed20</span>
<span id="cb155-116"><a href="#cb155-116"></a>              addf (x :+ y) (x&#39; :+ y&#39;) = (x + x&#39;) :+ (y + y&#39;)  |])</span></code></pre></div>
<p>The addition process is created by passing an identifier and the newly defined <code>ProcFun</code> to the process constructor <code>zipWithSY</code> (i.e. the equivalent of <code>SY.comb21</code> in ForSyDe-Atom).</p>
<div class="sourceCode" id="cb156" data-startFrom="122"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 121;"><span id="cb156-122"><a href="#cb156-122"></a><span class="ot">addProc ::</span> <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb156-123"><a href="#cb156-123"></a>        <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb156-124"><a href="#cb156-124"></a>        <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb156-125"><a href="#cb156-125"></a>addProc <span class="ot">=</span> zipWithSY <span class="st">&quot;addProc&quot;</span> addFun</span></code></pre></div>
<p>From this process we create the component identified as <code>"add"</code>, with two input ports <code>"i1"</code> and <code>"i2"</code> and an output port <code>"o1"</code>.</p>
<div class="sourceCode" id="cb157" data-startFrom="130"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 129;"><span id="cb157-130"><a href="#cb157-130"></a><span class="ot">addSys ::</span> <span class="dt">SysDef</span> (  <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb157-131"><a href="#cb157-131"></a>                 <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb157-132"><a href="#cb157-132"></a>                 <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>) )</span>
<span id="cb157-133"><a href="#cb157-133"></a>addSys <span class="ot">=</span> newSysDef addProc <span class="st">&quot;add&quot;</span> [<span class="st">&quot;i1&quot;</span>,<span class="st">&quot;i2&quot;</span>] [<span class="st">&quot;o1&quot;</span>]</span></code></pre></div>
<p>Similarly, we define the <code>"mul"</code> component, but this time in one go. Notice again the expanded complex number multiplication. Instead of the normal multiplication operator <code>(*)</code> we use the in-house <code>fixmul20</code> function, which multiplies two Q19 numbers and truncates the result back to Q19. In the shallow simulation <code>fixmul20</code> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≡</mo><annotation encoding="application/x-tex">\equiv</annotation></semantics></math> <code>(*)</code>, but in the deep version <code>fixmul20</code> synthesizes to a custom VHDL <code>std_vector</code> function instead of the regular VHDL <code>*</code> operator.</p>
<div class="sourceCode" id="cb158" data-startFrom="142"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 141;"><span id="cb158-142"><a href="#cb158-142"></a><span class="ot">mulSys ::</span> <span class="dt">SysDef</span> (  <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb158-143"><a href="#cb158-143"></a>                 <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb158-144"><a href="#cb158-144"></a>                 <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>) )</span>
<span id="cb158-145"><a href="#cb158-145"></a>mulSys <span class="ot">=</span> newSysDef (zipWithSY <span class="st">&quot;mulProc&quot;</span> mulFun) <span class="st">&quot;mul&quot;</span> [<span class="st">&quot;i1&quot;</span>,<span class="st">&quot;i2&quot;</span>] [<span class="st">&quot;o1&quot;</span>]</span>
<span id="cb158-146"><a href="#cb158-146"></a>  <span class="kw">where</span> </span>
<span id="cb158-147"><a href="#cb158-147"></a>    mulFun <span class="ot">=</span> <span class="op">$</span>(newProcFun</span>
<span id="cb158-148"><a href="#cb158-148"></a>               [d|mulf :: Complex Fixed20 -&gt; Complex Fixed20 -&gt; Complex Fixed20 </span>
<span id="cb158-149"><a href="#cb158-149"></a>                  mulf (x :+ y) (x&#39; :+ y&#39;) = (fixmul20 x x&#39; - fixmul20 y y&#39;) :+</span>
<span id="cb158-150"><a href="#cb158-150"></a>                                             (fixmul20 x y&#39; + fixmul20 y x&#39;) |])</span></code></pre></div>
<p>The reset-delay FSM used as a delay element in the <code>fir'</code> pattern needs also to be defined as a component. We define the <code>"rDelay"</code> component using the <code>mooreSY</code> process constructors, taking two <code>ProcFun</code>s for the next state function <code>countReset</code> and output decoder <code>propagate</code>. We fix the counter value type to be <code>Int16</code>. The globally-defined <code>nb</code> (i.e. the number of range bins <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>b</mi></msub><annotation encoding="application/x-tex">N_b</annotation></semantics></math>) cannot be recognized as-is inside the banana brackets, and for now all we can do is to write the number explicitly. (N.B. support for partial function application is listed among the “todo” items of future ForSyDe language versions).</p>
<div class="sourceCode" id="cb159" data-startFrom="161"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 160;"><span id="cb159-161"><a href="#cb159-161"></a><span class="ot">rDelaySys ::</span> <span class="dt">SysDef</span> (<span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>) <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>))</span>
<span id="cb159-162"><a href="#cb159-162"></a>rDelaySys <span class="ot">=</span> newSysDef (mooreSY <span class="st">&quot;rDelayProc&quot;</span> countReset propagate(<span class="dv">0</span>, <span class="dv">0</span> <span class="op">:+</span> <span class="dv">0</span>))</span>
<span id="cb159-163"><a href="#cb159-163"></a>            <span class="st">&quot;rDelay&quot;</span> [<span class="st">&quot;i1&quot;</span>] [<span class="st">&quot;o1&quot;</span>]</span>
<span id="cb159-164"><a href="#cb159-164"></a>  <span class="kw">where</span></span>
<span id="cb159-165"><a href="#cb159-165"></a>    countReset <span class="ot">=</span> <span class="op">$</span>(newProcFun</span>
<span id="cb159-166"><a href="#cb159-166"></a>                   [d|cntf :: (Int16,Complex Fixed20) -&gt; Complex Fixed20</span>
<span id="cb159-167"><a href="#cb159-167"></a>                           -&gt; (Int16,Complex Fixed20) </span>
<span id="cb159-168"><a href="#cb159-168"></a>                      cntf(c,_) p = if c == 1024-1</span>
<span id="cb159-169"><a href="#cb159-169"></a>                                    then (0, 0 :+ 0)</span>
<span id="cb159-170"><a href="#cb159-170"></a>                                    else (c+1,p) |])</span>
<span id="cb159-171"><a href="#cb159-171"></a>    propagate  <span class="ot">=</span> <span class="op">$</span>(newProcFun</span>
<span id="cb159-172"><a href="#cb159-172"></a>                   [d|prpf :: (Int16,Complex Fixed20) -&gt; Complex Fixed20 </span>
<span id="cb159-173"><a href="#cb159-173"></a>                      prpf (_,p) = p |])</span></code></pre></div>
<p>Because partial application is not yet supported we need to instantiate the vector of coefficients into a farm of <code>constSY</code> signal generators. We thus create the “system constructor”:</p>
<div class="sourceCode" id="cb160" data-startFrom="179"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 178;"><span id="cb160-179"><a href="#cb160-179"></a><span class="ot">constSys ::</span> <span class="dt">ProcId</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span> <span class="dt">Fixed20</span> <span class="ot">-&gt;</span> <span class="dt">SysDef</span> (<span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>))</span>
<span id="cb160-180"><a href="#cb160-180"></a>constSys name c <span class="ot">=</span> newSysDef (constSY <span class="st">&quot;const&quot;</span> c) name [<span class="st">&quot;i1&quot;</span>] [<span class="st">&quot;o1&quot;</span>]</span></code></pre></div>
<p>which we then use as argument for the <code>app11</code> skeleton (which is in fact a <code>farm11</code> tailored for partial application only) to instantiate a farm of constant signal generators, i.e. a vector of constant signals. The coefficients are interpreted into a <code>FSVec</code> from their shallow counterparts defined in the second refinement phase.</p>
<div class="sourceCode" id="cb161" data-startFrom="187"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 186;"><span id="cb161-187"><a href="#cb161-187"></a>coefsR3 <span class="ot">=</span> Sk.app11 <span class="st">&quot;coef&quot;</span> constSys coefs</span>
<span id="cb161-188"><a href="#cb161-188"></a>  <span class="kw">where</span></span>
<span id="cb161-189"><a href="#cb161-189"></a>    coefs <span class="ot">=</span> <span class="op">$</span>(vectorTH <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">(V.fromVector</a><span class="ot"> coefsR2 ::</span> [<span class="dt">Complex</span> <span class="dt">Fixed20</span>]))</span></code></pre></div>
<p><strong>OBS:</strong> ForSyDe-Deep skeletons, as compared to their shallow counterparts, take care of <em>creating instances</em> (see Figure <a href="#fig:deep-syntax">41</a>) of defined systems as well as coupling them together. This is why they need components as arguments instead of simple functions.</p>
<p>Now, for didactic purpose, let us define ForSyDe-Deep equivalent of the <code>fir'</code> skeleton using the base catamorphisms <em>recur</em> (or its specialization <em>generate</em>), <em>farm</em> and <em>reduce</em>. We call this process network constructor <code>deepFIR</code> and, as you can see, it is defined similarly to its shallow counterpart, with a few exceptions: 1) it expects a base identifier, to create unique IDs for all the generated component instances; 2) it takes <code>SysDef</code> components instead of processes as arguments; 3) for coefficients it requires a fixed-size vector of strictly positive size, containing constants.</p>
<div class="sourceCode" id="cb162" data-startFrom="205"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 204;"><span id="cb162-205"><a href="#cb162-205"></a><span class="ot">deepFIR ::</span> (<span class="dt">SysFun</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a), <span class="dt">SysFun</span> (c <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a), <span class="dt">SysFun</span> (a <span class="ot">-&gt;</span> a),</span>
<span id="cb162-206"><a href="#cb162-206"></a>           <span class="dt">Pos</span> s&#39;, <span class="dt">Succ</span> s&#39; s)</span>
<span id="cb162-207"><a href="#cb162-207"></a>       <span class="ot">=&gt;</span> <span class="dt">ProcId</span>                <span class="co">-- ^ system ID</span></span>
<span id="cb162-208"><a href="#cb162-208"></a>       <span class="ot">-&gt;</span> <span class="dt">SysDef</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)  <span class="co">-- ^ process/operation replacing &#39;+&#39;</span></span>
<span id="cb162-209"><a href="#cb162-209"></a>       <span class="ot">-&gt;</span> <span class="dt">SysDef</span> (c <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)  <span class="co">-- ^ process/operation replacing &#39;*&#39;</span></span>
<span id="cb162-210"><a href="#cb162-210"></a>       <span class="ot">-&gt;</span> <span class="dt">SysDef</span> (a <span class="ot">-&gt;</span> a)       <span class="co">-- ^ delay process</span></span>
<span id="cb162-211"><a href="#cb162-211"></a>       <span class="ot">-&gt;</span> <span class="dt">FSVec</span> s c             <span class="co">-- ^ vector of coefficients</span></span>
<span id="cb162-212"><a href="#cb162-212"></a>       <span class="ot">-&gt;</span> a                     <span class="co">-- ^ input signal/structure </span></span>
<span id="cb162-213"><a href="#cb162-213"></a>       <span class="ot">-&gt;</span> a                     <span class="co">-- ^ output signal/structure</span></span>
<span id="cb162-214"><a href="#cb162-214"></a>deepFIR name addSys mulSys dlySys coefs <span class="ot">=</span></span>
<span id="cb162-215"><a href="#cb162-215"></a>  Sk.reduce addName addSys <span class="op">.</span> Sk.farm21 mulName mulSys coefs <span class="op">.</span> Sk.generate dlyName n dlySys</span>
<span id="cb162-216"><a href="#cb162-216"></a>  <span class="kw">where</span> n <span class="ot">=</span> lengthT coefs</span>
<span id="cb162-217"><a href="#cb162-217"></a>        dlyName <span class="ot">=</span> name <span class="op">L.++</span> <span class="st">&quot;_dly_&quot;</span></span>
<span id="cb162-218"><a href="#cb162-218"></a>        addName <span class="ot">=</span> name <span class="op">L.++</span> <span class="st">&quot;_add_&quot;</span></span>
<span id="cb162-219"><a href="#cb162-219"></a>        mulName <span class="ot">=</span> name <span class="op">L.++</span> <span class="st">&quot;_mul_&quot;</span></span></code></pre></div>
<p>We finally can define a component for the deep equivalent of <code>procPC</code> using the <code>deepFIR</code> process network constructor, by passing the above-defined components as arguments.</p>
<div class="sourceCode" id="cb163" data-startFrom="225"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 224;"><span id="cb163-225"><a href="#cb163-225"></a><span class="ot">procPCSys ::</span> <span class="dt">SysDef</span> (  <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb163-226"><a href="#cb163-226"></a>                    <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>) )</span>
<span id="cb163-227"><a href="#cb163-227"></a>procPCSys <span class="ot">=</span> newSysDef (deepFIR <span class="st">&quot;fir&quot;</span> addSys mulSys rDelaySys coefsR3)</span>
<span id="cb163-228"><a href="#cb163-228"></a>            <span class="st">&quot;FIR&quot;</span> [<span class="st">&quot;i1&quot;</span>] [<span class="st">&quot;o1&quot;</span>]</span></code></pre></div>
<p>and the deep equivalent of the PC process, statically defining its size as a type-level numeral equal to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>b</mi></msub><annotation encoding="application/x-tex">N_b</annotation></semantics></math></p>
<div class="sourceCode" id="cb164" data-startFrom="233"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 232;"><span id="cb164-233"><a href="#cb164-233"></a><span class="ot">pc3 ::</span> <span class="dt">FSVec</span> <span class="dt">D8</span> (<span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>))</span>
<span id="cb164-234"><a href="#cb164-234"></a>    <span class="ot">-&gt;</span> <span class="dt">FSVec</span> <span class="dt">D8</span> (<span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>))</span>
<span id="cb164-235"><a href="#cb164-235"></a>pc3 <span class="ot">=</span> Sk.farm11 <span class="st">&quot;pc&quot;</span> procPCSys</span></code></pre></div>
<p>with its associate system definition. Unfortunately, at the moment processes of type <code>FSVec a (Signal a) -&gt; ...</code> are not part of the <code>SysFun</code> class, thus we cannot create directly a <code>SysDef</code> components from <code>pc3</code>. What wee <em>can</em> do however is to wrap <code>pc3</code> inside a <code>zipx . pc . unzipx</code> pattern which merely transposes the vector and signal domains, and the synthesizer will simply ignore it. (N.B. vector-based components will be supported in future iterations of ForSyDe).</p>
<div class="sourceCode" id="cb165" data-startFrom="244"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 243;"><span id="cb165-244"><a href="#cb165-244"></a>sysPC3 <span class="ot">=</span> newSysDef (zipxSY <span class="st">&quot;zip&quot;</span> <span class="op">.</span> pc3 <span class="op">.</span> unzipxSY <span class="st">&quot;unzip&quot;</span>) <span class="st">&quot;PC3&quot;</span> [<span class="st">&quot;i1&quot;</span>] [<span class="st">&quot;o1&quot;</span>]</span></code></pre></div>
<h3 data-number="7.3.3" id="simulation.-synthesis"><span class="header-section-number">7.3.3</span> Simulation. Synthesis</h3>
<p>Similarly to the previous refinement stages, we further wrap the PC component in order to co-simulate it with the rest of the AESA system. To simulate a ForSyDe-Deep <code>SysDef</code> component we use the <code>simulate</code> function</p>
<div class="sourceCode" id="cb166" data-startFrom="252"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 251;"><span id="cb166-252"><a href="#cb166-252"></a><span class="ot">wrappedPC3 ::</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">V.Vector</span></a> ( <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">SY.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Float</span>))</span>
<span id="cb166-253"><a href="#cb166-253"></a>           <span class="ot">-&gt;</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html"><span class="dt">V.Vector</span></a> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">(<span class="dt">SDF.Signal</span></a> (<span class="dt">Complex</span> <span class="dt">Float</span>))</span>
<span id="cb166-254"><a href="#cb166-254"></a>wrappedPC3 <span class="ot">=</span> wrapR2 (wrapR3 (simulate sysPC3))</span></code></pre></div>
<p>where <code>wrapR3</code> translates between the shallow ForSyDe-Atom types and the component simulator types.</p>
<div class="sourceCode" id="cb167" data-startFrom="259"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 258;"><span id="cb167-259"><a href="#cb167-259"></a>wrapR3 sim <span class="ot">=</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.vector</a> <span class="op">.</span> L.map <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SDF.html">SDF.signal</a> <span class="op">.</span> L.transpose <span class="op">.</span> L.map FSV.fromVector <span class="op">.</span> sim</span>
<span id="cb167-260"><a href="#cb167-260"></a>             <span class="op">.</span> L.map (FSV.unsafeVector d8) <span class="op">.</span> L.transpose <span class="op">.</span> L.map <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a> <span class="op">.</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-Skel-FastVector.html">V.fromVector</a></span></code></pre></div>
<p>Please refer to the project’s <code>README</code> file for how to execute the AESA system alongside the deep <code>pc3</code> component. The plotted output for running the system against the radar indata generated by the 13 objects is shown in Figure <a href="#fig:deep-r3-odata">42</a>.</p>
<figure>
<img src="figs/AESA_REFINE_R3.png" id="fig:deep-r3-odata" alt="" /><figcaption>Figure 42: One output cube with radar data</figcaption>
</figure>
<p>The PC<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi></mi><mrow><mo stretchy="false" form="prefix">(</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">^{(3)}</annotation></semantics></math> component is not only able to be simulated, but we can also parse its internal structure. Here we call the command which dumps the internal structure of <code>sysPC3</code> as hierarchical GraphML files, as seen in the plots in Figure <a href="#fig:deep-gramhml-r3">43</a>.</p>
<div class="sourceCode" id="cb168" data-startFrom="272"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 271;"><span id="cb168-272"><a href="#cb168-272"></a>graphmlPC3 <span class="ot">=</span> writeGraphML sysPC3</span></code></pre></div>
<figure>
<img src="figs/graphMLR3.png" id="fig:deep-gramhml-r3" alt="" /><figcaption>Figure 43: Dumped GraphML structure: PC (left); FIR (above right); rDelay (below right).</figcaption>
</figure>
<p>Of course, the whole point of writing ForSyDe-Deep is to synthesize to backend code, in this case to synthesizable VHDL code. The following command generates a VHDL project folder with the PC architecture files.</p>
<div class="sourceCode" id="cb169" data-startFrom="280"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 279;"><span id="cb169-280"><a href="#cb169-280"></a>vhdlPC3 <span class="ot">=</span> writeVHDLOps (defaultVHDLOps {debugVHDL <span class="ot">=</span> <span class="dt">VHDLVerbose</span>}) sysPC3</span></code></pre></div>
<p>Furthermore, one can simulate the VHDL files using ModelSim (or alternatively Ghdl), provided their binaries are found in the system <code>PATH</code>. The following function can be wrapped as <code>wrappedPC3</code> instead of <code>simulate sysPC3</code>.</p>
<div class="sourceCode" id="cb170" data-startFrom="286"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 285;"><span id="cb170-286"><a href="#cb170-286"></a>vhdlSim <span class="ot">=</span> writeAndModelsimVHDL <span class="dt">Nothing</span> sysPC3</span></code></pre></div>
<p>Finally, we synthesize <code>sysPC3</code> to FPGA using the Quartus II tool suite (provided its binaries are found in <code>PATH</code>), e.g.:</p>
<div class="sourceCode" id="cb171" data-startFrom="291"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 290;"><span id="cb171-291"><a href="#cb171-291"></a>quartusPC3 <span class="ot">=</span> writeVHDLOps vhdlOps sysPC3</span>
<span id="cb171-292"><a href="#cb171-292"></a>  <span class="kw">where</span> vhdlOps    <span class="ot">=</span> defaultVHDLOps{execQuartus<span class="ot">=</span><span class="dt">Just</span> quartusOps}</span>
<span id="cb171-293"><a href="#cb171-293"></a>        quartusOps <span class="ot">=</span> checkSynthesisQuartus</span></code></pre></div>
<p>After synthesis it generated the RTL structures in Figure <a href="#fig:deep-quartus-r3">44</a>, with the specifications in tbl. <a href="#tbl:deep-spec-r3">3</a>.</p>
<figure>
<img src="figs/RTLR3.png" id="fig:deep-quartus-r3" alt="" /><figcaption>Figure 44: Screenshots of synthesized RTL components: FIR (above); PC (below right); rDelay and mul (below left).</figcaption>
</figure>
<div id="tbl:deep-spec-r3">
<table>
<caption>Table 3: Specifications of generated FPGA design</caption>
<tbody>
<tr class="odd">
<td>Top-level Entity Name</td>
<td>PC3</td>
</tr>
<tr class="even">
<td>Family</td>
<td>Cyclone IV GX</td>
</tr>
<tr class="odd">
<td>Total logic elements</td>
<td>3,014</td>
</tr>
<tr class="even">
<td>Total combinational functions</td>
<td>3,014</td>
</tr>
<tr class="odd">
<td>Dedicated logic registers</td>
<td>976</td>
</tr>
<tr class="even">
<td>Total registers</td>
<td>976</td>
</tr>
<tr class="odd">
<td>Total memory bits</td>
<td>0</td>
</tr>
<tr class="even">
<td>Embedded Multiplier 9-bit elements</td>
<td>160</td>
</tr>
<tr class="odd">
<td>Total PLLs</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="7.3.4" id="properties-2"><span class="header-section-number">7.3.4</span> Properties</h3>
<p>The main property we want to check now is that the ForSyDe-Deep version of PC<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi></mi><mrow><mo stretchy="false" form="prefix">(</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">^{(3)}</annotation></semantics></math> is the same as PC’’ defined in the second refinement phase.</p>
<div class="sourceCode" id="cb172" data-startFrom="6"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 5;"><span id="cb172-6"><a href="#cb172-6"></a><span class="ot">{-# LANGUAGE PackageImports #-}</span></span>
<span id="cb172-7"><a href="#cb172-7"></a><span class="kw">module</span> <span class="dt">TestR3</span> <span class="kw">where</span></span></code></pre></div>
<blockquote>
<div class="sourceCode" id="cb173" data-startFrom="9"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 8;"><span id="cb173-9"><a href="#cb173-9"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a> <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb173-10"><a href="#cb173-10"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></span>
<span id="cb173-11"><a href="#cb173-11"></a><span class="kw">import</span> <span class="dt">ForSyDe.Deep</span></span></code></pre></div>
<div class="sourceCode" id="cb174" data-startFrom="13"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 12;"><span id="cb174-13"><a href="#cb174-13"></a><span class="kw">import</span> <span class="dt">Generators</span> (largeSySigs, cpxFixed20)</span>
<span id="cb174-14"><a href="#cb174-14"></a><span class="kw">import</span> <span class="dt">AESA.PC.R2</span> <span class="kw">as</span> <span class="dt">R2</span></span>
<span id="cb174-15"><a href="#cb174-15"></a><span class="kw">import</span> <span class="dt">AESA.PC.R3</span> <span class="kw">as</span> <span class="dt">R3</span></span></code></pre></div>
</blockquote>
<p>Since fixed point numbers can be compared exactly, we simply use the processes as they are, operating on signals of <code>Fixed20</code> numbers to test the property</p>
<p><span id="eq:prop_refine3_equiv"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>c</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo>⇒</mo><mi>Σ</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="monospace"><mi>𝚙</mi><mi>𝚛</mi><mi>𝚘</mi><mi>𝚌</mi><mi>𝙿</mi><mi>𝙲</mi><mi>″</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>Σ</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="monospace"><mi>𝚜</mi><mi>𝚒</mi><mi>𝚖</mi><mi>𝚞</mi><mi>𝚕</mi><mi>𝚊</mi><mi>𝚝</mi><mi>𝚎</mi><mo stretchy="false" form="prefix">(</mo><mi>𝚙</mi><mi>𝚛</mi><mi>𝚘</mi><mi>𝚌</mi><mi>𝙿</mi><mi>𝙲</mi><mi>𝚂</mi><mi>𝚢</mi><mi>𝚜</mi><mo stretchy="false" form="postfix">)</mo></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>25</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall c \in \mathbb{C} \Rightarrow
\Sigma(\mathtt{procPC&#39;&#39;}(\overline{c})) =
\Sigma(\mathtt{simulate (procPCSys)}(\overline{c}))
\qquad(25)</annotation></semantics></math></span></p>
<div class="sourceCode" id="cb175" data-startFrom="26"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 25;"><span id="cb175-26"><a href="#cb175-26"></a>prop_refine3_equiv <span class="ot">=</span> forAll (largeSySigs cpxFixed20)</span>
<span id="cb175-27"><a href="#cb175-27"></a>                      <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="fu">all</span> (\(a,b) <span class="ot">-&gt;</span> a <span class="op">==</span> b) <span class="op">$</span> <span class="fu">zip</span></span>
<span id="cb175-28"><a href="#cb175-28"></a>                              <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">(SY.fromSignal</a> <span class="op">$</span> R2.procPC&#39;&#39; s)</span>
<span id="cb175-29"><a href="#cb175-29"></a>                              (simulate R3.procPCSys <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a> s)</span></code></pre></div>
<p>Since the test passes flawlessly we can conclude that in the third refinement phase we have achieved semantic equivalence between the components written in the two different languages.</p>
<h2 data-number="7.4" id="sec:synth-r4"><span class="header-section-number">7.4</span> R4: Balancing the FIR Reduction</h2>
<p>The final refinement phase consists in performing some simple semantic-preserving transformations on the previous model in order to optimize the efficiency of the generated circuit.</p>
<p>Two (rather evident) optimizations are considered in this phase:</p>
<ul>
<li><p>as seen in Figures <a href="#fig:deep-gramhml-r3">43</a>, <a href="#fig:deep-quartus-r3">44</a>, as well as in Figure <a href="#fig:fir-pc">40</a>, the final stage of the <code>pcFIR</code>-instantiated process network consists of a reduction pattern. This pattern is instantiated recursively, by taking the result of the previous addition and applying it to the next one, thus generating a linear (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math>) reduction tree. However, the base operation performed, i.e. addition, is commutative, and a well-known catamorphism theorem (see <span class="citation" data-cites="ungureanu2019">Ungureanu et al. (<a href="#ref-ungureanu2019" role="doc-biblioref">2019</a>)</span> for more details) states that the reduction can in fact be performed as a balanced logarithmic (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math>) tree which means, in the case of digital hardware designs, a shorter combinational critical path.</p></li>
<li><p>having a counter in each delay element, although elegant and modular, is a terrible waste of silicon when considering that all counters are counting the same thing: how many samples have passed. A more reasonable design would take advantage of the identical part in all the <code>"rDelay"</code> components (i.e. the counter), and separate from the non-identical part (i.e. the delay register).</p></li>
</ul>
<p>The second optimization is identified and performed automatically by the Quartus compiler, hence the specifications in tbl. <a href="#tbl:deep-spec-r3">3</a> includes only one counter circuit for all the delay elements. Therefore we will only focus on reduction tree balancing and leave the functional decoupling of the reset-counter as an exercise.</p>
<h3 data-number="7.4.1" id="model-3"><span class="header-section-number">7.4.1</span> Model</h3>
<p>The module for the forth refinement module is the following.</p>
<div class="sourceCode" id="cb176" data-startFrom="34"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 33;"><span id="cb176-34"><a href="#cb176-34"></a><span class="ot">{-# LANGUAGE PackageImports, TemplateHaskell, FlexibleContexts #-}</span> </span>
<span id="cb176-35"><a href="#cb176-35"></a><span class="kw">module</span> <span class="dt">AESA.PC.R4</span> <span class="kw">where</span></span></code></pre></div>
<p>We import the same library as before:</p>
<div class="sourceCode" id="cb177" data-startFrom="39"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 38;"><span id="cb177-39"><a href="#cb177-39"></a><span class="kw">import</span> <span class="dt">ForSyDe.Deep</span></span>
<span id="cb177-40"><a href="#cb177-40"></a><span class="kw">import</span> <span class="dt">ForSyDe.Deep.Skeleton</span> <span class="kw">as</span> <span class="dt">Sk</span></span>
<span id="cb177-41"><a href="#cb177-41"></a><span class="kw">import</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb177-42"><a href="#cb177-42"></a><span class="kw">import</span> <span class="dt">Data.Param.FSVec</span> <span class="kw">as</span> <span class="dt">FSV</span></span>
<span id="cb177-43"><a href="#cb177-43"></a><span class="kw">import</span> <span class="dt">Data.TypeLevel.Num</span> <span class="kw">hiding</span> ((+), (-), (==))</span>
<span id="cb177-44"><a href="#cb177-44"></a></span>
<span id="cb177-45"><a href="#cb177-45"></a><span class="kw">import</span> <span class="dt">AESA.PC.R2</span> (wrapR2)</span>
<span id="cb177-46"><a href="#cb177-46"></a><span class="kw">import</span> <span class="dt">AESA.PC.R3</span> (wrapR3, coefsR3, addSys, mulSys, rDelaySys)</span></code></pre></div>
<p>To instantiate the logarithmic reduction tree, it is enough to replace the <code>reduce</code> skeleton with the <code>logReduce</code> skeleton in the previous <code>deepFIR</code> process network constructor.</p>
<div class="sourceCode" id="cb178" data-startFrom="52"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 51;"><span id="cb178-52"><a href="#cb178-52"></a>balancedFIR name addSys mulSys dlySys coefs <span class="ot">=</span></span>
<span id="cb178-53"><a href="#cb178-53"></a>  Sk.logReduce  (name <span class="op">L.++</span> <span class="st">&quot;_add_&quot;</span>) addSys</span>
<span id="cb178-54"><a href="#cb178-54"></a>  <span class="op">.</span> Sk.farm21   (name <span class="op">L.++</span> <span class="st">&quot;_mul_&quot;</span>) mulSys coefs</span>
<span id="cb178-55"><a href="#cb178-55"></a>  <span class="op">.</span> Sk.generate (name <span class="op">L.++</span> <span class="st">&quot;_dly_&quot;</span>) n dlySys</span>
<span id="cb178-56"><a href="#cb178-56"></a>  <span class="kw">where</span> n <span class="ot">=</span> lengthT coefs</span></code></pre></div>
<p>The new <code>procPC</code> system definition is created using the skeleton above.</p>
<div class="sourceCode" id="cb179" data-startFrom="60"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 59;"><span id="cb179-60"><a href="#cb179-60"></a><span class="ot">procPCSys&#39; ::</span> <span class="dt">SysDef</span> (  <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>)</span>
<span id="cb179-61"><a href="#cb179-61"></a>                     <span class="ot">-&gt;</span> <span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>) ) </span>
<span id="cb179-62"><a href="#cb179-62"></a>procPCSys&#39; <span class="ot">=</span> newSysDef (balancedFIR <span class="st">&quot;fir&quot;</span> addSys mulSys rDelaySys coefsR3)</span>
<span id="cb179-63"><a href="#cb179-63"></a>             <span class="st">&quot;FIR&quot;</span> [<span class="st">&quot;i1&quot;</span>] [<span class="st">&quot;o1&quot;</span>]    </span></code></pre></div>
<p>We finally create the refined version of the AESA PC<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi></mi><mrow><mo stretchy="false" form="prefix">(</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">^{(4)}</annotation></semantics></math> signal processing stage</p>
<div class="sourceCode" id="cb180" data-startFrom="67"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 66;"><span id="cb180-67"><a href="#cb180-67"></a><span class="ot">pc4 ::</span> <span class="dt">FSVec</span> <span class="dt">D8</span> (<span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>))</span>
<span id="cb180-68"><a href="#cb180-68"></a>    <span class="ot">-&gt;</span> <span class="dt">FSVec</span> <span class="dt">D8</span> (<span class="dt">Signal</span> (<span class="dt">Complex</span> <span class="dt">Fixed20</span>))</span>
<span id="cb180-69"><a href="#cb180-69"></a>pc4 <span class="ot">=</span> Sk.farm11 <span class="st">&quot;pc&quot;</span> procPCSys&#39; </span></code></pre></div>
<p>which is then declared as a component.</p>
<div class="sourceCode" id="cb181" data-startFrom="73"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 72;"><span id="cb181-73"><a href="#cb181-73"></a>sysPC4 <span class="ot">=</span> newSysDef (zipxSY <span class="st">&quot;zip&quot;</span> <span class="op">.</span> pc4 <span class="op">.</span> unzipxSY <span class="st">&quot;unzip&quot;</span>) <span class="st">&quot;PC4&quot;</span> [<span class="st">&quot;i1&quot;</span>] [<span class="st">&quot;o1&quot;</span>]</span></code></pre></div>
<h3 data-number="7.4.2" id="simulation.-synthesis-1"><span class="header-section-number">7.4.2</span> Simulation. Synthesis</h3>
<p>Similar to previous refinement phases, we wrap the PC<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi></mi><mrow><mo stretchy="false" form="prefix">(</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">^{(4)}</annotation></semantics></math> in order to co-simulate it with the high-level AESA model. As expected, the AESA simulation using this component gives exactly the same results as the previous simulation, shown in Figure <a href="#fig:deep-r3-odata">42</a>.</p>
<div class="sourceCode" id="cb182" data-startFrom="82"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 81;"><span id="cb182-82"><a href="#cb182-82"></a>wrappedPC4 <span class="ot">=</span> wrapR2 (wrapR3 (simulate sysPC4))</span></code></pre></div>
<p>Dumping the internal structure of PC<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi></mi><mrow><mo stretchy="false" form="prefix">(</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">^{(4)}</annotation></semantics></math> shows in Figure <a href="#fig:deep-gramhml-r4">45</a> a more compact FIR structure, with a shorter combinational depth, as well as one <code>"rCount"</code> component fanning out into all the delay elements.</p>
<div class="sourceCode" id="cb183" data-startFrom="88"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 87;"><span id="cb183-88"><a href="#cb183-88"></a>graphmlPC4 <span class="ot">=</span> writeGraphMLOps (defaultGraphMLOps {yFilesMarkup <span class="ot">=</span> <span class="dt">True</span>})  sysPC4</span></code></pre></div>
<p>The VHDL code can be generated</p>
<div class="sourceCode" id="cb184" data-startFrom="93"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 92;"><span id="cb184-93"><a href="#cb184-93"></a>vhdlPC4 <span class="ot">=</span> writeVHDL sysPC4</span></code></pre></div>
<p>simulated</p>
<div class="sourceCode" id="cb185" data-startFrom="97"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 96;"><span id="cb185-97"><a href="#cb185-97"></a>vhdlSim <span class="ot">=</span> writeAndModelsimVHDL <span class="dt">Nothing</span> sysPC4</span>
<span id="cb185-98"><a href="#cb185-98"></a><span class="co">-- vhdlSim&#39; = writeAndGhdlVHDL Nothing sysPC4 -- alternatively</span></span></code></pre></div>
<p>or synthesized.</p>
<div class="sourceCode" id="cb186" data-startFrom="102"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 101;"><span id="cb186-102"><a href="#cb186-102"></a>quartusPC4 <span class="ot">=</span> writeVHDLOps vhdlOps sysPC4</span>
<span id="cb186-103"><a href="#cb186-103"></a>  <span class="kw">where</span> vhdlOps    <span class="ot">=</span> defaultVHDLOps{execQuartus<span class="ot">=</span><span class="dt">Just</span> quartusOps}</span>
<span id="cb186-104"><a href="#cb186-104"></a>        quartusOps <span class="ot">=</span> checkSynthesisQuartus</span></code></pre></div>
<p>The generated circuit has exactly the same size as the previous one (tbl. <a href="#tbl:deep-spec-r4">4</a>), however, the combinational depth is visibly smaller, as seen in the RTL plot in Figure <a href="#fig:deep-quartus-r4">46</a>.</p>
<figure>
<img src="figs/GML_FIR_R4.png" id="fig:deep-gramhml-r4" alt="" /><figcaption>Figure 45: Dumped GraphML structure of the new FIR component</figcaption>
</figure>
<figure>
<img src="figs/RTLR4.png" id="fig:deep-quartus-r4" alt="" /><figcaption>Figure 46: Screenshot of the RTL view of FIR</figcaption>
</figure>
<div id="tbl:deep-spec-r4">
<table>
<caption>Table 4: Specifications of generated FPGA design</caption>
<tbody>
<tr class="odd">
<td>Top-level Entity Name</td>
<td>PC4</td>
</tr>
<tr class="even">
<td>Family</td>
<td>Cyclone IV GX</td>
</tr>
<tr class="odd">
<td>Total logic elements</td>
<td>3,014</td>
</tr>
<tr class="even">
<td>Total combinational functions</td>
<td>3,014</td>
</tr>
<tr class="odd">
<td>Dedicated logic registers</td>
<td>976</td>
</tr>
<tr class="even">
<td>Total registers</td>
<td>976</td>
</tr>
<tr class="odd">
<td>Total memory bits</td>
<td>0</td>
</tr>
<tr class="even">
<td>Embedded Multiplier 9-bit elements</td>
<td>160</td>
</tr>
<tr class="odd">
<td>Total PLLs</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="7.4.3" id="properties-3"><span class="header-section-number">7.4.3</span> Properties</h3>
<p>Here we test that the ForSyDe-Deep version of PC<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi></mi><mrow><mo stretchy="false" form="prefix">(</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">^{(4)}</annotation></semantics></math> is the same as PC<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi></mi><mrow><mo stretchy="false" form="prefix">(</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">^{(3)}</annotation></semantics></math> defined in the third phase.</p>
<div class="sourceCode" id="cb187" data-startFrom="6"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 5;"><span id="cb187-6"><a href="#cb187-6"></a><span class="ot">{-# LANGUAGE PackageImports #-}</span></span>
<span id="cb187-7"><a href="#cb187-7"></a><span class="kw">module</span> <span class="dt">TestR4</span> <span class="kw">where</span></span></code></pre></div>
<blockquote>
<div class="sourceCode" id="cb188" data-startFrom="9"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 8;"><span id="cb188-9"><a href="#cb188-9"></a><span class="kw">import</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html"><span class="dt">ForSyDe.Atom.MoC.SY</span></a> <span class="kw">as</span> <span class="dt">SY</span></span>
<span id="cb188-10"><a href="#cb188-10"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></span>
<span id="cb188-11"><a href="#cb188-11"></a><span class="kw">import</span> <span class="dt">ForSyDe.Deep</span></span></code></pre></div>
<div class="sourceCode" id="cb189" data-startFrom="13"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 12;"><span id="cb189-13"><a href="#cb189-13"></a><span class="kw">import</span> <span class="dt">Generators</span> (largeSySigs, cpxFixed20)</span>
<span id="cb189-14"><a href="#cb189-14"></a><span class="kw">import</span> <span class="dt">AESA.PC.R3</span> <span class="kw">as</span> <span class="dt">R3</span></span>
<span id="cb189-15"><a href="#cb189-15"></a><span class="kw">import</span> <span class="dt">AESA.PC.R4</span> <span class="kw">as</span> <span class="dt">R4</span></span></code></pre></div>
</blockquote>
<p>The property <span id="eq:prop_refine4_equiv"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>c</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℂ</mi></mstyle><mo>⇒</mo><mi>Σ</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="monospace"><mi>𝚙</mi><mi>𝚛</mi><mi>𝚘</mi><mi>𝚌</mi><mi>𝙿</mi><mi>𝙲</mi><mi>𝚂</mi><mi>𝚢</mi><mi>𝚜</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>Σ</mi><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="monospace"><mi>𝚙</mi><mi>𝚛</mi><mi>𝚘</mi><mi>𝚌</mi><mi>𝙿</mi><mi>𝙲</mi><mi>𝚂</mi><mi>𝚢</mi><mi>𝚜</mi><mi>′</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mover><mi>c</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mo stretchy="false" form="prefix">(</mo><mn>26</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\forall c \in \mathbb{C} \Rightarrow
\Sigma(\mathtt{procPCSys} (\overline{c})) =
\Sigma(\mathtt{procPCSys&#39;}(\overline{c}))
\qquad(26)</annotation></semantics></math></span></p>
<p>is tested by the QuickCheck program</p>
<div class="sourceCode" id="cb190" data-startFrom="26"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 25;"><span id="cb190-26"><a href="#cb190-26"></a>prop_refine4_equiv <span class="ot">=</span> forAll (largeSySigs cpxFixed20)</span>
<span id="cb190-27"><a href="#cb190-27"></a>                      <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="fu">all</span> (\(a,b) <span class="ot">-&gt;</span> a <span class="op">==</span> b) <span class="op">$</span> <span class="fu">zip</span></span>
<span id="cb190-28"><a href="#cb190-28"></a>                              (simulate R3.procPCSys  <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a> s)</span>
<span id="cb190-29"><a href="#cb190-29"></a>                              (simulate R4.procPCSys&#39; <span class="op">$</span> <a href="https://forsyde.github.io/forsyde-atom/api/ForSyDe-Atom-MoC-SY.html">SY.fromSignal</a> s)</span></code></pre></div>
<p>As all tests are passing (check the project’s <code>README</code> file on how to run tests), hence we can conclude that PC<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi></mi><mrow><mo stretchy="false" form="prefix">(</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">^{(4)}</annotation></semantics></math> is a good replacement for the AESA PC stage.</p>
<h2 data-number="7.5" id="conclusions-1"><span class="header-section-number">7.5</span> Conclusions</h2>
<p>In this section we have shown a series of design transformations on one of the high-level model components of AESA down to synthesizable VHDL code. Along the way we have co-simulated the transformed components alongside the original AESA high-level model, as well as gradually validated the final generated design artifact is a proper implementation for its behavioural model.</p>
<p>The scope of this section was two-fold: on the one hand we have shown a practical and didactic example and consolidated the design methodology introduced in the previous chapters; and on the other hand we have provided a brief glance over the current status of some of the tools and their position in the ForSyDe ecosystem, as well as directions for future development. As mentioned several times throughout this document the ForSyDe ecosystem is actively being developed and the overall vision is to learn from past and current experiences in order to achieve a correct-by-construction design flow.</p>
<p>Although all the designs shown in this report, both original and intermediate, were written manually, the modeling frameworks have provided us with the means to understand which transformations can be fully- or partially-automated in the future. For example refinement 3 should be invalidated by a unified high-level, layered modeling language; refinement 4 could be done automatically once a program analyzer understands that the core reduction operation is commutative; refinement 2 could be fully- or partially-automated once a clear design specification or constraint language can be formulated <em>and</em> analyzed. Refinement 1 though, as well as the transformation from the cube version of AESA in section <a href="#sec:atom">2</a> to the streamed version in section <a href="#sec:refine">6</a> is not so trivial to automate. This is because the nonsemantic-preserving transformations involved admit multiple (maybe better) solutions. Choosing between alternative solutions, although aided by verification and validation techniques, often relies on designer experience. In the future some of these decision could be automated or computer-aided by design space exploration techniques once we understand how to formulate the search problems.</p>
<h1 data-number="8" id="acknowledgements"><span class="header-section-number">8</span> Acknowledgements</h1>
<p>The authors would like to acknowledge Per Ericsson for his contributions in designing the AESA signal processing chain (in Figure <a href="#fig:video-chain-spec">2</a>) and in writing the specifications.</p>
<p>This report was partially funded by the Swedish Governmental Agency for Innovation Systems, NFFP7 project: Correct-by-construction design methodology #2017-04892.</p>
<h1 class="unnumbered" data-number="" id="references">References</h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-backus-1978">
<p>Backus, John. 1978. “Can Programming Be Liberated from the von Neumann Style?: A Functional Style and Its Algebra of Programs.” <em>Communications of the ACM</em> 21 (8): 613–41. <a href="https://doi.org/10.1145/359576.359579">https://doi.org/10.1145/359576.359579</a>.</p>
</div>
<div id="ref-Benveniste03">
<p>Benveniste, Albert, Paul Caspi, Stephen A. Edwards, Nicolas Halbwachs, Paul Le Guernic, and Robert de Simone. 2003. “The Synchronous Languages 12 Years Later.” <em>Proceedings of the IEEE</em> 91 (1): 64–83.</p>
</div>
<div id="ref-bourke2013zelus">
<p>Bourke, Timothy, and Marc Pouzet. 2013. “Zélus: A Synchronous Language with Odes.” In <em>Proceedings of the 16th International Conference on Hybrid Systems: Computation and Control</em>, 113–18.</p>
</div>
<div id="ref-buck93">
<p>Buck, J. T., and E. A. Lee. 1993. “Scheduling Dynamic Dataflow Graphs with Bounded Memory Using the Token Flow Model.” In <em>IEEE International Conference on Acoustics Speech and Signal Processing</em>, nil. <a href="https://doi.org/10.1109/icassp.1993.319147">https://doi.org/10.1109/icassp.1993.319147</a>.</p>
</div>
<div id="ref-claessen-2011-quick">
<p>Claessen, Koen, and John Hughes. 2011. “Quickcheck: A Lightweight Tool for Random Testing of Haskell Programs.” <em>ACM SIGPLAN</em> 46 (4): 53.</p>
</div>
<div id="ref-Fischer-2003">
<p>Fischer, Jörg, Sergei Gorlatch, and Holger Bischof. 2003. “Foundations of Data-Parallel Skeletons.” In <em>Patterns and Skeletons for Parallel and Distributed Computing</em>, edited by Fethi A. Rabhi and Sergei Gorlatch, 1–27. Springer London. <a href="https://doi.org/10.1007/978-1-4471-0097-3_1">https://doi.org/10.1007/978-1-4471-0097-3_1</a>.</p>
</div>
<div id="ref-hughes-2007">
<p>Hughes, John. 2007. “QuickCheck Testing for Fun and Profit.” In, 4354:1–32. <a href="https://doi.org/10.1007/978-3-540-69611-7_1">https://doi.org/10.1007/978-3-540-69611-7_1</a>.</p>
</div>
<div id="ref-hutton-2016">
<p>Hutton, Graham. 2016. <em>Programming in Haskell</em>. 2nd ed. New York, NY, USA: Cambridge University Press.</p>
</div>
<div id="ref-lee-2015">
<p>Lee, Edward. 2015. “The Past, Present and Future of Cyber-Physical Systems: A Focus on Models.” <em>Sensors</em> 15 (3): 4837–69. <a href="https://doi.org/10.3390/s150304837">https://doi.org/10.3390/s150304837</a>.</p>
</div>
<div id="ref-Lee18">
<p>Lee, Edward A. 2018. “Models of Timed Systems.” In <em>Formal Modeling and Analysis of Timed Systems</em>, edited by David N. Jansen and Pavithra Prabhakar, 17–33. Cham: Springer International Publishing.</p>
</div>
<div id="ref-lee2016fundamental">
<p>Lee, Edward A. 2016. “Fundamental Limits of Cyber-Physical Systems Modeling.” <em>ACM Transactions on Cyber-Physical Systems</em> 1 (1): 1–26.</p>
</div>
<div id="ref-lee95">
<p>Lee, Edward A, and Thomas M Parks. 1995. “Dataflow Process Networks.” <em>Proceedings of the IEEE</em> 83 (5): 773–801.</p>
</div>
<div id="ref-lee98">
<p>Lee, Edward A, and Alberto Sangiovanni-Vincentelli. 1998. “A Framework for Comparing Models of Computation.” <em>IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</em> 17 (12): 1217–29.</p>
</div>
<div id="ref-leeseshia-15">
<p>Lee, Edward A., and Sanjit A. Seshia. 2016. <em>Introduction to Embedded Systems: A Cyber-Physical Systems Approach</em>. Second Edition. MIT Press. <a href="http://leeseshia.org">http://leeseshia.org</a>.</p>
</div>
<div id="ref-Lipovaca11">
<p>Lipovača, Miran. 2011. <em>Learn You a Haskell for Great Good!: A Beginner’s Guide</em>. 1st ed. San Francisco, CA, USA: No Starch Press.</p>
</div>
<div id="ref-raudvere2008application">
<p>Raudvere, Tarvo, Ingo Sander, and Axel Jantsch. 2008. “Application and Verification of Local Nonsemantic-Preserving Transformations in System Design.” <em>IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</em> 27 (6): 1091–1103.</p>
</div>
<div id="ref-sander-2004">
<p>Sander, I., and A. Jantsch. 2004. “System Modeling and Transformational Design Refinement in Forsyde.” <em>IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</em> 23 (1): 17–32. <a href="https://doi.org/10.1109/tcad.2003.819898">https://doi.org/10.1109/tcad.2003.819898</a>.</p>
</div>
<div id="ref-sander-2017-forsy">
<p>Sander, Ingo, Axel Jantsch, and Seyed-Hosein Attarzadeh-Niaki. 2017. “ForSyDe: System Design Using a Functional Language and Models of Computation.” In <em>Handbook of Hardware/Software Codesign</em>, edited by Soonhoi Ha and Jürgen Teich, 99–140. Dordrecht: Springer Netherlands. <a href="https://doi.org/10.1007/978-94-017-7267-9_5">https://doi.org/10.1007/978-94-017-7267-9_5</a>.</p>
</div>
<div id="ref-Sifakis15">
<p>Sifakis, Joseph. 2015. “System Design Automation: Challenges and Limitations” 103 (November): 2093–2103.</p>
</div>
<div id="ref-skillicorn05">
<p>Skillicorn, David B. 2005. <em>Foundations of Parallel Programming</em>. 6. Cambridge University Press.</p>
</div>
<div id="ref-stuijk-2011">
<p>Stuijk, Sander, Marc Geilen, Bart Theelen, and Twan Basten. 2011. “Scenario-Aware Dataflow: Modeling, Analysis and Implementation of Dynamic Applications.” In <em>2011 International Conference on Embedded Computer Systems: Architectures, Modeling and Simulation</em>.</p>
</div>
<div id="ref-atom-manual">
<p>Ungureanu, George. 2018. <em>ForSyDe-Atom User Manual</em>. KTH Royal Institute of Technology. <a href="https://forsyde.github.io/forsyde-atom/assets/manual.pdf">https://forsyde.github.io/forsyde-atom/assets/manual.pdf</a>.</p>
</div>
<div id="ref-ungureanu-2018-bridg">
<p>Ungureanu, George, Jose E. G. de Medeiros, and Ingo Sander. 2018. “Bridging Discrete and Continuous Time Models with Atoms.” In <em>2018 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (Date)</em>, nil. <a href="https://doi.org/10.23919/date.2018.8342019">https://doi.org/10.23919/date.2018.8342019</a>.</p>
</div>
<div id="ref-ungureanu17">
<p>Ungureanu, George, and Ingo Sander. 2017. “A Layered Formal Framework for Modeling of Cyber-Physical Systems.” In <em>2017 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (Date)</em>, 1715–20. IEEE.</p>
</div>
<div id="ref-ungureanu2019">
<p>Ungureanu, George, Timmy Sundström, Anders Åhlander, Ingo Sander, and Ingemar Söderquist. 2019. “Formal Design, Co-Simulation and Validation of a Radar Signal Processing System.” In <em>Proceedings of FDL 2019: Forum on Specification &amp; Design Languages</em>.</p>
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>and other aspects, not covered in this report<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>For more information on absent semantics, check out Chapter 3 of <span class="citation" data-cites="leeseshia-15">(Edward A. Lee and Seshia <a href="#ref-leeseshia-15" role="doc-biblioref">2016</a>)</span><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>at this moment it is enough to know that both are implemented in terms of existing skeletons or process constructors. More complex behaviors such as these two will be made explicit later in section <a href="#sec:refine">6</a>. Interested readers can consult the implementations in the <code>forsyde-shallow-extensions</code> package.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>the <code>decimalCpxNum</code> generator and <code>withinRangeComplex</code> utility are defined in the <code>Generators</code> module, see section <a href="#sec:prop-gens">5.2.4</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>this type of behavior is quite naturally expressed in other paradigms, such as communicating sequential processes (CSP), rendezvous or Petri Nets. Currently ForSyDe does not support such MoCs and they are out of the scope of this report.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>we try to avoid unnecessary transposes (i.e. type traversals) which, at the moment, are not very efficiently implemented.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>actually for most of the properties in this section there are theories which can prove the preservation of semantics during certain transformations (e.g. the Bird-Merteens formalism) without the need to resort to simulation, but they are out of the scope of this report. This report rather focuses on common practices and tools for disciplined design instead.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>in fact both <code>fir</code> and <code>fir'</code> derive from the same catamorphism. For a formal proof check <span class="citation" data-cites="ungureanu2019">(Ungureanu et al. <a href="#ref-ungureanu2019" role="doc-biblioref">2019</a>)</span>.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>recall what layers are in section <a href="#sec:crash-atom">2.1</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
